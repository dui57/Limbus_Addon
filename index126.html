<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ë¦¼ë²„ìŠ¤ ì»´í¼ë‹ˆ ì• ë“œì˜¨</title>
  <style>
    :root{
      --bg:#050608;
      --bg2:#0b0d10;
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.14);

      --gold:#caa66a;
      --gold2:#f3d39a;

      --text:#eef1ff;
      --muted:rgba(238,241,255,.70);

      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius: 18px;

      --barOrange:#d95a2b;
      --barOrange2:#f07a33;

      --toneRed:#ff4b4b;
      --toneRed2:#ff6868;

      --toneGrayText: rgba(235,240,255,.40);
      --toneGrayBorder: rgba(235,240,255,.28);

      --toneNormalText: rgba(255,255,255,.92);
      --toneNormalBorder: rgba(255,255,255,.14);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1100px 700px at 15% 10%, rgba(202,166,106,.14), transparent 58%),
        radial-gradient(900px 600px at 85% 25%, rgba(243,211,154,.08), transparent 62%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      display:grid;
      place-items:start center;
      padding: 22px;
    }

    /* âœ… ì „ì²´ ì•± ìµœëŒ€ í­ í™•ì¥ (íŒ¨ì‹œë¸Œê°€ ì¢ì•„ ë³´ì´ë˜ ì›ì¸ í•´ê²°) */
    .app{ width: min(1920px, 100%); }

    .topbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 16px 18px;
      border: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .brand{ display:flex; flex-direction:column; gap:2px; }
    .brand h1{ margin:0; font-size: 20px; letter-spacing:-0.02em; }
    .brand .sub{ margin:0; font-size: 13px; color: var(--muted); }
    .pill{
      font-size: 12px;
      color: var(--muted);
      padding: 7px 10px;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: rgba(0,0,0,.22);
    }

    .screen{ margin-top: 14px; }
    .card{
      border: 1px solid var(--line);
      background: rgba(255,255,255,.05);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    button{
      border: 1px solid var(--line2);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-size: 14px;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      white-space: nowrap;
    }
    button:hover{
      background: rgba(255,255,255,.10);
      border-color: rgba(255,255,255,.22);
    }
    button:active{ transform: translateY(1px); }

    .primary{
      background: linear-gradient(180deg, rgba(202,166,106,.24), rgba(202,166,106,.10));
      border-color: rgba(202,166,106,.40);
    }
    .primary:hover{
      background: linear-gradient(180deg, rgba(202,166,106,.32), rgba(202,166,106,.14));
      border-color: rgba(202,166,106,.55);
    }
    .ghost{ background: transparent; }

    .home{ padding: 22px; }
    .home h2{ margin:0 0 6px; font-size: 18px; }
    .home p{ margin:0 0 18px; color: var(--muted); line-height: 1.6; font-size: 14px; }
    .actions{ display:flex; gap:12px; flex-wrap:wrap; }

    .toast{
      margin-top: 14px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.20);
      color: var(--muted);
      font-size: 13px;
      line-height: 1.6;
      display:none;
      white-space: pre-wrap;
    }

    /* ===== AI ìƒëŒ€ ì´ë¦„(ë‡Œíš¡) ì „ìš© í…Œë§ˆ ===== */
    .aiNameWrap{
      display:flex;
      flex-direction:column;
      gap:2px;
      line-height:1.2;
    }
    .aiNameMain{
      font-weight:1000;
      font-size:22px;
      letter-spacing:.06em;
      color:#f4d7a1;
      text-shadow:
        0 0 10px rgba(255,205,120,.22),
        0 2px 8px rgba(0,0,0,.55);
    }
    .aiNameSub{
      font-size:11px;
      font-weight:700;
      letter-spacing:.14em;
      color:rgba(255,224,170,.82);
      text-transform:uppercase;
      opacity:.95;
    }

    /* ë‡Œíš¡ ì„ íƒ ì‹œì—ë§Œ ì‚´ì§ ë” ê°•í•œ í†¤ */
    .aiNameWrap.leiheng .aiNameMain{
      color:#f6cc7a;
      text-shadow:
        0 0 14px rgba(255,196,88,.28),
        0 2px 10px rgba(0,0,0,.65);
    }
    .aiNameWrap.leiheng .aiNameSub{
      color:rgba(255,214,138,.90);
    }

    .hidden{ display:none; }

    /* âœ… í‚¤ì›Œë“œ ëª¨ë‹¬: ì¤‘ì•™ì •ë ¬ ë˜ê²Œ display:flex ê³ ì • */
    #kwModal{ display:flex; }
    #kwModal.hidden{ display:none !important; }

    /* ===== EDITOR layout ===== */
    .editor{
      display:grid;
      grid-template-columns: 280px 1fr;
      min-height: 640px;
    }
    .sidebar{
      padding: 16px;
      border-right: 1px solid var(--line);
      background: rgba(0,0,0,.18);
    }
    .sidebar h3{
      margin: 2px 0 10px;
      font-size: 14px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: .02em;
    }
    .nav{ display:flex; flex-direction:column; gap: 10px; }
    .nav button{
      text-align:left;
      padding: 12px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.04);
    }
    .nav button.active{
      border-color: rgba(202,166,106,.65);
      background: linear-gradient(180deg, rgba(202,166,106,.18), rgba(202,166,106,.07));
      box-shadow: 0 8px 25px rgba(202,166,106,.12);
    }
    .sidebar .bottom{
      margin-top: 14px;
      padding-top: 14px;
      border-top: 1px solid var(--line);
      display:flex;
      gap: 10px;
    }
    .sidebar .bottom button{ flex: 1; text-align:center; }

    /* âœ… content ê°€ìš´ë° ê³ ì • í•´ì œ (íŒ¨ì‹œë¸Œ í­ í™•ì¥) */
    .content{
      padding: 18px;
      background: rgba(255,255,255,.03);
      display:flex;
      justify-content: stretch;
    }

    .centerBoard{
      width: min(1040px, 100%);
      margin: 0 auto;
    }

    /* âœ… ì—¬ê¸°! content ì•ˆì˜ ê° íŒ¨ë„ì€ ê°€ë¡œ 100% ì‚¬ìš© */
    .content > section{ width: 100%; }

    .core-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
      align-items:start;
    }

    .frame{
      border: 1px solid rgba(202,166,106,.35);
      background: linear-gradient(180deg, rgba(12,13,16,.92), rgba(7,8,10,.92));
      border-radius: 16px;
      box-shadow: 0 18px 55px rgba(0,0,0,.40);
      overflow:hidden;
    }
    .frame .hdr{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(202,166,106,.28);
      background: linear-gradient(180deg, rgba(202,166,106,.22), rgba(143,107,50,.10));
      color: var(--gold2);
      font-weight: 700;
      letter-spacing: .02em;
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .frame .hdr .slash{
      margin-left:auto;
      width: 120px;
      height: 2px;
      background: linear-gradient(90deg, rgba(202,166,106,.0), rgba(202,166,106,.65), rgba(202,166,106,.0));
      opacity: .9;
    }
    .frame .body{ padding: 12px; }

    .name-row input, .kwInput, .numInput, .textInput, textarea{
      width:100%;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.28);
      color: var(--text);
      outline:none;
      min-width: 0;
      font-family: inherit;
    }
    .name-row input:focus, .kwInput:focus, .numInput:focus, .textInput:focus, textarea:focus{
      border-color: rgba(202,166,106,.70);
      box-shadow: 0 0 0 3px rgba(202,166,106,.14);
    }

    .portrait{
      height: 360px;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      background:
        radial-gradient(700px 320px at 30% 10%, rgba(202,166,106,.08), transparent 60%),
        rgba(0,0,0,.24);
      display:grid;
      place-items:center;
      overflow:hidden;
      position: relative;
    }
    .portrait img{
      width: 100%;
      height: 100%;
      object-fit: contain;
      display:none;
    }
    .portrait .ph{
      color: rgba(238,241,255,.55);
      font-size: 13px;
      line-height: 1.6;
      text-align:center;
      padding: 0 20px;
    }
    .upload-row{
      display:flex;
      gap: 10px;
      align-items:center;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .file{
      position: relative;
      overflow:hidden;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
      min-width: 160px;
    }
    .file input[type="file"]{
      position:absolute;
      inset:0;
      opacity:0;
      cursor:pointer;
    }

    .statList{ display:grid; grid-template-columns: 1fr; gap: 10px; }
    .rowItem{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 10px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      background: rgba(0,0,0,.22);
      min-width: 0;
      transition: border-color .15s ease;
    }
    .iconBox{
      width: 30px;
      height: 30px;
      display:grid;
      place-items:center;
      border-radius: 10px;
      border: 1px solid rgba(202,166,106,.35);
      background: rgba(0,0,0,.20);
      flex: 0 0 auto;
      overflow:hidden;
      transition: border-color .15s ease;
    }
    .iconBox img{
      width: 20px;
      height: 20px;
      object-fit: contain;
      display:block;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,.35));
    }
    .label{
      color: rgba(243,211,154,.95);
      font-weight: 800;
      white-space: nowrap;
      flex: 0 0 auto;
    }
    .grow{ flex: 1 1 auto; min-width: 0; }
    .inline{ display:flex; gap: 8px; align-items:center; min-width:0; }
    .inline .sep{ opacity:.6; font-size:12px; padding:0 4px; flex:0 0 auto; }

    .select{
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.28);
      color: var(--toneNormalText);
      outline:none;
      appearance: none;
      min-width: 0;
      text-align:center;
      transition: border-color .15s ease, color .15s ease;
    }
    .coef{
      margin-top: 4px;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: .02em;
      color: var(--toneNormalText);
      opacity: .95;
      user-select:none;
    }

    .tone-normal { --toneBorder: var(--toneNormalBorder); --toneText: var(--toneNormalText); }
    .tone-gray   { --toneBorder: var(--toneGrayBorder);   --toneText: var(--toneGrayText); }
    .tone-red    { --toneBorder: var(--toneRed);          --toneText: var(--toneRed2); }

    .physGrid{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    .physBox.tone-normal, .physBox.tone-gray, .physBox.tone-red{ border-color: var(--toneBorder); }
    .physBox.tone-normal .iconBox, .physBox.tone-gray .iconBox, .physBox.tone-red .iconBox{ border-color: var(--toneBorder); }
    .physBox.tone-normal .select, .physBox.tone-gray .select, .physBox.tone-red .select{ border-color: var(--toneBorder); color: var(--toneText); }
    .physBox.tone-normal .coef, .physBox.tone-gray .coef, .physBox.tone-red .coef{ color: var(--toneText); }

    /* sins 2 rows fixed */
    .sinsWrap{ display:flex; flex-direction:column; gap: 10px; }
    .sinsRow{ display:grid; gap: 10px; }
    .sinsRow.top{ grid-template-columns: repeat(4, 1fr); }
    .sinsRow.bottom{ grid-template-columns: repeat(3, 1fr); }

    .sinCell{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 8px;
      padding: 10px 8px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      min-width: 0;
    }
    .sinCell .sinIcon{
      width: 34px;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(202,166,106,.35);
      background: rgba(0,0,0,.22);
      display:grid;
      place-items:center;
      overflow:hidden;
    }
    .sinCell .sinIcon img{
      width: 22px;
      height: 22px;
      object-fit: contain;
      display:block;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,.35));
    }
    .sinCell .sinName{
      font-size: 13px;
      color: rgba(243,211,154,.95);
      font-weight: 800;
      letter-spacing: .01em;
      white-space: nowrap;
    }
    .sinBox.tone-normal .select, .sinBox.tone-gray .select, .sinBox.tone-red .select{ color: var(--toneText); }
    .sinBox.tone-normal .coef, .sinBox.tone-gray .coef, .sinBox.tone-red .coef{ color: var(--toneText); }

    /* stagger */
    .staggerBoard{
      border: 1px solid rgba(202,166,106,.35);
      background: linear-gradient(180deg, rgba(70,40,18,.50), rgba(35,18,10,.38));
      border-radius: 14px;
      padding: 14px 14px 12px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
    }
    .staggerBarOuter{
      border: 1px solid rgba(202,166,106,.55);
      border-radius: 999px;
      padding: 6px;
      background: rgba(0,0,0,.25);
    }
    .staggerBar{
      position: relative;
      height: 16px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.22));
      overflow: hidden;
    }
    .staggerBar .fill{
      position:absolute;
      inset:0;
      background: linear-gradient(90deg, var(--barOrange), var(--barOrange2));
      opacity: .95;
    }
    .markerLayer{ position:absolute; inset:0; pointer-events:none; }
    .marker{
      position:absolute;
      top: -5px;
      transform: translateX(-50%);
      width: 8px;
      height: 26px;
      border-radius: 2px;
      background: #f3f0e8;
      box-shadow: 0 0 0 1px rgba(0,0,0,.35), 0 8px 14px rgba(0,0,0,.35);
      opacity: .98;
    }
    .tickLayer{ position: relative; height: 22px; margin-top: 8px; }
    .tick{
      position:absolute;
      transform: translateX(-50%);
      font-weight: 900;
      font-size: 16px;
      color: rgba(243,211,154,.95);
      text-shadow: 0 2px 10px rgba(0,0,0,.45);
      white-space: nowrap;
    }
    .staggerActions{ display:flex; gap: 10px; justify-content: flex-end; margin-top: 10px; }

    .row-actions{ display:flex; gap: 10px; flex-wrap:wrap; margin-top: 12px; }

    /* ===== íŠ¹ì„± í‚¤ì›Œë“œ ===== */
    .kwWrap{ display:flex; flex-direction:column; gap: 10px; }
    .kwRow{
      display:grid;
      grid-template-columns: 1fr auto auto;
      gap: 10px;
      align-items:center;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      transition: border-color .15s ease, box-shadow .15s ease;
    }
    .kwInput{
      width:100%;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.26);
      color: var(--text);
      outline:none;
      min-width: 0;
      transition: color .15s ease, text-decoration-color .15s ease;
    }
    .kwRow .btnSmall{
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 13px;
    }
    .kwRow.deleted{
      border-color: var(--toneRed);
      box-shadow: 0 0 0 1px rgba(255,75,75,.15) inset;
    }
    .kwRow.deleted .kwInput{
      color: var(--toneRed2);
      text-decoration: line-through;
      text-decoration-color: rgba(220,220,220,.70);
      text-decoration-thickness: 2px;
    }
    .kwFooter{
      display:flex;
      justify-content:flex-end;
      margin-top: 6px;
    }

    /* ===== ì „ìš© í‚¤ì›Œë“œ í¸ì§‘ ===== */
    .dkPage{ width: min(1240px, 100%); display:flex; flex-direction:column; gap: 14px; margin:0 auto; }

    .dkTop{
      display:grid;
      grid-template-columns: 320px 1fr 300px;
      gap: 18px;
      align-items:stretch;
    }
    .box{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.18);
      padding: 12px;
    }

    .dkIconPreview{
      width: 100%;
      height: 260px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      display:grid;
      place-items:center;
      overflow:hidden;
      margin-bottom: 10px;
    }
    .dkIconPreview img{ width:100%; height:100%; object-fit: contain; display:none; }
    .dkIconPreview .ph{ color: rgba(238,241,255,.55); font-size: 12px; text-align:center; padding: 0 6px; }

    .dkButtons{ display:flex; flex-direction:column; gap: 10px; }

    .dkContentArea textarea{
      height: 320px;
      resize: vertical;
      text-align: center;
      line-height: 1.9;
      font-size: 14px;
    }

    .dkActionCol{
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    .stateBtn{
      font-weight: 900;
      letter-spacing: .02em;
    }

    #skSkillTypeBtn{ width:100%; display:block; text-align:center; }
    .stateBtn.buff{
      color: rgba(243,211,154,.95);
      border-color: rgba(202,166,106,.40);
      background: rgba(202,166,106,.12);
    }
    .stateBtn.debuff{
      color: var(--toneRed2);
      border-color: rgba(255,75,75,.50);
      background: rgba(255,75,75,.10);
    }

    .btnDanger{
      border-color: rgba(255,75,75,.35);
      background: rgba(255,75,75,.10);
    }
    .btnDanger:hover{
      border-color: rgba(255,75,75,.55);
      background: rgba(255,75,75,.14);
    }

    .dkListBox{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.16);
      padding: 12px;
      min-height: 460px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    .dkItem{
      display:grid;
      grid-template-columns: 92px 1fr 120px;
      gap: 12px;
      align-items: start;
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      cursor:pointer;
      transition: border-color .15s ease, background .15s ease;
    }
    .dkItem:hover{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.18);
    }
    .dkItem.active{
      box-shadow: 0 0 0 1px rgba(202,166,106,.25) inset;
    }

    .dkItem.buff{
      border-color: rgba(202,166,106,.60);
      background: rgba(202,166,106,.08);
    }
    .dkItem.debuff{
      border-color: rgba(255,75,75,.60);
      background: rgba(255,75,75,.06);
    }

    .dkLeft{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 10px;
      width: 100%;
      padding-top: 2px;
    }
    .dkLeftTitle{
      font-weight: 900;
      font-size: 14px;
      line-height: 1.25;
      color: rgba(243,211,154,.95);
      text-align:center;
      white-space: normal;
      word-break: break-word;
      width: 100%;
    }

    .dkMiniIcon{
      width: 64px;
      height: 64px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      overflow:hidden;
      display:grid;
      place-items:center;
    }
    .dkItem.buff .dkMiniIcon{ border-color: rgba(202,166,106,.45); }
    .dkItem.debuff .dkMiniIcon{ border-color: rgba(255,75,75,.45); }
    .dkMiniIcon img{ width:100%; height:100%; object-fit: contain; display:none; }
    .dkMiniIcon .ph{ font-size: 11px; color: rgba(238,241,255,.45); }

    .dkMeta{
      display:flex;
      flex-direction:column;
      align-items:center;
      text-align:center;
      gap: 6px;
      padding-top: 6px;
      min-width: 0;
    }
    .dkMeta .d{
      font-size: 13px;
      color: rgba(238,241,255,.75);
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-word;
      width: 100%;
    }

    .dkTag{
      font-weight: 900;
      font-size: 12px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      text-align:center;
      align-self: start;
      margin-top: 4px;
    }
    .dkTag.buff{ color: rgba(243,211,154,.95); border-color: rgba(202,166,106,.55); }
    .dkTag.debuff{ color: var(--toneRed2); border-color: rgba(255,75,75,.60); }

    .dkFooterBar{
      display:flex;
      justify-content:flex-end;
      gap: 10px;
      margin-top: 6px;
    }

    /* ===== PASSIVE (ê°œí¸) ===== */
    /* âœ… íŒ¨ì‹œë¸ŒëŠ” ê°€ë¡œë¥¼ ì œí•œí•˜ì§€ ì•Šê³ , ì‚¬ì´ë“œë°” ì˜† ë‚¨ëŠ” í­ì„ ì „ë¶€ ì‚¬ìš© */
    .passivePage{
      width: 100%;
      max-width: none;
      margin: 0;
    }

    .passTop{
      display:grid;
      grid-template-columns: 1fr;
      gap: 18px;
      align-items: stretch;
    }

    .passEditor textarea{
      height: 360px;
      resize: vertical;
      line-height: 1.85;
      font-size: 14px;
      text-align: left;
    }

    .passLabel{
      color: rgba(243,211,154,.95);
      font-weight: 900;
      margin-bottom: 6px;
    }

    .passHeaderPick{ display:flex; gap:10px; flex-wrap:wrap; }
    .pvStyleBtn.active{
      border-color: rgba(202,166,106,.70);
      background: rgba(202,166,106,.14);
    }

    .pvBoardBox{
      margin-top: 14px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.16);
      padding: 12px;
    }

    .pvBoardHead{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }

    .pvBoardHint{
      color:var(--muted);
      font-size:13px;
    }

    .pvBoardScroll{
      max-height: 560px;
      overflow:auto;
      padding: 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      border-radius: 14px;
    }

    .pvCard{
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.10);
      margin-bottom: 12px;
      border-radius: 14px;
      overflow:hidden;
      cursor:pointer;
      transition: border-color .15s ease, background .15s ease;
    }
    .pvCard:hover{
      background: rgba(255,255,255,.05);
      border-color: rgba(255,255,255,.18);
    }
    .pvCard.active{
      box-shadow: 0 0 0 1px rgba(202,166,106,.25) inset;
    }

    .pvHdr{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      font-weight: 900;
      color: rgba(255,255,255,.95);
      position: relative;
      overflow:hidden;
    }
    .pvHdr .slashes{
      margin-left:auto;
      display:flex;
      gap: 6px;
      opacity: .95;
    }
    .pvHdr .slashes i{
      width: 10px;
      height: 18px;
      transform: skewX(-20deg);
      display:block;
      background: rgba(0,0,0,.30);
    }

    .pvHdr.orange{ background: linear-gradient(90deg, #ff7a2f, #8b3b12); }
    .pvHdr.red{    background: linear-gradient(90deg, #ff3d3d, #7a1a1a); }
    .pvHdr.brown{  background: linear-gradient(90deg, #b9833c, #5a3a16); }

    .pvBody{
      padding: 12px 12px 14px;
      color: rgba(255,255,255,.92);
      line-height: 1.75;
      font-size: 13px;
      white-space: pre-wrap;
    }

    .pvHL{
      padding: 0 2px;
      border: 2px solid rgba(255,122,47,.95);
      border-radius: 0;
      background: rgba(255,122,47,.12);
      color: rgba(255,140,70,.98);
      font-weight: 900;

      text-decoration-line: underline;
      text-decoration-color: rgba(255,255,255,.92);
      text-decoration-thickness: 2px;
      text-underline-offset: 3px;
    }

    /* âœ… ì „ìš©í‚¤ì›Œë“œ í‘œì‹œ(ë²„í”„/ë””ë²„í”„ ìƒ‰) */
    .pvKW{
      font-weight: 900;
      padding: 0 2px;
      border-bottom: 2px solid rgba(255,255,255,.92);
      text-decoration: underline;
      text-decoration-color: rgba(255,255,255,.92);
      text-underline-offset: 3px;
    }
    .pvKW.buff{ color: rgba(243,211,154,.95); }
    .pvKW.debuff{ color: rgba(255,120,120,.98); }

    /* ê°•ì¡° ì•ˆì—ì„œë„ í‚¤ì›Œë“œ ìƒ‰ ìœ ì§€ */
    .pvHL .pvKW.buff{ color: rgba(243,211,154,.95); }
    .pvHL .pvKW.debuff{ color: rgba(255,120,120,.98); }

/* ===== SKILL Color Effects ===== */
.fxGreen{
  color: #6CFF9E;     /* ë°ì€ ì´ˆë¡ */
  font-weight: 900;
}

.fxBlue{
  color: #7EC8FF;     /* ë°ì€ íŒŒë‘ */
  font-weight: 900;
}

.fxRed{
  color: #FF2B2B;     /* ğŸ”¥ ë” ê°•í•œ ë¹¨ê°• */
  font-weight: 900;
}

    /* ===== responsive ===== */
    @media (max-width: 1120px){
      .core-grid{ grid-template-columns: 1fr; }
      .dkTop{ grid-template-columns: 1fr; }
      .kwRow{ grid-template-columns: 1fr; }
      .kwFooter button{ width:100%; }
      .passTop{ grid-template-columns: 1fr; }
      .pvBoardScroll{ max-height: 460px; }
    }
    @media (max-width: 980px){
      .editor{ grid-template-columns: 1fr; }
      .sidebar{ border-right:none; border-bottom:1px solid var(--line); }
      .physGrid{ grid-template-columns: 1fr; }
      .sinsRow.top{ grid-template-columns: repeat(2, 1fr); }
      .sinsRow.bottom{ grid-template-columns: repeat(2, 1fr); }
      .tick{ font-size: 14px; }
      .dkItem{ grid-template-columns: 92px 1fr; }
      .dkTag{ justify-self:start; }
    }

/* ===== SKILL (FIXED LAYOUT) ===== */
.skillPage{ width: 100%; max-width: none; }

/* ===== SKILL text line align ===== */
/* âœ… ìŠ¤í‚¬ í˜ì´ì§€ë¥¼ "ìœ„(3ì—´) + ì•„ë˜(ì €ì¥ëœ ìŠ¤í‚¬)" 2ë‹¨ìœ¼ë¡œ */
.skillEditorGrid{
  width: min(1600px, 100%);
  margin: 0 auto;
  display: grid;
  grid-template-columns: 1fr;     /* 1ì—´ ì»¨í…Œì´ë„ˆ */
  gap: 18px;
  align-items: start;
}

/* âœ… ìœ„ìª½: 3ì—´(ë¯¸ë¦¬ë³´ê¸° / í¸ì§‘ / ìŠ¤í‚¬ìˆ˜ì¹˜) */
.skillTopGrid{
  display: grid;
  grid-template-columns: 520px 1fr 340px; /* ì›í•˜ëŠ” ë¹„ìœ¨ë¡œ ì¡°ì ˆ ê°€ëŠ¥ */
  gap: 18px;
  align-items: start;
}

/* âœ… grid ìì‹ overflow/ì¹¨ë²” ë°©ì§€ í•µì‹¬ */
.skillTopGrid > *{ min-width: 0; }
.skillEditorGrid > *{ min-width: 0; }

/* ë°•ìŠ¤ê°€ ë°–ìœ¼ë¡œ íŠ€ëŠ” ê±¸ ì˜ë¼ì¤Œ */
.skillTopGrid .box{ overflow: hidden; }
.skillSavedBox{ overflow: hidden; }

.coinEffectWrapper{
  position: relative;
  width: 28px;
  height: 28px;
  flex: 0 0 auto;
}

.coinEffectFrame{
  width: 100%;
  height: 100%;
  object-fit: contain;
  display:block;
}

.coinEffectRoman{
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 12px;
  font-weight: 1000;
  color: rgba(255,255,255,.95);
  pointer-events: none;
  text-shadow: 0 2px 6px rgba(0,0,0,.65);
}

/* ===== SKILL text line align (ADD BACK) ===== */
.skLines{
  display:flex;
  flex-direction:column;
  gap:2px;
}

.skLine{
  display:grid;
  grid-template-columns: 28px 1fr; /* ì™¼ìª½ ì½”ì¸ ì¹¸ */
  gap:10px;
  align-items:start;
}

.skLead{
  display:flex;
  align-items:flex-start;
  justify-content:center;
  font-weight:1000;
  text-align:center;
  opacity:.95;
  min-width:0;
}

.skBody{
  min-width:0;
}

/* ===== Skill Preview v3 (3ë²ˆì§¸ ì´ë¯¸ì§€ ìŠ¤íƒ€ì¼) ===== */
.skillPreviewCard.v2{
  background: rgba(0,0,0,.34);
  border: 1px solid rgba(255,255,255,.14);
}

/* ===== Skill Preview v2: ì½”ì¸ -> íƒ€ì´í‹€ ìœ„, ì½”ì¸ì€ ì™¼ìª½ ì •ë ¬ ===== */
#skPreviewCard.skillPreviewCard.v2{
  width: min(420px, 100%);
  margin: 0 auto;
}

/* ì½”ì¸ ì¤„: ì™¼ìª½ ì •ë ¬ + íƒ€ì´í‹€ê³¼ ê°™ì€ í­ */
#skPreviewCard.skillPreviewCard.v2 #skCoinRow{
  display:flex;
  justify-content:flex-start;   /* âœ… ì™¼ìª½ ì •ë ¬ */
  align-items:center;
  gap:6px;
  margin: 0 auto;               /* ì¹´ë“œ ê¸°ì¤€ ì¤‘ì•™ì— â€œí­â€ë§Œ ë§ì¶¤ */
  width: 100%;
  max-width: 360px;             /* âœ… 2ë²ˆ ì´ë¯¸ì§€ ëŠë‚Œ */
}

/* ì½”ì¸ ì•„ì´ì½˜ í¬ê¸°(ì‘ê²Œ) */
#skPreviewCard.skillPreviewCard.v2 #skCoinRow .skCoinIcon{
  width:16px;
  height:16px;
}

/* íƒ€ì´í‹€ë°”ë„ ê°™ì€ í­ */
#skPreviewCard.skillPreviewCard.v2 #skTitleBar{
  width: 100%;
  max-width: 360px;
  margin: 0 auto;
}

/* í”„ë ˆì„ ìœ„ìª½ ë” compact */
.skillPreviewCard.v2 .skTop{
  gap: 10px;
}
.skillPreviewCard.v2 .skFrame{
  width: 100px;
  height: 100px;
}

/* âœ… ì½”ì¸ + íƒ€ì´í‹€ í•œ ì¤„ë¡œ */
.skHeaderRow{
  display:flex;
  align-items:center;
  gap: 10px;
}

/* ===== Skill Preview v2 (2ë²ˆ ì‚¬ì§„ ìŠ¤íƒ€ì¼) ===== */
.skillPreviewCard.v2{
  width: min(420px, 100%);      /* âœ… 2ë²ˆì²˜ëŸ¼ 'ì¹´ë“œ í­'ì„ ì¡ì•„ì¤Œ */
  margin: 0 auto;

  border: 1px solid rgba(255,255,255,.12);
  border-radius: 18px;
  background: rgba(0,0,0,.22);
  padding: 14px;

  display: flex;               /* âœ… 1ì—´ ì„¸ë¡œ ìŠ¤íƒ */
  flex-direction: column;
  gap: 12px;

  overflow: hidden;
}

.skillPreviewCard.v2 .skTop{
  display:flex;
  flex-direction: column;
  align-items:center;
  gap: 8px;
}

.skillPreviewCard.v2 .skFrame{
  width: 230px;                /* âœ… 2ë²ˆì²˜ëŸ¼ ìœ„ì— í¼ì§í•˜ê²Œ */
  height: 230px;
}

.skillPreviewCard.v2 .skTitleBar{
  width: 100%;
  max-width: 360px;
  margin: 0 auto;
}

/* âœ… 2ë²ˆ ì´ë¯¸ì§€: ì„±ì¥ê³„ìˆ˜ ë¼ì¸ */
.skillPreviewCard.v2 .skGrowthRow{
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 10px;
  margin-top: 2px;
  padding: 6px 8px;
}

.skillPreviewCard.v2 .skGrowthIcon{
  width: 18px;
  height: 18px;
  object-fit: contain;
  filter: drop-shadow(0 2px 6px rgba(0,0,0,.45));
  opacity: .95;
}

.skillPreviewCard.v2 .skGrowthText{
  font-weight: 1000;
  color: rgba(243,211,154,.95);
  text-shadow: 0 2px 10px rgba(0,0,0,.45);
  letter-spacing: -.01em;
  display:flex;
  align-items:baseline;
  gap: 6px;
}

.skillPreviewCard.v2 .skGrowthLabel{
  opacity: .92;
}

.skillPreviewCard.v2 .skGrowthPlus{
  opacity: .95;
}

/* ìŠ¤íƒ¯í‘œ v2: 2ë²ˆ ì‚¬ì§„ì²˜ëŸ¼ 'ê°ˆìƒ‰ ë°”íƒ• + ê¸ˆ ë¼ì¸' ëŠë‚Œ */
.skStatTable.skStat2col.v2{
  width: 100%;
  border: 1px solid rgba(202,166,106,.60);
  border-radius: 14px;
  overflow: hidden;
  background: rgba(25,14,8,.45);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
}

.skStatTable.skStat2col.v2 .skStatTr{
  grid-template-columns: 1fr 120px;  /* âœ… ì˜¤ë¥¸ìª½ ê°’ ì¹¸ ê³ ì • ëŠë‚Œ */
  border-bottom: 1px solid rgba(202,166,106,.22);
}

.skStatTable.skStat2col.v2 .skStatTh{
  padding: 12px 12px;
  font-weight: 1000;
  color: rgba(243,211,154,.95);
  background: rgba(45,26,14,.60);
  border-right: 1px solid rgba(202,166,106,.22);
  text-align: left;
}

.skStatTable.skStat2col.v2 .skStatTd{
  padding: 12px 12px;
  justify-content: center;      /* âœ… 2ë²ˆì²˜ëŸ¼ ê°€ìš´ë° ì •ë ¬ */
  gap: 8px;
  background: rgba(15,10,8,.35);
}

/* íš¨ê³¼ ë°•ìŠ¤: 2ë²ˆì²˜ëŸ¼ 'ë³¸ë¬¸ì´ ì•„ë˜ë¡œ ê¸¸ê²Œ' */
.skillPreviewCard.v2 .skEffectBox{
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  background: rgba(0,0,0,.25);
  padding: 12px;
  min-height: 160px;
}

/* í”„ë ˆì„/íƒ€ì´í‹€ë°” */
.skFrame{
  width: 260px;
  height: 260px;
  position: relative;
  display:grid;
  place-items:center;
}
.skFrame > img{ width: 100%; height: 100%; object-fit: contain; display:block; }
#skFrameImg{ position:absolute; inset:0; z-index:2; pointer-events:none; }

.skInner{
  position:absolute;
  top:50%;
  left:50%;
  transform: translate(-50%, -50%);

  width: 64%;
  height: 64%;
  border-radius: 999px;
  overflow:hidden;
  display:grid;
  place-items:center;
  z-index:1;
}
.skInner img{ width:100%; height:100%; object-fit:contain; display:none; }

.skTitleBar{
  width: 260px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.12);
  padding: 12px 14px;
  position: relative;
  overflow:hidden; /* âœ… stripesê°€ íŠ€ë©´ ì—¬ê¸°ì„œ ì˜ë¦¼ */
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
}
.skTitle{ font-weight: 1000; letter-spacing: -.02em; color: rgba(255,255,255,.92); text-align:left; padding-left: 6px; }

.skTitleStripes{
  position:absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%) skewX(-18deg);
  width: 54px;
  height: 22px;
  border-radius: 6px;
  background:
    linear-gradient(90deg,
      rgba(0,0,0,.0) 0%,
      rgba(0,0,0,.0) 20%,
      rgba(255,255,255,.18) 20%,
      rgba(255,255,255,.18) 32%,
      rgba(0,0,0,.0) 32%,
      rgba(0,0,0,.0) 44%,
      rgba(255,255,255,.18) 44%,
      rgba(255,255,255,.18) 56%,
      rgba(0,0,0,.0) 56%,
      rgba(0,0,0,.0) 68%,
      rgba(255,255,255,.18) 68%,
      rgba(255,255,255,.18) 80%,
      rgba(0,0,0,.0) 80%,
      rgba(0,0,0,.0) 100%);
}

/* ì½”ì¸ ì•„ì´ì½˜ */
.skCoinRow{
  display:flex;
  justify-content:center;
  gap:6px;
  margin: 8px 0 6px 0;
}
.skCoinIcon{ width: 22px; height: 22px; object-fit:contain; }

/* ===== ìŠ¤íƒ¯í‘œ (ì‚ì ¸ë‚˜ì˜´ ë°©ì§€) ===== */
.skStatTable.skStat2col{
  width: 100%;
  border: 1px solid rgba(202,166,106,.55);
  border-radius: 14px;
  overflow: hidden; /* âœ… í‘œ í…Œë‘ë¦¬ ì‚ì ¸ë‚˜ì˜´ ë°©ì§€ */
  background: rgba(0,0,0,.28);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
  min-width: 0;     /* âœ… */
}

.skStatTr{
  display: grid;
  grid-template-columns: 140px 1fr;
  border-bottom: 1px solid rgba(202,166,106,.22);
  min-width: 0;
}
.skStatTr:last-child{ border-bottom: none; }

.skStatTh{
  padding: 14px 16px;
  font-weight: 1000;
  color: rgba(243,211,154,.95);
  background: linear-gradient(180deg, rgba(60,40,18,.65), rgba(20,12,8,.45));
  border-right: 1px solid rgba(202,166,106,.22);
  letter-spacing: .01em;
  min-width: 0;
}

.skStatTd{
  padding: 14px 16px;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 10px;
  font-weight: 1000;
  color: rgba(238,241,255,.95);
  background: linear-gradient(180deg, rgba(40,26,14,.55), rgba(12,10,10,.35));
  min-width: 0;              /* âœ… */
  overflow: hidden;          /* âœ… */
  text-overflow: ellipsis;   /* âœ… */
  white-space: nowrap;       /* âœ… */
}

.skMiniIcon, .skStatIcon{
  width: 22px;
  height: 22px;
  object-fit: contain;
  flex: 0 0 auto;
  filter: drop-shadow(0 2px 6px rgba(0,0,0,.45));
}

/* ===== Coin Effect inline icon (in description text) ===== */
.coinEff{
  display:inline-flex;
  align-items:center;
  gap:6px;
  vertical-align: middle;
  margin: 0 2px;
  line-height: 0;           /* ê¸€ì line-height ì˜í–¥ ì œê±° */
}

.coinEffIcon{
  position: relative;
  width: 22px;              /* âœ… 22 -> 16 */
  height: 22px;             /* âœ… 22 -> 16 */
  flex: 0 0 22px;            /* âœ… ê³ ì • */
  display: block;
  vertical-align: middle;
  line-height: 0;
}

.coinEffIcon img{
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  display: block;
}

.coinEffRoman{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%) scale(.86); /* âœ… ì‚´ì§ ì¶•ì†Œ */
  width:100%;
  text-align:center;
  font-size: 9px;              /* âœ… ì‘ê²Œ */
  font-weight: 1000;
  letter-spacing: -0.08em;     /* âœ… ê¸´ ë¡œë§ˆìˆ«ì í­ ì¤„ì´ê¸° */
  white-space: nowrap;         /* âœ… ì¤„ë°”ê¿ˆ ê¸ˆì§€ */
  line-height: 1;              /* âœ… ìœ„ì•„ë˜ ì‚ì ¸ë‚˜ì˜´ ë°©ì§€ */
  color: rgba(255,255,255,.95);
  text-shadow: 0 2px 6px rgba(0,0,0,.70);
  pointer-events:none;
  overflow:hidden;             /* âœ… ë§ˆì§€ë§‰ ì•ˆì „ì¥ì¹˜ */
}

/* âœ… í”„ë ˆì„ ì´ë¯¸ì§€ë¥¼ ë°•ìŠ¤ì— 'ë”±' ë¶™ì—¬ì„œ ê·¸ë¦¬ê¸° */
.coinEffIcon img{
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  display: block;
}

/* íš¨ê³¼ ë°•ìŠ¤ */
.skEffectBox{
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 16px;
  background: rgba(0,0,0,.25);
  padding: 12px;
  min-height: 220px;
  white-space: pre-normal;
  line-height: 1.75;
  font-size: 13px;
  color: rgba(238,241,255,.92);
  min-width: 0;
  overflow-wrap: anywhere; /* âœ… ê¸´ í…ìŠ¤íŠ¸ë„ íŠ€ì§€ ì•Šê²Œ */
}

/* ===== í¸ì§‘ ì˜ì—­(ê°€ìš´ë°) ===== */
#skText{
  height: 320px;
  resize: vertical;
  line-height: 1.85;
  font-size: 14px;
  text-align: left;
}

/* ===== ì €ì¥ëœ ìŠ¤í‚¬(ë§¨ ì•„ë˜ ì „ì²´í­) ===== */
.skillSavedBox{
  grid-column: 1 / -1;
}

.skillSlots{
  display:flex;
  gap: 12px;
  flex-wrap: wrap;
  margin-top: 10px;
  align-items: flex-end;
}

.skSlot{
  width: 96px;
  height: 96px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.20);
  display:grid;
  place-items:center;
  overflow:hidden;
  cursor:pointer;
  position: relative;
  flex: 0 0 auto;
}

.skSlot.active{
  border-color: rgba(202,166,106,.65);
  box-shadow: 0 0 0 2px rgba(202,166,106,.18) inset;
}

.skSlot .slotFrame{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit: contain;
}

.skSlot .slotInner{
  position:absolute;
  inset:18%;           /* ë‚´ë¶€ ì›í˜• ì˜ì—­ í¬ê¸° */
  border-radius:999px;
  overflow:hidden;
  display:grid;
  place-items:center;
}

.skSlot .slotInner img{
  width:100%;
  height:100%;
  object-fit: contain;
  display:block;
}

.skSlot > img{
  width:100%;
  height:100%;
  object-fit: contain;
  display:block;
}

/* ===== ë°˜ì‘í˜• ===== */
@media (max-width: 1280px){
  .skillTopGrid{ grid-template-columns: 1fr; }
  .skillPreviewCard{ grid-template-columns: 1fr; }
  .skTitleBar, .skFrame{ width: 100%; max-width: 360px; }
}

/* ===== Coin Sign Layout (Skill) ===== */
.coinWrap{
  display:flex;
  align-items:center;
  gap:10px;
}

.coinSignBtn{
  width:44px;
  height:44px;
  display:grid;
  place-items:center;
  padding:0;
  font-weight:1000;
}

/* ===== Skill List (Saved Skills -> List Cards) ===== */
.skList{
  display:flex;
  flex-direction:column;
  gap: 12px;
  margin-top: 10px;
}

.skListCard{
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  border-radius: 16px;
  overflow:hidden;
  cursor:pointer;
  transition: background .15s ease, border-color .15s ease, transform .08s ease;
}
/* ë§¤ì¹˜ í™”ë©´ "í˜„ì¬ ë½‘ì€ ìŠ¤í‚¬" 2ì—´ ë°°ì¹˜ + ì¶•ì†Œ */
#myPickedSkills,
#enemyPickedSkills{
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap:8px;
  align-items:start;
}

#myPickedSkills .skillPickItem,
#enemyPickedSkills .skillPickItem{
  margin:0 !important;
}

.matchPickedMini{
  margin:0 !important;
  width:auto !important;
  zoom:.44;                 /* ë„ˆë¬´ ì‘ì§€ ì•Šê²Œ ì¡°ì • */
  transform-origin: top left;
}

/* ì¤Œìœ¼ë¡œ ìƒê¸°ëŠ” ì•„ë˜ ì—¬ë°± ì¤„ì´ê¸° */
#myPickedSkills .matchPickedMini,
#enemyPickedSkills .matchPickedMini{
  display:block;
}

/* ì¹´ë“œ ì•ˆ ì´ë¯¸ì§€/ë³¸ë¬¸ ê³¼í•œ ë†’ì´ ì¡°ê¸ˆ ë” ì••ì¶• */
#myPickedSkills .matchPickedMini .skListFrame,
#enemyPickedSkills .matchPickedMini .skListFrame{
  margin-bottom:4px !important;
}

#myPickedSkills .matchPickedMini .skListFx,

.stChip{display:inline-flex;align-items:center;gap:6px; padding-right:10px;}
.stChip .stIcon{width:16px;height:16px;object-fit:contain;display:block;}
.stChip .stNum{font-weight:800; font-size:11px; opacity:.95; margin-left:2px;}
#enemyPickedSkills .matchPickedMini .skListFx{
  max-height:70px !important;
}.skListCard:hover{
  background: rgba(255,255,255,.04);
  border-color: rgba(255,255,255,.18);
}
.skListCard:active{ transform: translateY(1px); }
.skListCard.active{
  box-shadow: 0 0 0 1px rgba(202,166,106,.25) inset;
  border-color: rgba(202,166,106,.35);
}

.skListTop{
  display:grid;
  grid-template-columns: 120px 1fr;
  gap: 12px;
  padding: 12px;
  align-items: start;
}

.skListArt{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap: 8px;
  min-width:0;
}
.skListFrame{
  width: 110px;
  height: 110px;
  position: relative;
  display:grid;
  place-items:center;
}
.skListFrame > img{ width:100%; height:100%; object-fit:contain; display:block; }
.skListFrame .inner{
  position:absolute;
  inset: 18%;
  border-radius: 999px;
  overflow:hidden;
  display:grid;
  place-items:center;
}
.skListFrame .inner img{ width:100%; height:100%; object-fit:contain; display:block; }

/* âœ… ìŠ¤í‚¬ ëª©ë¡ í”„ë ˆì„/ë‚´ë¶€ ì´ë¯¸ì§€ ë ˆì´ì–´ ê³ ì • (í”„ë ˆì„ì´ í•­ìƒ ìœ„) */
.skListFrame{
  position: relative;
  overflow: hidden; /* í˜¹ì‹œ ëª¨ë¥¼ ì‚ì ¸ë‚˜ì˜´ ë°©ì§€ */
}

/* í”„ë ˆì„ ì´ë¯¸ì§€ë¥¼ 'ìœ„'ë¡œ */
.skListFrame > img{
  position: absolute;
  inset: 0;
  z-index: 2;
  pointer-events: none;
}

/* ìœ ì € ì´ë¯¸ì§€(ë‚´ë¶€)ë¥¼ 'ì•„ë˜'ë¡œ + ì›í˜• í´ë¦½ ìœ ì§€ */
.skListFrame .inner{
  position: absolute;
  inset: 18%;
  z-index: 1;
  border-radius: 999px;
  overflow: hidden;
}

/* ë‚´ë¶€ ì´ë¯¸ì§€ëŠ” í´ë¦½ ì•ˆì—ì„œë§Œ */
.skListFrame .inner img{
  width: 100%;
  height: 100%;
  object-fit: contain; /* ë¯¸ë¦¬ë³´ê¸°ë‘ ë™ì¼ ëŠë‚Œì´ë©´ contain */
  display: block;
}

.skListCoins{
  display:flex;
  justify-content:center;
  gap: 4px;
}
.skListCoins img{ width: 16px; height: 16px; object-fit:contain; }

.skListMain{
  min-width:0;
  display:flex;
  flex-direction:column;
  gap: 10px;
}

.skListTitleBar{
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.12);
  padding: 10px 12px;
  position: relative;
  overflow:hidden;
  box-shadow: 0 10px 30px rgba(0,0,0,.25);
}
.skListTitle{
  font-weight: 1000;
  letter-spacing: -.02em;
  color: rgba(255,255,255,.92);
  padding-left: 4px;
  white-space: nowrap;
  overflow:hidden;
  text-overflow: ellipsis;
}

.skListStat{
  width: 100%;
  border: 1px solid rgba(202,166,106,.35);
  border-radius: 14px;
  overflow:hidden;
  background: rgba(0,0,0,.22);
}
.skListStatRow{
  display:grid;
  grid-template-columns: 120px 1fr;
  border-bottom: 1px solid rgba(202,166,106,.18);
}
.skListStatRow:last-child{ border-bottom:none; }
.skListStatTh{
  padding: 10px 12px;
  font-weight: 1000;
  color: rgba(243,211,154,.95);
  background: rgba(60,40,18,.45);
  border-right: 1px solid rgba(202,166,106,.18);
}
.skListStatTd{
  padding: 10px 12px;
  display:flex;
  align-items:center;
  justify-content:flex-end;
  gap: 8px;
  font-weight: 1000;
  color: rgba(238,241,255,.92);
  background: rgba(20,12,8,.25);
}

.skListActions{
  padding: 0 12px 12px;
  display:flex;
  justify-content:center;
}

.skListToggle{
  width: 100%;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
  padding: 10px 12px;
  font-weight: 1000;
  color: rgba(243,211,154,.95);
  cursor:pointer;
}
.skListToggle:hover{
  background: rgba(255,255,255,.04);
  border-color: rgba(255,255,255,.18);
}

.skListBody{
  padding: 0 12px 12px;
  display:none;
}
.skListBody.open{ display:block; }

.skListEffect{
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  background: rgba(0,0,0,.25);
  padding: 12px;
  white-space: pre-wrap;
  line-height: 1.75;
  font-size: 13px;
  color: rgba(238,241,255,.92);
}

/* ë°˜ì‘í˜• */
@media (max-width: 980px){
  .skListTop{ grid-template-columns: 1fr; }
  .skListArt{ flex-direction:row; justify-content:center; }
}

/* ===== Keyword Tooltip ===== */
.kwTip.hidden{ display:none; }

.kwTip{
  position: fixed;
  z-index: 9999999;
  pointer-events: none; /* íˆ´íŒ ìœ„ì— ë§ˆìš°ìŠ¤ê°€ ì˜¬ë¼ê°€ë„ ê¹œë¹¡ì„ ë°©ì§€ */
}

/* ===== Keyword Modal Buff/Debuff Toggle ===== */
.kwStateToggle{
  font-weight: 900;
  font-size: 13px;
  padding: 8px 12px;
  border-radius: 12px;
  background: rgba(0,0,0,.18);
  border: 2px solid rgba(243,211,154,.95); /* ê¸°ë³¸: ë²„í”„(ë…¸ë€ í…Œë‘ë¦¬) */
  color: rgba(243,211,154,.98);
}

.kwStateToggle.debuff{
  border-color: rgba(255,75,75,.90);       /* ë””ë²„í”„: ë¹¨ê°„ í…Œë‘ë¦¬ */
  color: rgba(255,120,120,.98);            /* ë””ë²„í”„: ë¹¨ê°„ ê¸€ì”¨ */
}

/* ===== Keyword Modal Tabs ===== */
.kwTabs{
  display:flex;
  gap:8px;
  padding:6px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.22);
  border-radius: 999px;
}

.kwTab{
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 900;
  border: 1px solid rgba(255,255,255,.10);
  background: transparent;
  color: rgba(238,241,255,.70);
}

.kwTab.active{
  color: rgba(243,211,154,.98);
  border-color: rgba(202,166,106,.55);
  background: rgba(202,166,106,.14);
}

.kwTipBox{
  width: min(380px, 90vw);
  border: 1px solid rgba(255,255,255,.14);
  border-radius: 14px;
  background: rgba(10,10,12,.96);
  box-shadow: 0 18px 60px rgba(0,0,0,.60);
  padding: 12px;
  display: grid;
  grid-template-columns: 68px 1fr;
  gap: 12px;
}

.kwTipIcon{
  width: 68px; height: 68px;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.25);
  overflow: hidden;
  display: grid;
  place-items: center;
}
.kwTipIcon img{
  width: 100%;
  height: 100%;
  object-fit: contain;
  display:block;
}

.kwTipTitle{
  font-weight: 900;
  margin-bottom: 6px;
}

/* ë²„í”„ */
.kwTipTitle.buff{
  color: rgba(243,211,154,.95);
}

/* ë””ë²„í”„ */
.kwTipTitle.debuff{
  color: rgba(255,120,120,.98);
}
.kwTipText{
  white-space: pre-wrap;
  line-height: 1.6;
  font-size: 13px;
  color: rgba(238,241,255,.85);
}

.kwTipTitle.debuff{
  color: rgba(255,120,120,.98);
}
.kwTipTitle.buff{
  color: rgba(243,211,154,.95);
}

/* ===== Skill List (Grid) ===== */
#skListNormal,
#skListSpecial{
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
  gap: 14px;
  align-items: start;
}

/* í™”ë©´ ë„“ì„ ë•Œ ì¡°ê¸ˆ ë” ì´˜ì´˜í•˜ê²Œ */
@media (min-width: 1400px){
  #skListNormal,
  #skListSpecial{
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
  }
}

/* === Saved Skill Card -> v2(ì„¸ë¡œ 1ì—´) === */
.skListCard{
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  border-radius: 18px;
  overflow:hidden;
}

.skListTop{
  display:flex;
  flex-direction: column;
  align-items:center;
  gap: 12px;
  padding: 14px;
}

.skListArt{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap: 8px;
}

.skListFrame{
  width: 230px;
  height: 230px;
}

.skListCoins{
  display:flex;
  justify-content:center;
  gap:6px;
}

.skListTitleBar{
  width: 100%;
  max-width: 360px;
  margin: 0 auto;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.12);
  padding: 12px 14px;
  position: relative;
  overflow:hidden;
  box-shadow: 0 10px 30px rgba(0,0,0,.25);
}

.skListTitle{
  font-weight: 1000;
  letter-spacing: -.02em;
  color: rgba(255,255,255,.92);
  padding-left: 6px;
  text-align:left;
  white-space: nowrap;
  overflow:hidden;
  text-overflow: ellipsis;
}

/* ê³µê²©ë ˆë²¨/ì„±ì¥ê³„ìˆ˜ ì¤„ */
.skListGrowthRow{
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 10px;
  margin-top: 2px;
  padding: 6px 8px;
}

.skListGrowthIcon{
  width: 18px;
  height: 18px;
  object-fit: contain;
  filter: drop-shadow(0 2px 6px rgba(0,0,0,.45));
  opacity: .95;
}

.skListGrowthText{
  font-weight: 1000;
  color: rgba(243,211,154,.95);
  text-shadow: 0 2px 10px rgba(0,0,0,.45);
  letter-spacing: -.01em;
  display:flex;
  align-items:baseline;
  gap: 6px;
}

/* ìŠ¤íƒ¯í‘œë¥¼ ë¯¸ë¦¬ë³´ê¸°(v2) ìŠ¤íƒ€ì¼ë¡œ */
.skListStat{
  width: 100%;
  max-width: 360px;
  border: 1px solid rgba(202,166,106,.60);
  border-radius: 14px;
  overflow: hidden;
  background: rgba(25,14,8,.45);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
}

.skListStatRow{
  display:grid;
  grid-template-columns: 1fr 120px;
  border-bottom: 1px solid rgba(202,166,106,.22);
}
.skListStatRow:last-child{ border-bottom:none; }

.skListStatTh{
  padding: 12px 12px;
  font-weight: 1000;
  color: rgba(243,211,154,.95);
  background: rgba(45,26,14,.60);
  border-right: 1px solid rgba(202,166,106,.22);
  text-align:left;
}

.skListStatTd{
  padding: 12px 12px;
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 8px;
  font-weight: 1000;
  color: rgba(238,241,255,.92);
  background: rgba(15,10,8,.35);
}

/* ===== View Mode (Read Only) ===== */
.readonly input,
.readonly textarea,
.readonly select{
  pointer-events:none;
  opacity:.92;
}
.readonly .file input[type="file"]{ pointer-events:none; }
.readonly .row-actions,
.readonly .dkFooterBar,
.readonly #pvAddBtn,
.readonly #pvSaveBtn,
.readonly #pvDeleteBtn,
.readonly #dkAddBtn,
.readonly #dkSaveBtn,
.readonly #dkDeleteBtn,
.readonly #btnSaveCore,
.readonly #btnResetCore,
.readonly #skSaveBtn,
.readonly #skNewBtn,
.readonly #skDeleteBtn,
.readonly #btnClearImg,
.readonly #dkIconClear,
.readonly #skImgClear{
  display:none !important;
}

/* ===== View Mode: CORE ì „ìš© UI ì •ë¦¬ ===== */
.readonly .upload-row{ display:none !important; }      /* âœ… ì´ë¯¸ì§€ ì—…ë¡œë“œ/ì œê±° ì¤„ í†µì§¸ë¡œ ì œê±° */
.readonly .staggerActions{ display:none !important; }  /* âœ… ííŠ¸ ì¶”ê°€/ì‚­ì œ ë²„íŠ¼ ì œê±° */

/* ===== View Mode: trait keyword chips ===== */
.traitChips{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center;
}

.traitChip{
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(202,166,106,.35);
  background: rgba(0,0,0,.18);
  color: rgba(243,211,154,.95);
  font-weight: 900;
  font-size: 13px;
  line-height: 1.2;
}

.traitChip.deleted{
  border-color: rgba(255,75,75,.55);
  color: rgba(255,120,120,.98);
  text-decoration: line-through;
  text-decoration-thickness: 2px;
  text-decoration-color: rgba(255,180,180,.95);
}

/* ===== View Mode: trait keyword line ===== */
.traitLine{
  border: 1px solid rgba(202,166,106,.40);
  border-radius: 14px;
  background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.18));
  padding: 12px 14px;
  color: rgba(243,211,154,.95);
  font-weight: 900;
  letter-spacing: -.01em;
  line-height: 1.45;
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
}

.readonly #traitKwList{ display:none !important; }  /* âœ… ê¸°ì¡´ í¸ì§‘ ë¦¬ìŠ¤íŠ¸ ìˆ¨ê¹€ */
.readonly .kwFooter{ display:none !important; }     /* âœ… 'í‚¤ì›Œë“œ ì¶”ê°€' ë²„íŠ¼ ì˜ì—­ ìˆ¨ê¹€ */

/* ===== View Mode: Name title vibe ===== */
.readonly #charName{
  background: linear-gradient(180deg, rgba(0,0,0,.40), rgba(0,0,0,.22));
  border-color: rgba(202,166,106,.45);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.25), 0 10px 30px rgba(0,0,0,.35);
  padding: 14px 16px;
}

/* âœ… í¸ì§‘ëª¨ë“œì—ì„œëŠ” ë³´ê¸°ì „ìš© ìš”ì•½(ì¹©) ìˆ¨ê¹€ */
.traitLine{ display:none; }
.readonly .traitLine{ display:block; }

/* ===== View Mode: PASSIVE ì „ìš© UI ì •ë¦¬ ===== */
.readonly #panel-passive .passTop{ 
  display:none !important;            /* âœ… ìœ„ í¸ì§‘ë€ í†µì§¸ë¡œ ì œê±° */
}

.readonly #panel-passive .pvBoardHead{
  display:none !important;            /* âœ… "ì•„ë˜ ëª©ë¡ì—ì„œ..." + ì¶”ê°€ë²„íŠ¼ ì¤„ ì œê±° */
}

.readonly #panel-passive .pvBoardBox{
  margin-top: 0 !important;           /* âœ… ìœ„ê°€ ì‚¬ë¼ì ¸ì„œ ëœ¨ëŠ” ì—¬ë°± ì œê±° */
}

/* ===== View Mode: SKILL ì „ìš© (ëª©ë¡ë§Œ ë‚¨ê¸°ê¸°) ===== */
.readonly #panel-skill .skillTopGrid{
  display:none !important;   /* âœ… ë¯¸ë¦¬ë³´ê¸°/í¸ì§‘/ìˆ˜ì¹˜ 3ì—´ í†µì§¸ë¡œ ìˆ¨ê¹€ */
}
.readonly #panel-skill .skillSavedBox{
  display:block !important;  /* âœ… ìŠ¤í‚¬ ëª©ë¡ì€ ìœ ì§€ */
}

/* ===== View Mode: PASSIVE only list ===== */
.readonly #panel-passive .passTop{ display:none !important; }      /* ìœ„ í¸ì§‘ë€ ì œê±° */
.readonly #panel-passive .pvBoardHint{ display:none !important; }  /* ì•ˆë‚´ë¬¸ ì œê±° */

/* ===== View Mode: SKILL only list ===== */
.readonly #panel-skill .skillTopGrid{ display:none !important; }   /* ë¯¸ë¦¬ë³´ê¸°/í¸ì§‘/ìˆ˜ì¹˜ ì œê±° */
.readonly #panel-skill .skillSavedBox{ margin-top: 0 !important; } /* ìœ„ê°€ ì‚¬ë¼ì ¸ë„ ë¶™ê²Œ */

/* ===== View Mode: DK only list ===== */
.readonly #panel-dk .dkTop{ display:none !important; }             /* ìœ„ í¸ì§‘ 3ì¹¸ ì œê±° */
.readonly #panel-dk .dkListBox > div:first-child{ display:none !important; } /* ì•ˆë‚´ë¬¸ ì œê±° */

/* ===== Skill Kind Toggle ===== */
.skKindToggle{
  display:flex;
  gap:8px;
}

.skKindBtn{
  flex:1;
  border-radius:12px;
  font-weight:900;
  padding:10px 12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.20);
  color: rgba(238,241,255,.82);
}

.skKindBtn.active{
  color: rgba(243,211,154,.98);
  border-color: rgba(202,166,106,.60);
  background: rgba(202,166,106,.14);
  box-shadow: 0 0 0 1px rgba(202,166,106,.16) inset;
}

#skSpawnWrap.disabled{
  opacity:.55;
}
#skSpawnWrap.disabled input{
  pointer-events:none;
}

#sanityPanicText, #sanityGainText, #sanityLossText{
  width:100%;
  min-height:84px;
  resize:vertical;
}

/* ===== AI ìƒëŒ€ í…Œë§ˆ í…ìŠ¤íŠ¸ (ë‡Œíš¡) ===== */
.aiEnemyName.leiheng{
  font-weight: 1000;
  font-size: 18px;
  line-height: 1.15;
  letter-spacing: .3px;
  color: #f1c25a;
  text-shadow:
    0 0 10px rgba(180,20,20,.35),
    0 1px 0 rgba(0,0,0,.85);
}

.aiEnemySub.leiheng{
  margin-top: 2px;
  font-weight: 900;
  font-size: 13px;
  letter-spacing: .2px;
  color: #ffd46f;
  text-shadow:
    0 0 8px rgba(140,10,10,.28),
    0 1px 0 rgba(0,0,0,.85);
}

.aiEnemyDesc{
  margin-top: 10px;
  color: rgba(238,241,255,.95);
}

/* ===== ë‡Œíš¡ í…Œë§ˆ í…ìŠ¤íŠ¸ ===== */
.lhThemeName{
  display:block;
  font-weight:1000;
  letter-spacing:.04em;
  line-height:1.05;
  color:#d7ecff;
  text-shadow:
    0 0 10px rgba(110,190,255,.35),
    0 0 20px rgba(80,150,255,.20),
    0 2px 10px rgba(0,0,0,.65);
}

.lhThemeSub{
  display:block;
  margin-top:3px;
  font-size:12px;
  font-weight:800;
  letter-spacing:.12em;
  color:rgba(188,222,255,.92);
  text-shadow: 0 1px 8px rgba(0,0,0,.55);
}

.lhThemeMeta{
  border:1px solid rgba(120,190,255,.22) !important;
  background:
    linear-gradient(180deg, rgba(70,120,170,.14), rgba(20,30,45,.14)),
    rgba(255,255,255,.04) !important;
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.03),
    0 8px 20px rgba(0,0,0,.18);
}

/* ===== AI ì  ë©”íƒ€ í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ìœ ì§€ ===== */
#playEnemyCharMeta{
  white-space: pre-line;
}

/* ===== ë‡Œíš¡ ì´ë¦„ í…Œë§ˆ ===== */
#playEnemyCharMeta .aiNameLei{
  display:block;
  font-weight: 1000;
  font-size: 20px;
  line-height: 1.1;
  letter-spacing: .04em;
  color: #ffd87a;
  text-shadow:
    0 0 10px rgba(255,140,40,.35),
    0 0 20px rgba(255,70,70,.25),
    0 2px 8px rgba(0,0,0,.65);
}

/* ===== ë‡Œíš¡ ë¶€ì œ í…Œë§ˆ ===== */
#playEnemyCharMeta .aiSubLei{
  display:block;
  margin-top: 2px;
  margin-bottom: 8px;
  font-weight: 800;
  font-size: 12px;
  letter-spacing: .10em;
  color: rgba(255,215,130,.92);
  text-shadow: 0 1px 6px rgba(0,0,0,.55);
}

.aiInfoActions{
  margin-top:10px;
  display:flex;
  gap:8px;
}

.aiWaveInfoPanel{
  margin-top:10px;
  border:1px solid rgba(255,255,255,.12);
  border-radius:14px;
  background:rgba(0,0,0,.22);
  overflow:hidden;
}

.aiWaveInfoPanel.hidden{ display:none; }

.aiWaveInfoHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  padding:10px 12px;
  border-bottom:1px solid rgba(255,255,255,.08);
  background:rgba(255,255,255,.03);
}
.aiWaveInfoHead .t{
  font-weight:900;
  color:rgba(243,211,154,.95);
}
.aiWaveInfoHead .x{
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.18);
  color:rgba(238,241,255,.9);
  border-radius:10px;
  padding:6px 10px;
  cursor:pointer;
}

.aiWaveInfoList{
  padding:10px;
  display:grid;
  gap:8px;
}

.aiWaveCard{
  border:1px solid rgba(255,255,255,.10);
  border-radius:12px;
  background:rgba(255,255,255,.02);
  padding:10px;
  display:grid;
  gap:8px;
}
.aiWaveTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.aiWaveTitle{
  font-weight:900;
  color:rgba(238,241,255,.96);
}
.aiWaveTag{
  font-size:12px;
  font-weight:900;
  padding:5px 8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.18);
}
.aiWaveTag.boss{
  color:rgba(255,120,120,.98);
}
.aiWaveTag.enemy{
  color:rgba(243,211,154,.95);
}
.aiWaveDesc{
  color:rgba(238,241,255,.72);
  font-size:13px;
  white-space:pre-wrap;
}
.aiWaveBtn{
  justify-self:start;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.18);
  color:rgba(238,241,255,.92);
  border-radius:10px;
  padding:7px 10px;
  cursor:pointer;
}
.aiWaveBtn[disabled]{
  opacity:.5;
  cursor:not-allowed;
}


/* ===== MATCH CINEMATIC ===== */
.matchCinematic{
  margin-top:12px;
  border:1px solid rgba(202,166,106,.30);
  border-radius:16px;
  background:linear-gradient(180deg, rgba(20,16,10,.88), rgba(6,8,12,.92));
  padding:12px;
  min-height:220px;
  box-shadow:0 12px 30px rgba(0,0,0,.28);
}
.matchCineHeader{
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  margin-bottom:10px;
}
.matchCineTitle{
  font-size:13px; font-weight:1000; color:rgba(243,211,154,.95); letter-spacing:.3px;
}
.matchCineSub{
  font-size:11px; color:var(--muted);
}
.matchCineArena{
  display:grid; grid-template-columns:minmax(0,1fr) 108px minmax(0,1fr); gap:10px; align-items:start;
}
.matchCineSide{
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  background:rgba(255,255,255,.03);
  padding:10px;
  min-height:150px;
}
.matchCineSide.enemy{ border-color:rgba(255,120,120,.18); }
.matchCineSide.my{ border-color:rgba(202,166,106,.24); }
.matchCineName{
  font-size:12px; font-weight:1000; color:#fff; margin-bottom:4px;
}
.matchCineSkill{
  font-size:15px; font-weight:1000; color:rgba(243,211,154,.97); line-height:1.25;
}
.matchCineMeta{
  margin-top:6px;
  font-size:12.5px;
  line-height:1.25;
  color:rgba(200,225,255,.92);
  letter-spacing:.2px;
}
.matchCineMeta b{ color:var(--text); font-weight:800; }
.matchCineMeta .metaSep{ opacity:.7; padding:0 6px; }
.matchCineMeta .metaBoost{ color:#7fd0ff; font-weight:800; }
.matchCineMeta .miniChip{ display:inline-flex; align-items:center; padding:1px 6px; border-radius:999px; border:1px solid rgba(127,208,255,.35); background:rgba(20,70,110,.35); color:#9fe3ff; font-weight:900; font-size:11px; line-height:1; white-space:nowrap; }
.matchCineMeta .metaTag{ display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border:1px solid rgba(140,190,255,.22); background:rgba(30,50,80,.25); border-radius:999px; }
.matchCineMeta .metaSub{ opacity:.85; }
.matchCineMeta .metaKey{ opacity:.95; }
.matchCineCoins{
  margin-top:12px; display:flex; flex-wrap:wrap; gap:6px;
}
.matchCineCoin{
  width:34px; height:34px; border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.25);
  display:grid; place-items:center;
  overflow:hidden;
  transform:scale(1);
  transition:transform .16s ease, box-shadow .16s ease, opacity .16s ease;
}
.matchCineCoin img{
  width:100%; height:100%; object-fit:contain; display:block;
}
.matchCineCoin.flip{
  transform:scale(1.12);
  box-shadow:0 0 0 2px rgba(243,211,154,.18), 0 8px 20px rgba(0,0,0,.25);
}
.matchCineCoin.broken{
  opacity:.3;
  filter:grayscale(1);
}
.matchCineCenter{
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:8px; min-height:150px;
}
.matchCineVs{
  font-size:20px; font-weight:1000; color:rgba(243,211,154,.95);
}
.matchCineRound{
  font-size:12px; color:var(--muted); font-weight:800;
}
.matchCineScore{
  font-size:22px; font-weight:1000; color:#fff; line-height:1;
  white-space:nowrap; text-align:center; min-width:96px;
}
.matchCineResult{
  margin-top:10px;
  border:1px solid rgba(255,255,255,.08);
  border-radius:12px;
  background:rgba(0,0,0,.18);
  padding:9px 10px;
  font-size:12px;
  color:rgba(238,241,255,.9);
  min-height:38px;
}
.matchCineTag{
  display:inline-block;
  border:1px solid rgba(255,255,255,.12);
  border-radius:999px;
  padding:3px 8px;
  font-size:11px;
  font-weight:900;
  background:rgba(255,255,255,.04);
}
.matchCineTag.win{ color:rgba(243,211,154,.98); border-color:rgba(202,166,106,.38); }
.matchCineTag.draw{ color:rgba(255,255,255,.95); }
.matchCineAttack{
  margin-top:8px; display:flex; align-items:center; gap:8px; flex-wrap:wrap;
  font-size:12px; color:rgba(238,241,255,.9);
}

/* ===== MATCH UI ===== */
.matchHome{ padding: 18px; }
.matchBoard{
  display:grid;
  grid-template-columns: minmax(360px, 1fr) 420px minmax(360px, 1fr);
  gap: 14px;
  align-items:start;
}
.teamPanel{
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 16px;
  background: rgba(0,0,0,.22);
  overflow:hidden;
  box-shadow: 0 12px 35px rgba(0,0,0,.28);
}
.teamPanel.enemy{
  border-color: rgba(255,120,120,.18);
}
.teamPanel.my{
  border-color: rgba(202,166,106,.30);
}

.teamHead{
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,.10);
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
}
.teamNameWrap{ min-width:0; }
.teamSide{
  font-size:11px;
  color: var(--muted);
  font-weight:700;
}
.teamName{
  font-size:16px;
  font-weight:1000;
  color: rgba(255,255,255,.95);
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.spdBadge{
  border:1px solid rgba(255,255,255,.16);
  border-radius:999px;
  padding:6px 10px;
  font-size:12px;
  font-weight:900;
  background: rgba(0,0,0,.22);
  white-space:nowrap;
}

.teamBody{
  padding: 10px;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.teamMainGrid{
  display:grid;
  grid-template-columns: 120px 1fr;
  gap:10px;
}
.portraitMini{
  height: 160px;
  border:1px solid rgba(255,255,255,.10);
  border-radius: 12px;
  background: rgba(0,0,0,.22);
  display:grid;
  place-items:center;
  overflow:hidden;
}
.portraitMini img{
  width:100%;
  height:100%;
  object-fit:contain;
  display:none;
}
.portraitMini .ph{
  color: var(--muted);
  font-size:12px;
}

.coreInfoStack{
  display:flex;
  flex-direction:column;
  gap:8px;
  min-width:0;
}

.miniBlock{
  border:1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  background: linear-gradient(180deg, rgba(0,0,0,.32), rgba(255,255,255,.03));
  padding: 10px;
}
.miniLabel{
  font-size:12px;
  font-weight:1000;
  color: rgba(243,211,154,.98);
  margin-bottom:8px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  letter-spacing:.02em;
}
.miniLabel::before{
  content:"";
  width:10px;
  height:10px;
  border-radius:3px;
  background: rgba(202,166,106,.55);
  box-shadow: 0 0 0 1px rgba(0,0,0,.35);
  margin-right:8px;
}
.miniLabel{ padding-bottom:6px; border-bottom:1px solid rgba(255,255,255,.08); }
.miniLabel > *{ display:flex; align-items:center; gap:8px; }
.miniStatGrid{
  display:flex;
  flex-direction:column;
  gap:8px;
}
.statMiniCell{
  border:1px solid rgba(255,255,255,.10);
  border-radius:12px;
  padding:10px 10px;
  background: rgba(0,0,0,.22);
  display:flex;
  flex-direction:column;
  gap:6px;
  font-size:13px;
}
.statMiniTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.statMiniCell b{ color: rgba(243,211,154,.95); font-weight:900; }
.statMiniCell span{
  font-weight:1000;
  color: rgba(255,255,255,.96);
}
.statMiniCell .val{
  font-size:14px;
}
.statBar{
  height:10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  overflow:hidden;
}
.statBarFill{
  height:100%;
  width:0%;
  border-radius:999px;
}
.statBarFill.hp{
  background: linear-gradient(90deg, rgba(217,90,43,.92), rgba(240,122,51,.92));
}
.statBarFill.shield{
  background: linear-gradient(90deg, rgba(110,190,255,.95), rgba(170,220,255,.95));
}
.statMiniCell.sanityCell{ }
.statMiniSanityWrap{ display:flex; align-items:center; gap:8px; margin-left:auto; }
.statMiniSanityBtns button{ min-width:28px; height:24px; padding:0 8px; border-radius:10px; font-size:12px; }


.staggerMiniLine{
  border:1px solid rgba(202,166,106,.25);
  border-radius:10px;
  padding:7px 8px;
  background: rgba(35,20,10,.22);
  font-size:12px;
  line-height:1.45;
  color: rgba(255,255,255,.9);
}

.staggerMiniWrap{
  border:1px solid rgba(255,255,255,.10);
  border-radius:10px;
  padding:8px 10px;
  background:rgba(255,255,255,.02);
}
.staggerMiniBar{
  position:relative;
  height:12px;
  border-radius:999px;
  border:1px solid rgba(202,166,106,.45);
  background:linear-gradient(90deg, rgba(217,90,43,.95), rgba(240,122,51,.95));
  overflow:hidden;
}
.staggerMiniMark{
  position:absolute;
  top:-1px;
  width:3px;
  height:14px;
  background:rgba(255,255,255,.9);
  box-shadow:0 0 0 1px rgba(0,0,0,.2);
}
.staggerMiniLabels{
  margin-top:6px;
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  font-size:12px;
  color:rgba(243,211,154,.95);
  font-weight:800;
}
.staggerMiniLabels span{
  padding:2px 6px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.18);
}

.resWrap{ display:flex; flex-direction:column; gap:6px; }
.resLine{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
}
.resChip{
  border:1px solid rgba(255,255,255,.10);
  border-radius:999px;
  padding:4px 8px;
  font-size:11px;
  background: rgba(0,0,0,.20);
  color: rgba(255,255,255,.88);
}
.resChip .k{ color: var(--muted); }
.resChip .v{ font-weight:900; }

.chipWrap{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  min-height: 24px;
}
.chip{
  border:1px solid rgba(255,255,255,.10);
  border-radius:999px;
  padding:4px 8px;
  font-size:11px;
  background: rgba(255,255,255,.03);
}
.chip.buff{
  border-color: rgba(202,166,106,.40);
  color: rgba(243,211,154,.95);
}
.chip.debuff{
  border-color: rgba(255,75,75,.45);
  color: rgba(255,120,120,.98);
}
.chip.empty{
  color: var(--muted);
  border-style:dashed;
}

.passivePreviewLine{
  color: rgba(238,241,255,.85);
  font-size:12px;
  line-height:1.45;
  min-height: 18px;
}

.slotGrid{
  display:grid;
  grid-template-columns: repeat(3, minmax(0,1fr));
  gap:8px;
}
.slotBtn{
  border:1px solid rgba(255,255,255,.12);
  border-radius:10px;
  background: rgba(0,0,0,.22);
  padding:8px;
  text-align:center;
  font-size:12px;
  cursor:pointer;
}
.slotBtn.active{
  border-color: rgba(202,166,106,.60);
  background: rgba(202,166,106,.12);
}
.slotBtn.ai{
  border-color: rgba(255,120,120,.35);
}
.resChip.danger .v{ color:#ff6b6b; font-weight:900; }
.staggerMiniLine{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; font-size:12px; }
.staggerPct{ color:rgba(243,211,154,.95); font-weight:800; }
.staggerHp{ opacity:.7; font-size:11px; margin-right:6px; }
.staggerState{ display:inline-flex; align-items:center; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.16); font-size:11px; }
.staggerState.on{ border-color:rgba(255,80,80,.5); color:#ff8d8d; background:rgba(255,70,70,.10); }
.portraitMini{ position:relative; overflow:hidden; }
.portraitMini[data-sttier="1"]::after{ content:""; position:absolute; inset:0; background:center/contain no-repeat url("assets/overlay_staggered.png"); pointer-events:none; opacity:.95; }
.portraitMini[data-sttier="2"]::after{ content:""; position:absolute; inset:0; background:center/contain no-repeat url("assets/overlay_staggered_plus.png"); pointer-events:none; opacity:.95; }
.portraitMini[data-sttier="3"]::after{ content:""; position:absolute; inset:0; background:center/contain no-repeat url("assets/overlay_staggered_plusplus.png"); pointer-events:none; opacity:.95; }
.portraitMini.isStaggered::before{ content:""; position:absolute; inset:0; background:rgba(255,0,0,.08); pointer-events:none; }
.slotBtn{ display:flex; align-items:center; justify-content:center; gap:6px; }
.slotIcWrap{ width:18px; height:18px; position:relative; display:inline-flex; align-items:center; justify-content:center; }
.slotIc{ width:18px; height:18px; object-fit:contain; }
.slotIcWrap .ph{ font-size:12px; opacity:.9; line-height:1; }
.slotNum{ font-weight:800; }

#myPickedSkills .matchPickedMini .skListTop,
#enemyPickedSkills .matchPickedMini .skListTop{ grid-template-columns: 120px minmax(0,1fr); gap:10px; }
#myPickedSkills .matchPickedMini .skListFrame,
#enemyPickedSkills .matchPickedMini .skListFrame{ width:120px; height:120px; }
#myPickedSkills .matchPickedMini .skListTitle,
#enemyPickedSkills .matchPickedMini .skListTitle{ font-size:12px; line-height:1.25; }

.pickedSkillList, .specialSkillList{
  display:flex;
  flex-direction:column;
  gap:8px;
}
.skillPickItem{
  border:1px solid rgba(255,255,255,.10);
  border-radius:10px;
  padding:8px;
  background: rgba(0,0,0,.20);
  font-size:12px;
  line-height:1.45;
}
.skillPickItem .nm{
  font-weight:900;
  color: rgba(255,255,255,.94);
}
.skillPickItem .meta{
  color: var(--muted);
  margin-top:2px;
}
.skillPickItem button{
  margin-top:6px;
  width:100%;
  padding:7px 8px;
  font-size:11px;
  border-radius: 10px;
}

.centerPanel{
  position:sticky;
  top: 14px;
}
.turnCard{
  border:1px solid rgba(202,166,106,.32);
  border-radius: 16px;
  background: linear-gradient(180deg, rgba(35,24,12,.30), rgba(0,0,0,.20));
  padding: 10px;
}
.turnTop{
  display:flex;
  justify-content:space-between;
  gap:10px;
  align-items:center;
}
.turnLabel{
  font-size:11px;
  color: var(--muted);
  font-weight:800;
}
.turnNum{
  font-size:26px;
  font-weight:1000;
  line-height:1;
  color: rgba(243,211,154,.95);
}
.turnBtns{
  display:flex;
  flex-direction:column;
  gap:8px;
}
.turnBtns button{
  padding:8px 10px;
  font-size:12px;
  border-radius:10px;
}
.turnInfoRows{
  margin-top:10px;
  display:flex;
  flex-direction:column;
  gap:6px;
}
.turnInfoRow{
  display:flex;
  justify-content:space-between;
  gap:10px;
  font-size:12px;
  border:1px solid rgba(255,255,255,.08);
  border-radius:10px;
  padding:7px 8px;
  background: rgba(0,0,0,.18);
}
.turnInfoRow span:first-child{ color: var(--muted); }
.turnInfoRow span:last-child{ font-weight:900; }

.matchLogBox{
  height: 420px;
  overflow:auto;
  padding: 10px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.25);
  border-radius: 14px;
  white-space: pre-wrap;
  line-height: 1.6;
  font-size: 12px;
  color: rgba(238,241,255,.85);
}
.matchLogLine.bleed{ color:#ff6b6b; font-weight:800; }
.matchLogLine.rupture{ color:#7CFF7A; font-weight:800; }
.matchLogLine.tremor{ color:#b48cff; font-weight:800; }
.matchLogLine.sinking{ color:#6fb8ff; font-weight:800; }
.matchLogLine.crit{ color:#ffd84d; font-weight:900; }

.matchLogLine .logIcon{width:16px;height:16px;vertical-align:-3px;margin-right:6px;filter:drop-shadow(0 1px 3px rgba(0,0,0,.55));}
.matchLogLine.burn{ color: var(--toneRed); font-weight:900; }

.matchLogLine.evade{ color: rgba(205,235,255,.92); font-weight:800; }
.matchLogLine.guard{ color: rgba(170,220,255,.92); font-weight:850; }
@media (max-width: 1480px){
  .matchBoard{
    grid-template-columns: 1fr;
  }
  .centerPanel{
    position: static;
    order: -1;
  }
}

  
.statusNumInput{
  height:36px;
  padding:0 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.28);
  color:#eef1ff;
  font-weight:800;
  outline:none;
}
.statusNumInput:focus{
  border-color: rgba(243,211,154,.55);
  box-shadow: 0 0 0 2px rgba(243,211,154,.10);
}
.statusKwBtnIcon{
  width:18px;height:18px;display:inline-flex;align-items:center;justify-content:center;
  border-radius:4px;background:rgba(0,0,0,.22);overflow:hidden;flex:0 0 18px;
}
.statusKwBtnIcon img{width:100%;height:100%;object-fit:contain;display:block;}
.statusKwBtnIcon .ph{font-size:9px;opacity:.55;line-height:1;}


.coinVoiceRow{border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px;background:rgba(255,255,255,.02);}
.coinVoiceRow .top{display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;margin-bottom:8px;}
.coinVoiceRow .title{font-weight:900;color:rgba(243,211,154,.95);}
</style>
</head>

<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">
        <h1>ë¦¼ë²„ìŠ¤ ì»´í¼ë‹ˆ ì• ë“œì˜¨</h1>
        <p class="sub">ìºë¦­í„° í¸ì§‘ + ì „ìš© í‚¤ì›Œë“œ(í”„ë¡œí† íƒ€ì…)</p>
      </div>
      <div class="pill">core v1.0</div>
    </header>

    <!-- HOME -->
    <section class="screen card" id="view-home">
      <div class="home">
        <h2>ë¦¼ë²„ìŠ¤ ì»´í¼ë‹ˆ ìµœê°•ìì „</h2>
        <p>í”Œë ˆì´í•˜ê±°ë‚˜ ìºë¦­í„°ë¥¼ ë§Œë“¤ì–´ì„œ, ìµœê°•ì„ ê°€ë ¤ë³´ì.</p>
        <div class="actions">
          <button class="primary" id="btn-play" type="button">í”Œë ˆì´</button>
          <button id="btn-go-editor" type="button">ìºë¦­í„° ë§Œë“¤ê¸°</button>
          <button id="btn-go-library" type="button">ìºë¦­í„° ë³´ê¸° ë° ë¶ˆëŸ¬ì˜¤ê¸°</button>
        </div>
        <div class="toast" id="home-toast"></div>
      </div>
    </section>

<!-- PLAY MODE SELECT -->
<section class="screen card hidden" id="view-play-mode">
  <div class="home">
    <h2>í”Œë ˆì´ ì„ íƒ</h2>
    <p>ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ í”Œë ˆì´í• ì§€ ê³¨ë¼ì¤˜.</p>

    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:14px;">
      <button id="btn-play-char" type="button" class="primary" style="padding:18px 12px; font-size:16px; font-weight:900;">
        ìºë¦­í„° ëŒ€ì „
      </button>

      <button id="btn-play-ai" type="button" style="padding:18px 12px; font-size:16px; font-weight:900;">
        AI ëŒ€ì „
      </button>
    </div>

    <div class="actions" style="margin-top:14px;">
      <button class="ghost" id="btn-play-mode-back" type="button">í™ˆìœ¼ë¡œ</button>
    </div>

    <div class="toast" id="playModeToast"></div>
  </div>
</section>

<!-- PLAY LOBBY -->
<section class="screen card hidden" id="view-play">
  <div class="home">
    <h2>ìºë¦­í„° ëŒ€ì „</h2>
    <p>ë‚´ ìºë¦­í„°ì™€ ìƒëŒ€ë¥¼ ê³¨ë¼ì„œ ë§¤ì¹˜ë¥¼ ì‹œì‘í•´.</p>

    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:14px;">
      <div class="frame" style="margin:0;">
        <div class="hdr">ë‚´ ìºë¦­í„° <span class="slash"></span></div>
        <div class="body">
          <select id="playMyChar" class="select"></select>
          <div class="toast" id="playMyCharMeta" style="display:block;margin-top:10px;"></div>
        </div>
      </div>

      <div class="frame" style="margin:0;">
        <div class="hdr">ìƒëŒ€ ìºë¦­í„° <span class="slash"></span></div>
        <div class="body">
          <select id="playEnemyChar" class="select"></select>
          <div class="toast" id="playEnemyCharMeta" style="display:block;margin-top:10px;"></div>

          <div class="aiInfoActions" style="margin-top:10px;">
            <button type="button" id="btnAiWaveInfo" class="ghost">ìƒì„¸ì •ë³´ í™•ì¸</button>
          </div>

          <div id="aiWaveInfoPanel" class="hidden" style="margin-top:10px; border:1px solid rgba(255,255,255,.12); border-radius:12px; background:rgba(0,0,0,.18);">
            <div style="display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.08);">
              <div style="font-weight:900; color:rgba(243,211,154,.95);">ì›¨ì´ë¸Œ ìƒì„¸ì •ë³´</div>
              <button type="button" id="btnAiWaveInfoClose" class="ghost" style="padding:6px 10px;">ë‹«ê¸°</button>
            </div>
            <div id="aiWaveInfoList" style="padding:10px 12px;"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="frame" id="playBgFrame" style="margin-top:12px; display:none;">
      <div class="hdr">ì „íˆ¬ ë°°ê²½ <span class="slash"></span></div>
      <div class="body">
        <select id="playBattleBg" class="select"></select>
        <div class="toast" id="playBattleBgMeta" style="display:block;margin-top:10px;">ìºë¦­í„° ëŒ€ì „ì—ì„œ ì‚¬ìš©í•  ë°°ê²½ì„ ê³ ë¥¼ ìˆ˜ ìˆì–´.</div>
      </div>
    </div>

    <div class="frame" id="playBgmFrame" style="margin-top:12px; display:none;">
      <div class="hdr">ì „íˆ¬ ìŒì•… <span class="slash"></span></div>
      <div class="body">
        <select id="playBattleBgm" class="select"></select>
        <div class="toast" id="playBattleBgmMeta" style="display:block;margin-top:10px;">ìºë¦­í„° ëŒ€ì „ì—ì„œ ì‚¬ìš©í•  ìŒì•…ì„ ê³ ë¥¼ ìˆ˜ ìˆì–´.</div>
      </div>
    </div>

    <div class="actions" style="margin-top:14px;">
      <button class="primary" id="btn-start-match" type="button">ë§¤ì¹˜ ì‹œì‘</button>
      <button id="btn-play-random" type="button">ìƒëŒ€ ëœë¤</button>
      <button class="ghost" id="btn-play-back" type="button">í™ˆìœ¼ë¡œ</button>
    </div>

    <div class="toast" id="playToast"></div>
  </div>
</section>

<!-- MATCH -->
<section class="screen card hidden" id="view-match">
  <div class="home matchHome">
    <h2>ë§¤ì¹˜</h2>
    <p id="matchTitle">-</p>

    <!-- ìƒë‹¨ ì „ì¥ -->
    <div class="matchBoard" id="matchBoard" style="margin-top:14px;">

      <!-- ë‚´ íŒ€ (ì™¼ìª½) -->
      <div class="teamPanel my" id="myPanel">
        <div class="teamHead">
          <div class="teamNameWrap">
            <div class="teamSide">ë‚´ íŒ€</div>
            <div class="teamName" id="myNameView">-</div>
          </div>
          <div class="spdBadge" id="mySpd">SPD -</div>
        </div>

        <div class="teamBody">
          <div class="teamMainGrid">
            <div class="portraitMini" id="myPortraitMini">
              <img id="myPortraitMiniImg" alt="">
              <div class="ph">ì´ˆìƒ</div>
            </div>

            <div class="coreInfoStack">
              <div class="miniBlock">
                <div class="miniLabel">ìŠ¤í…Œì´í„°ìŠ¤</div>
                <div class="miniStatGrid" id="myStatsMini"></div>
              </div>

              <div class="miniBlock">
                <div class="miniLabel">ííŠ¸ëŸ¬ì§</div>
                <div id="myStaggerMini"></div>
              </div>

              <div class="miniBlock">
                <div class="miniLabel">ë‚´ì„±</div>
                <div class="resWrap">
                  <div class="resLine" id="myPhysMini"></div>
                  <div class="resLine" id="mySinMini"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="miniBlock">
            <div class="miniLabel">í‚¤ì›Œë“œ</div>
            <div class="chipWrap" id="myKeywordsMini"></div>
          </div>

          <div class="miniBlock">
            <div class="miniLabel">ë²„í”„/ë””ë²„í”„ í˜„í™©</div>
            <div class="chipWrap" id="myStatusChips"></div>
          </div>

          <div class="miniBlock">
            <div class="miniLabel">íŒ¨ì‹œë¸Œ <button class="miniBtn" type="button" id="btnMyPassive">ìƒì„¸ì •ë³´</button></div>
            <div class="passivePreviewLine" id="myPassivePreview">-</div>
          </div>

          <div class="miniBlock">
            <div class="miniLabel">ì‚¬ìš© ê°€ëŠ¥ ìŠ¬ë¡¯</div>
            <div class="slotGrid" id="mySlots"></div>
          </div>

<div class="miniBlock">
  <div class="miniLabel">í˜„ì¬ ë½‘ì€ ìŠ¤í‚¬</div>
  <div class="pickedSkillList" id="myPickedSkills"></div>
</div>

<div class="miniBlock">
  <div class="miniLabel">íŠ¹ìˆ˜ ìŠ¤í‚¬ ëª©ë¡ (í´ë¦­ ì‹œ ì¶”ê°€)</div>
  <div class="specialSkillList" id="mySpecialSkills"></div>
</div>
        </div>
      </div>

      <!-- ê°€ìš´ë° í„´/ë¡œê·¸ -->
      <div class="centerPanel">
        <div class="turnCard">
          <div class="turnTop">
            <div>
              <div class="turnLabel">TURN</div>
              <div class="turnNum" id="matchTurnNo">1</div>
            </div>
            <div class="turnBtns">
              <button class="primary" id="btn-match-roll" type="button">ì†ë„/ìŠ¤í‚¬ ë½‘ê¸°</button>
              <button id="btn-match-next" type="button">ì „íˆ¬ ì§„í–‰</button>
              <button class="ghost" id="btn-statusRealtime" type="button" title="ìƒíƒœ(ë²„í”„/ë””ë²„í”„) í‘œì‹œ ì‹œì  í† ê¸€">ìƒíƒœí‘œì‹œ: ì¢…ë£Œ í›„</button>
            </div>
          </div>

          <div class="turnInfoRows">
            <div class="turnInfoRow">
              <span>ë‚´ ìŠ¬ë¡¯</span>
              <span id="mySlotInfo">-</span>
            </div>
            <div class="turnInfoRow">
              <span>ì  ìŠ¬ë¡¯</span>
              <span id="enemySlotInfo">-</span>
            </div>
          </div>
        </div>

        <div class="matchCinematic" id="matchCinematic">
          <div class="matchCineHeader">
            <div>
              <div class="matchCineTitle">í•© ì—°ì¶œ</div>
              <div class="matchCineSub" id="matchCineSub">ì „íˆ¬ ì§„í–‰ì„ ëˆ„ë¥´ë©´ ì—¬ê¸°ì— í•© ê³¼ì •ì´ í‘œì‹œë¼.</div>
            </div>
            <div class="matchCineTag" id="matchCineTag">ëŒ€ê¸° ì¤‘</div>
          </div>
          <div class="matchCineArena">
            <div class="matchCineSide my">
              <div class="matchCineName" id="cineMyName">ë‚´ íŒ€</div>
              <div class="matchCineSkill" id="cineMySkill">-</div>
              <div class="matchCineMeta" id="cineMyMeta">ê¸°ë³¸ê°’ - / ì½”ì¸ -</div>
              <div class="matchCineCoins" id="cineMyCoins"></div>
            </div>
            <div class="matchCineCenter">
              <div class="matchCineRound" id="cineRound">ROUND -</div>
              <div class="matchCineVs">VS</div>
              <div class="matchCineScore" id="cineScore">-</div>
            </div>
            <div class="matchCineSide enemy">
              <div class="matchCineName" id="cineEnemyName">ì </div>
              <div class="matchCineSkill" id="cineEnemySkill">-</div>
              <div class="matchCineMeta" id="cineEnemyMeta">ê¸°ë³¸ê°’ - / ì½”ì¸ -</div>
              <div class="matchCineCoins" id="cineEnemyCoins"></div>
            </div>
          </div>
          <div class="matchCineResult" id="cineResult">ì „íˆ¬ ì—°ì¶œ ëŒ€ê¸° ì¤‘</div>
          <div class="matchCineAttack" id="cineAttack"></div>
        </div>

        <div class="frame" style="margin-top:12px;">
          <div class="hdr">ì „íˆ¬ ë¡œê·¸ <span class="slash"></span></div>
          <div class="body">
            <div id="matchLog" class="matchLogBox"></div>
          </div>
        </div>
      </div>

      <!-- ì  (ì˜¤ë¥¸ìª½) -->
      <div class="teamPanel enemy" id="enemyPanel">
        <div class="teamHead">
          <div class="teamNameWrap">
            <div class="teamSide">ì </div>
            <div class="teamName" id="enemyNameView">-</div>
          </div>
          <div class="spdBadge" id="enemySpd">SPD -</div>
        </div>

        <div class="teamBody">
          <div class="teamMainGrid">
            <div class="portraitMini" id="enemyPortraitMini">
              <img id="enemyPortraitMiniImg" alt="">
              <div class="ph">ì´ˆìƒ</div>
            </div>

            <div class="coreInfoStack">
              <div class="miniBlock">
                <div class="miniLabel">ìŠ¤í…Œì´í„°ìŠ¤</div>
                <div class="miniStatGrid" id="enemyStatsMini"></div>
              </div>

              <div class="miniBlock">
                <div class="miniLabel">ííŠ¸ëŸ¬ì§</div>
                <div id="enemyStaggerMini"></div>
              </div>

              <div class="miniBlock">
                <div class="miniLabel">ë‚´ì„±</div>
                <div class="resWrap">
                  <div class="resLine" id="enemyPhysMini"></div>
                  <div class="resLine" id="enemySinMini"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="miniBlock">
            <div class="miniLabel">í‚¤ì›Œë“œ</div>
            <div class="chipWrap" id="enemyKeywordsMini"></div>
          </div>

          <div class="miniBlock">
            <div class="miniLabel">ë²„í”„/ë””ë²„í”„ í˜„í™©</div>
            <div class="chipWrap" id="enemyStatusChips"></div>
          </div>

          <div class="miniBlock">
            <div class="miniLabel">íŒ¨ì‹œë¸Œ <button class="miniBtn" type="button" id="btnEnemyPassive">ìƒì„¸ì •ë³´</button></div>
            <div class="passivePreviewLine" id="enemyPassivePreview">-</div>
          </div>

          <div class="miniBlock">
            <div class="miniLabel">ì ì´ ë½‘ì€ ìŠ¤í‚¬ / ìŠ¬ë¡¯ ì§€ì • (AI)</div>
            <div class="slotGrid" id="enemySlots"></div>
          </div>

          <div class="miniBlock">
            <div class="miniLabel">í˜„ì¬ ë½‘ì€ ìŠ¤í‚¬</div>
            <div class="pickedSkillList" id="enemyPickedSkills"></div>
          </div>
        </div>
      </div>

    </div>

    <div class="actions" style="margin-top:14px;">
      <button class="ghost" id="btn-match-exit" type="button">ë¡œë¹„ë¡œ</button>
      <button class="ghost" id="btn-match-home" type="button">í™ˆìœ¼ë¡œ</button>
    </div>

    <div class="toast" id="matchToast"></div>
  </div>
</section>
<!-- CHARACTER LIBRARY -->
<section class="screen card hidden" id="view-library">
  <div class="home">
    <h2>ìºë¦­í„° ë³´ê¸° ë° ë¶ˆëŸ¬ì˜¤ê¸°</h2>
    <p>ì €ì¥ëœ ìºë¦­í„°ë¥¼ ì„ íƒí•´ì„œ ë³´ê¸° ì „ìš©ìœ¼ë¡œ ì—´ê±°ë‚˜, í¸ì§‘ìœ¼ë¡œ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆì–´.</p>

    <div class="actions" style="margin-bottom:12px;">
      <button type="button" id="btn-import-character">íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°</button>
      <input id="importFile" type="file" accept="application/json" style="display:none;">
      <button type="button" class="primary" id="btn-save-as-character">í˜„ì¬ ì‘ì—…ì„ ìºë¦­í„°ë¡œ ì €ì¥</button>
      <button type="button" class="ghost" id="btn-lib-back">ëŒì•„ê°€ê¸°</button>
    </div>

    <div id="charList" style="display:flex; flex-direction:column; gap:12px;"></div>
    <div class="toast" id="libToast"></div>
  </div>
</section>

    <!-- EDITOR -->
    <section class="screen card hidden" id="view-editor">
      <div class="editor">
        <aside class="sidebar">
          <h3>ìºë¦­í„° í¸ì§‘</h3>
          <div class="nav">
            <button type="button" id="tab-core" class="active">í•µì‹¬ ì •ë³´</button>
            <button type="button" id="tab-passive">íŒ¨ì‹œë¸Œ í¸ì§‘</button>
            <button type="button" id="tab-skill">ìŠ¤í‚¬ í¸ì§‘</button>
            <button type="button" id="tab-dk">ì „ìš© í‚¤ì›Œë“œ í¸ì§‘</button>
          </div>
          <div class="bottom">
            <button type="button" class="ghost" id="btn-back">ëŒì•„ê°€ê¸°</button>
          </div>
        </aside>

        <main class="content">
          <!-- CORE -->
          <section id="panel-core">
            <div class="centerBoard">
              <div class="core-grid">
                <!-- LEFT -->
                <div>
                  <div class="frame">
                    <div class="hdr">ì´ë¦„ <span class="slash"></span></div>
                    <div class="body">
                      <div class="name-row">
                        <input id="charName" type="text" />
                      </div>
                    </div>
                  </div>

                  <div class="frame" style="margin-top:14px;">
                    <div class="hdr">ì´ë¯¸ì§€ <span class="slash"></span></div>
                    <div class="body">
                      <div class="portrait">
                        <img id="portraitImg" alt="ìºë¦­í„° ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°" />
                        <div class="ph" id="portraitPh">
                          ì•„ì§ ì´ë¯¸ì§€ê°€ ì—†ì–´.<br/>
                          ì•„ë˜ì—ì„œ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì— í‘œì‹œë¼.
                        </div>
                      </div>

                      <div class="upload-row">
                        <button class="primary file" type="button">
                          ì´ë¯¸ì§€ ì—…ë¡œë“œ
                          <input id="fileInput" type="file" accept="image/*" />
                        </button>
                        <button type="button" id="btnClearImg">ì´ë¯¸ì§€ ì œê±°</button>
                      </div>
                    </div>
                  </div>

                  <div class="frame" style="margin-top:14px;">
                    <div class="hdr">ííŠ¸ëŸ¬ì§ êµ¬ê°„ <span class="slash"></span></div>
                    <div class="body">
                      <div class="staggerBoard">
                        <div class="staggerBarOuter">
                          <div class="staggerBar" aria-label="ííŠ¸ëŸ¬ì§ êµ¬ê°„ ë°”">
                            <div class="fill"></div>
                            <div class="markerLayer" id="markerLayer"></div>
                          </div>
                        </div>
                        <div class="tickLayer" id="tickLayer"></div>
                      </div>

                      <div class="staggerActions">
                        <button type="button" id="btnAddStagger" class="primary">ííŠ¸ ì¶”ê°€</button>
                        <button type="button" id="btnDelStagger">ííŠ¸ ì‚­ì œ</button>
                      </div>
                    </div>
                  </div>

<div class="frame" style="margin-top:14px;">
  <div class="hdr">ì •ì‹ ë ¥ íš¨ê³¼ <span class="slash"></span></div>
  <div class="body">
    <!-- ì´ë¯¸ì§€ -->
    <div class="field">
      <div class="label">ì •ì‹ ë ¥ íš¨ê³¼ ì´ë¯¸ì§€</div>

      <div class="portrait" style="min-height:180px;">
        <img id="sanityFxImg" alt="ì •ì‹ ë ¥ íš¨ê³¼ ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°" />
        <div class="ph" id="sanityFxPh">
          ì•„ì§ ì´ë¯¸ì§€ê°€ ì—†ì–´.<br/>
          ì•„ë˜ì—ì„œ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì— í‘œì‹œë¼.
        </div>
      </div>

      <div class="upload-row" style="margin-top:10px;">
        <button class="primary file" type="button">
          ì´ë¯¸ì§€ ì—…ë¡œë“œ
          <input id="sanityFxFile" type="file" accept="image/*" />
        </button>
        <button type="button" id="btnClearSanityFxImg">ì´ë¯¸ì§€ ì œê±°</button>
      </div>
    </div>

    <!-- íŒ¨ë‹‰ íš¨ê³¼ -->
    <div class="field" style="margin-top:12px;">
      <div class="label">íŒ¨ë‹‰ íš¨ê³¼</div>
      <textarea id="sanityPanicText" rows="4" placeholder="ì˜ˆ: í„´ ì‹œì‘ ì‹œ, ê³µê²© ìœ„ë ¥ ì¦ê°€ 1 ..."></textarea>
    </div>

    <!-- ì •ì‹ ë ¥ ì¦ê°€ ì¡°ê±´ -->
    <div class="field" style="margin-top:12px;">
      <div class="label">ì •ì‹ ë ¥ ì¦ê°€ ì¡°ê±´</div>
      <textarea id="sanityGainText" rows="4" placeholder="ì˜ˆ: í•© ìŠ¹ë¦¬ ì‹œ íšŸìˆ˜ì— ë¹„ë¡€í•˜ì—¬ ì¦ê°€ ..."></textarea>
    </div>

    <!-- ì •ì‹ ë ¥ ê°ì†Œ ì¡°ê±´ -->
    <div class="field" style="margin-top:12px;">
      <div class="label">ì •ì‹ ë ¥ ê°ì†Œ ì¡°ê±´</div>
      <textarea id="sanityLossText" rows="4" placeholder="ì˜ˆ: í•© íŒ¨ë°° ì‹œ 4 ê°ì†Œ"></textarea>
    </div>
  </div>
</div>

                  <div class="row-actions">
                    <button class="primary" id="btnSaveCore" type="button">ì €ì¥</button>
                    <button id="btnResetCore" type="button">ì´ˆê¸°í™”</button>
                  </div>

                  <div class="toast" id="coreToast"></div>
                </div>

                <!-- RIGHT -->
                <div>
                  <div class="frame">
                    <div class="hdr">ìŠ¤í…Œì´í„°ìŠ¤ <span class="slash"></span></div>
                    <div class="body">
                      <div class="statList">
                        <div class="rowItem">
                          <div class="iconBox" title="ë ˆë²¨ ì•„ì´ì½˜"><img src="assets/icon_level.png" alt="ë ˆë²¨" /></div>
                          <div class="label">ë ˆë²¨</div>
                          <div class="grow"><input id="statLevel" class="numInput" type="number" min="1" step="1" /></div>
                        </div>

                        <div class="rowItem">
                          <div class="iconBox" title="ì²´ë ¥ ì•„ì´ì½˜"><img src="assets/icon_hp.png" alt="ì²´ë ¥" /></div>
                          <div class="label">ì²´ë ¥</div>
                          <div class="grow"><input id="statHp" class="numInput" type="number" min="0" step="1" /></div>
                        </div>

                        <div class="rowItem">
                          <div class="iconBox" title="ì†ë„ ì•„ì´ì½˜"><img src="assets/icon_speed.png" alt="ì†ë„" /></div>
                          <div class="label">ì†ë„</div>
                          <div class="grow inline">
                            <input id="statSpdMin" class="numInput" type="number" min="0" step="1" />
                            <span class="sep">~</span>
                            <input id="statSpdMax" class="numInput" type="number" min="0" step="1" />
                          </div>
                        </div>

                        <div class="rowItem">
                          <div class="iconBox" title="ë°©ì–´ë ˆë²¨ ì•„ì´ì½˜"><img src="assets/icon_deflv.png" alt="ë°©ì–´ë ˆë²¨" /></div>
                          <div class="label">ë°©ì–´ë ˆë²¨</div>
                          <div class="grow"><input id="statDefLv" class="numInput" type="number" min="0" step="1" /></div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div class="frame" style="margin-top:14px;">
                    <div class="hdr">ë¬¼ë¦¬ ë‚´ì„± ì •ë³´ <span class="slash"></span></div>
                    <div class="body">
                      <div class="physGrid">
                        <div class="physBox rowItem tone-normal">
                          <div class="iconBox"><img src="assets/icon_slash.png" alt="ì°¸ê²©" /></div>
                          <div class="grow">
                            <select id="physSlash" class="select"></select>
                            <div class="coef" id="coef_physSlash">[x1.0]</div>
                          </div>
                        </div>

                        <div class="physBox rowItem tone-normal">
                          <div class="iconBox"><img src="assets/icon_pierce.png" alt="ê´€í†µ" /></div>
                          <div class="grow">
                            <select id="physPierce" class="select"></select>
                            <div class="coef" id="coef_physPierce">[x1.0]</div>
                          </div>
                        </div>

                        <div class="physBox rowItem tone-normal">
                          <div class="iconBox"><img src="assets/icon_blunt.png" alt="íƒ€ê²©" /></div>
                          <div class="grow">
                            <select id="physBlunt" class="select"></select>
                            <div class="coef" id="coef_physBlunt">[x1.0]</div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div class="frame" style="margin-top:14px;">
                    <div class="hdr">ì£„ì•… ë‚´ì„± ì •ë³´ <span class="slash"></span></div>
                    <div class="body">
                      <div class="sinsWrap">
                        <div class="sinsRow top">
                          <div class="sinCell sinBox tone-normal">
                            <div class="sinName">ë¶„ë…¸</div>
                            <div class="sinIcon"><img src="assets/icon_wrath.png" alt="ë¶„ë…¸" /></div>
                            <select class="select" id="sinWrath"></select>
                            <div class="coef" id="coef_sinWrath">[x1.0]</div>
                          </div>
                          <div class="sinCell sinBox tone-normal">
                            <div class="sinName">ìƒ‰ìš•</div>
                            <div class="sinIcon"><img src="assets/icon_lust.png" alt="ìƒ‰ìš•" /></div>
                            <select class="select" id="sinLust"></select>
                            <div class="coef" id="coef_sinLust">[x1.0]</div>
                          </div>
                          <div class="sinCell sinBox tone-normal">
                            <div class="sinName">ë‚˜íƒœ</div>
                            <div class="sinIcon"><img src="assets/icon_sloth.png" alt="ë‚˜íƒœ" /></div>
                            <select class="select" id="sinSloth"></select>
                            <div class="coef" id="coef_sinSloth">[x1.0]</div>
                          </div>
                          <div class="sinCell sinBox tone-normal">
                            <div class="sinName">íƒì‹</div>
                            <div class="sinIcon"><img src="assets/icon_gluttony.png" alt="íƒì‹" /></div>
                            <select class="select" id="sinGluttony"></select>
                            <div class="coef" id="coef_sinGluttony">[x1.0]</div>
                          </div>
                        </div>

                        <div class="sinsRow bottom">
                          <div class="sinCell sinBox tone-normal">
                            <div class="sinName">ìš°ìš¸</div>
                            <div class="sinIcon"><img src="assets/icon_gloom.png" alt="ìš°ìš¸" /></div>
                            <select class="select" id="sinGloom"></select>
                            <div class="coef" id="coef_sinGloom">[x1.0]</div>
                          </div>
                          <div class="sinCell sinBox tone-normal">
                            <div class="sinName">ì˜¤ë§Œ</div>
                            <div class="sinIcon"><img src="assets/icon_pride.png" alt="ì˜¤ë§Œ" /></div>
                            <select class="select" id="sinPride"></select>
                            <div class="coef" id="coef_sinPride">[x1.0]</div>
                          </div>
                          <div class="sinCell sinBox tone-normal">
                            <div class="sinName">ì§ˆíˆ¬</div>
                            <div class="sinIcon"><img src="assets/icon_envy.png" alt="ì§ˆíˆ¬" /></div>
                            <select class="select" id="sinEnvy"></select>
                            <div class="coef" id="coef_sinEnvy">[x1.0]</div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div class="frame" style="margin-top:14px;">
                    <div class="hdr">íŠ¹ì„± í‚¤ì›Œë“œ <span class="slash"></span></div>
                    <div class="body">
                      <div class="kwWrap" id="traitKwList"></div>
                      <div class="kwFooter">
                        <button class="primary" type="button" id="btnTraitKwAdd">í‚¤ì›Œë“œ ì¶”ê°€</button>
                      </div>
                    </div>
                  </div>

                </div>
              </div>
            </div>
          </section>

          <!-- PASSIVE (ê°œí¸) -->
          <section id="panel-passive" class="hidden">
            <div class="passivePage">
              <div class="frame">
                <div class="hdr">íŒ¨ì‹œë¸Œ í¸ì§‘ <span class="slash"></span></div>
                <div class="body">
                  <!-- ìœ„: í¸ì§‘ -->
                  <div class="passTop">
                    <div class="box passEditor">
                      <div class="passRow">
                        <div class="passLabel">íŒ¨ì‹œë¸Œ ì´ë¦„</div>
                        <input id="pvName" class="textInput" type="text" placeholder="ì˜ˆ: ì˜ˆì§€ì•ˆ" />
                      </div>

                      <div class="passRow" style="margin-top:10px;">
                        <div class="passLabel">ì¤‘ìš”ë„</div>
                        <div class="passHeaderPick">
                          <button type="button" class="pvStyleBtn active" data-style="brown">ë³´í†µ</button>
                          <button type="button" class="pvStyleBtn" data-style="orange">ì¤‘ìš”</button>
                          <button type="button" class="pvStyleBtn" data-style="red">ë§¤ìš°ì¤‘ìš”</button>
                        </div>
                      </div>

                      <div class="passRow" style="margin-top:10px;">
                        <div class="passLabel">ë‚´ìš©</div>
                        <textarea id="pvText" placeholder="ë‚´ìš©ì„ ì…ë ¥í•´ì¤˜. (ê°•ì¡°ëŠ” ì•„ë˜ ë²„íŠ¼)"></textarea>
                      </div>

                      <div class="row-actions" style="margin-top:12px;">
                        <!-- âœ… í‚¤ì›Œë“œ ë²„íŠ¼ ì¶”ê°€ -->
                        <button type="button" id="pvKeywordBtn">í‚¤ì›Œë“œ</button>
                        <button type="button" id="pvHighlightBtn">ê°•ì¡°</button>
                        <button type="button" class="primary" id="pvSaveBtn">ì €ì¥</button>
                        <button type="button" class="btnDanger" id="pvDeleteBtn">ì‚­ì œ</button>
                      </div>

                      <div class="toast" id="pvToast"></div>
                    </div>
                  </div>

                  <!-- ì•„ë˜: ì™„ì„±ëœ íŒ¨ì‹œë¸Œ(ë„“ê²Œ) -->
                  <div class="pvBoardBox">
                    <div class="pvBoardHead">
                      <div class="pvBoardHint">ì•„ë˜ ëª©ë¡ì—ì„œ ì„ íƒí•˜ë©´ ìœ„ì—ì„œ ìˆ˜ì •í•  ìˆ˜ ìˆì–´.</div>
                      <button class="primary" type="button" id="pvAddBtn">íŒ¨ì‹œë¸Œ ì¶”ê°€</button>
                    </div>
                    <div class="pvBoardScroll" id="pvBoard"></div>
                  </div>

                </div>
              </div>
            </div>
          </section>

<section id="panel-skill" class="hidden">
  <div class="skillPage">
    <div class="frame">
      <div class="hdr">ìŠ¤í‚¬ í¸ì§‘ <span class="slash"></span></div>
      <div class="body">

<div class="skillEditorGrid">

  <!-- âœ… ìœ„ 3ì—´ ì˜ì—­ -->
  <div class="skillTopGrid">

    <!-- (1) LEFT: ë¯¸ë¦¬ë³´ê¸° -->
    <div class="box">
      <div class="passLabel">ë¯¸ë¦¬ë³´ê¸°</div>

<div class="skillPreviewCard v2" id="skPreviewCard">

<!-- ìœ„: í”„ë ˆì„ -->
<div class="skTop">
  <div class="skFrame">
    <img id="skFrameImg" alt="frame" />
    <div class="skInner">
      <img id="skInnerImg" alt="inner" />
    </div>
  </div>
</div>

<!-- âœ… ì½”ì¸(ì™¼ìª½ ì •ë ¬) -->
<div class="skCoinRow skCoinRowV2" id="skCoinRow"></div>

<!-- âœ… íƒ€ì´í‹€(ì½”ì¸ ì•„ë˜) -->
<div class="skTitleBar skTitleBarV2" id="skTitleBar">
  <div class="skTitle" id="skTitleTxt">ë§ˆíƒ„ì‚¬ê²©</div>
  <div class="skTitleStripes" aria-hidden="true"></div>
</div>

<!-- âœ… ê³µê²©ë ˆë²¨/ì„±ì¥ê³„ìˆ˜ ë¼ì¸ (íƒ€ì´í‹€ ì•„ë˜) -->
<div class="skGrowthRow skGrowthRowV3" id="skGrowthRow">
  <img class="skGrowthIcon" src="assets/icon_growth.png" alt="ì„±ì¥ê³„ìˆ˜">
  <div class="skGrowthText">
    <span id="skPrevGrowthBase">0</span>
    <span class="skGrowthLabel">ì„±ì¥ê³„ìˆ˜</span>
    <span class="skGrowthPlus">(
      <span id="skPrevGrowthSign">+</span>
      <span id="skPrevGrowthPlus">0</span>
    )</span>
  </div>
</div>

  <!-- ìŠ¤íƒ¯í‘œ: (ì›ë˜ ì˜¤ë¥¸ìª½ì— ìˆë˜ ê²ƒ) ì•„ë˜ë¡œ ì´ë™ -->
  <div class="skStatTable skStat2col v2">
    <div class="skStatTr">
      <div class="skStatTh">ê³µê²© ìœ í˜•</div>
      <div class="skStatTd" id="skPrevAtkCell">
        <img class="skMiniIcon" id="skPrevAtkIcon" alt="">
        <span id="skPrevAtk">ê´€í†µ</span>
      </div>
    </div>

    <div class="skStatTr">
      <div class="skStatTh">ì£„ì•… ì†ì„±</div>
      <div class="skStatTd" id="skPrevSinCell">
        <img class="skMiniIcon" id="skPrevSinIcon" alt="">
        <span id="skPrevSin">ì˜¤ë§Œ</span>
      </div>
    </div>

    <div class="skStatTr">
      <div class="skStatTh">ìŠ¤í‚¬ ìœ„ë ¥</div>
      <div class="skStatTd"><span id="skPrevPow">0</span></div>
    </div>

    <div class="skStatTr">
      <div class="skStatTh">ì½”ì¸ ìœ„ë ¥</div>
      <div class="skStatTd"><span id="skPrevCoin">+0</span></div>
    </div>

    <div class="skStatTr">
      <div class="skStatTh">ê³µê²© ê°€ì¤‘ì¹˜</div>
      <div class="skStatTd"><span id="skPrevW">1</span></div>
    </div>
  </div>

  <!-- íš¨ê³¼ -->
  <div class="skEffectBox" id="skEffectBox"></div>

</div>

      <div style="margin-top:12px;">
        <div class="passLabel">ìŠ¤í‚¬ ì´ë¯¸ì§€(ìœ ì € ì—…ë¡œë“œ)</div>

        <div class="skImgPick">
          <div class="skImgPreview" id="skImgPreview">
            <img id="skImgEl" alt="ìŠ¤í‚¬ ì´ë¯¸ì§€" />
            <div class="ph" id="skImgPh">ì´ë¯¸ì§€</div>
          </div>

          <div class="dkButtons" style="margin:0;">
            <button class="primary file" type="button">
              ì´ë¯¸ì§€ ì—…ë¡œë“œ
              <input id="skImgFile" type="file" accept="image/*" />
            </button>
            <button type="button" id="skImgClear">ì´ë¯¸ì§€ ì œê±°</button>
          </div>
        </div>
      </div>
    </div>

    <!-- (2) MIDDLE: í¸ì§‘ -->
    <div class="box">
      <div class="passLabel">ìŠ¤í‚¬ ì´ë¦„</div>
      <input id="skName" class="textInput" type="text" placeholder="ì˜ˆ: ë§ˆíƒ„ì‚¬ê²©" />

      <div style="margin-top:12px;" class="skillRow2">
        <div>
          <div class="passLabel">ê³µê²© ìœ í˜•</div>
          <select id="skAtkType" class="select">
            <option value="slash">ì°¸ê²©</option>
            <option value="pierce">ê´€í†µ</option>
            <option value="blunt">íƒ€ê²©</option>
          </select>
        </div>

        <div>
          <div class="passLabel">ì£„ì•… ì†ì„±</div>
          <select id="skSin" class="select">
            <option value="wrath">ë¶„ë…¸</option>
            <option value="lust">ìƒ‰ìš•</option>
            <option value="sloth">ë‚˜íƒœ</option>
            <option value="gluttony">íƒì‹</option>
            <option value="melancholy">ìš°ìš¸</option>
            <option value="pride">ì˜¤ë§Œ</option>
            <option value="envy">ì§ˆíˆ¬</option>
          </select>
        </div>
      </div>

      <div style="margin-top:12px;" class="skillRow2">
        <div>
          <div class="passLabel">ìŠ¤í‚¬ ë“±ê¸‰(í”„ë ˆì„ 1~3)</div>
          <select id="skTier" class="select">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
          </select>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="passLabel">ìŠ¤í‚¬ íš¨ê³¼</div>
        <textarea id="skText" placeholder="íš¨ê³¼ë¥¼ ì…ë ¥í•´ì¤˜. í‚¤ì›Œë“œ ë²„íŠ¼ìœ¼ë¡œ [[kw:...]] í† í°ì„ ë„£ì„ ìˆ˜ ìˆì–´."></textarea>
      </div>

      <div style="margin-top:12px;" class="box">
        <div class="passLabel">ë°œë™ ì‹œ ìŒì„±</div>
        <input id="skHitSfx" class="textInput" type="text" placeholder="ì˜ˆ: assets/voice_skill_hit_01.mp3 (ì„ íƒ)" />
        <div class="dkButtons" style="margin-top:8px;">
          <button class="primary file" type="button">íš¨ê³¼ìŒ íŒŒì¼ ì—…ë¡œë“œ<input id="skHitSfxFile" type="file" accept="audio/*" /></button>
          <button type="button" id="skHitSfxClear">íš¨ê³¼ìŒ ì œê±°</button>
        </div>
        <div id="skHitSfxInfo" style="margin-top:6px; color:var(--muted); font-size:12px;">ì—…ë¡œë“œëœ íŒŒì¼ ì—†ìŒ</div>
        <div style="margin-top:6px; color:var(--muted); font-size:12px;">ì´ ìŠ¤í‚¬ì´ í•©ì—ì„œ ìŠ¹ë¦¬í•œ ë’¤ ì‹¤ì œë¡œ ì ì„ ê³µê²©í•  ë•Œ ì¬ìƒë¼. ê²½ë¡œ ì…ë ¥ ë˜ëŠ” íŒŒì¼ ì—…ë¡œë“œ ë‘˜ ë‹¤ ê°€ëŠ¥í•´.</div>
      </div>

      
      <div style="margin-top:12px; display:none;" class="box" id="skEvadeSfxBox">
        <div class="passLabel">íšŒí”¼ ì„±ê³µ/ì‹¤íŒ¨ íš¨ê³¼ìŒ</div>
        <div class="small" style="opacity:.75;margin-top:6px;">íšŒí”¼(atkType=evade) ì„ íƒ ì‹œ, ì½”ì¸ ìŒì„±/ë°œë™ ì‹œ ìŒì„± ëŒ€ì‹  ì•„ë˜ íš¨ê³¼ìŒì„ ì‚¬ìš©í•´.</div>

        <div style="margin-top:10px;">
          <div class="passLabel">íšŒí”¼ ì„±ê³µ íš¨ê³¼ìŒ (ê²½ë¡œ)</div>
          <input id="skEvadeSuccessSfxPath" class="textInput" type="text" placeholder="ì˜ˆ: assets/sfx_evade_success.mp3" />
        </div>

        <div style="margin-top:10px;">
          <div class="passLabel">íšŒí”¼ ì‹¤íŒ¨ íš¨ê³¼ìŒ (ê²½ë¡œ)</div>
          <input id="skEvadeFailSfxPath" class="textInput" type="text" placeholder="ì˜ˆ: assets/sfx_evade_fail.mp3" />
        </div>
      </div>
<div style="margin-top:12px;" class="box">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
          <div class="passLabel">ì½”ì¸ë³„ íš¨ê³¼ìŒ</div>
          <button type="button" id="skCoinVoiceAddBtn">ìŒì„± ì¶”ê°€</button>
        </div>
        <div id="skCoinVoiceList" style="margin-top:8px; display:flex; flex-direction:column; gap:10px;"></div>
        <div id="skCoinVoiceEmpty" style="margin-top:8px; color:var(--muted); font-size:12px;">ì¶”ê°€ëœ ì½”ì¸ ìŒì„±ì´ ì—†ì–´. 'ìŒì„± ì¶”ê°€'ë¥¼ ëˆŒëŸ¬ ì½”ì¸ ë²ˆí˜¸ë¥¼ ê³¨ë¼ ë„£ì–´ì¤˜.</div>
        <div style="display:none;">
          <input id="skCoinSfxPath1" class="textInput" type="text" />
          <input id="skCoinSfxPath2" class="textInput" type="text" />
          <input id="skCoinSfxPath3" class="textInput" type="text" />
          <input id="skCoinSfxPath4" class="textInput" type="text" />
          <input id="skCoinSfxPath5" class="textInput" type="text" />
          <input id="skCoinSfxFile1" type="file" accept="audio/*" />
          <input id="skCoinSfxFile2" type="file" accept="audio/*" />
          <input id="skCoinSfxFile3" type="file" accept="audio/*" />
          <input id="skCoinSfxFile4" type="file" accept="audio/*" />
          <input id="skCoinSfxFile5" type="file" accept="audio/*" />
          <button type="button" id="skCoinSfxClear1"></button>
          <button type="button" id="skCoinSfxClear2"></button>
          <button type="button" id="skCoinSfxClear3"></button>
          <button type="button" id="skCoinSfxClear4"></button>
          <button type="button" id="skCoinSfxClear5"></button>
          <div id="skCoinSfxInfo1"></div>
          <div id="skCoinSfxInfo2"></div>
          <div id="skCoinSfxInfo3"></div>
          <div id="skCoinSfxInfo4"></div>
          <div id="skCoinSfxInfo5"></div>
        </div>
        <div style="margin-top:6px; color:var(--muted); font-size:12px;">'ìŒì„± ì¶”ê°€'ë¥¼ ëˆŒëŸ¬ ì½”ì¸ ë²ˆí˜¸ë¥¼ ì •í•œ ë’¤, ê²½ë¡œë¥¼ ì…ë ¥í•˜ê±°ë‚˜ íŒŒì¼ì„ ì˜¬ë¦´ ìˆ˜ ìˆì–´.</div>
      </div>

      
<div style="margin-top:12px;" class="box autoRuleBox">
        <div class="passLabel">ìë™ ê·œì¹™ (ê°œí¸ UI)</div>
        <div class="small" style="opacity:.78; margin-top:6px; line-height:1.5;">
          íë¦„: <b>ì¡°ê±´(íŠ¸ë¦¬ê±°)</b> â†’ <b>ëŒ€ìƒ(ì°¸ì¡°/ì ìš©)</b> â†’ <b>ì„¸ë¶€ ì¡°ê±´</b> â†’ <b>í–‰ë™</b> â†’ <b>ìµœëŒ€ì¹˜</b><br/>
          <span style="color:var(--muted);">ì°¸ì¡° ëŒ€ìƒ=ì¡°ê±´ ê³„ì‚°ì— ì“°ëŠ” ëŒ€ìƒ / ì ìš© ëŒ€ìƒ=ê²°ê³¼ë¥¼ ì‹¤ì œë¡œ ë°›ëŠ” ëŒ€ìƒ</span>
        </div>

        <div style="margin-top:10px;" class="skillRow2">
          <div>
            <div class="passLabel">íŠ¸ë¦¬ê±°</div>
            <select id="arTrigger" class="select">
              <option value="use">ì‚¬ìš©ì‹œ</option>
              <option value="onHit">ì ì¤‘ì‹œ</option>
              <option value="clashWin">í•© ìŠ¹ë¦¬</option>
              <option value="clashLose">í•© íŒ¨ë°°</option>
              <option value="always">ìƒì‹œ</option>
            </select>
          </div>

          <div>
            <div class="passLabel">ì ìš© ëŒ€ìƒ</div>
            <select id="arApplyTarget" class="select">
              <option value="self">ìì‹ </option>
              <option value="target">ìƒëŒ€</option>
              <option value="none">ì—†ìŒ</option>
            </select>
          </div>

          <div>
            <div class="passLabel">ì°¸ì¡° ëŒ€ìƒ</div>
            <select id="arRefTarget" class="select">
              <option value="self">ìì‹ </option>
              <option value="target">ìƒëŒ€</option>
              <option value="none">ì—†ìŒ</option>
            </select>
          </div>
        </div>

        <div style="margin-top:10px;" class="skillRow2">
          <div>
            <div class="passLabel">ì„¸ë¶€ ì¡°ê±´</div>
            <select id="arCondType" class="select">
              <option value="none">ì—†ìŒ</option>
              <option value="kwCompare">í‚¤ì›Œë“œ N ì´ìƒ/ì´í•˜</option>
              <option value="kwPer">í‚¤ì›Œë“œ Në§ˆë‹¤</option>
              <option value="kwSumCompare">ë‘ í‚¤ì›Œë“œ í•© N ì´ìƒ/ì´í•˜</option>
              <option value="kwConsume">í‚¤ì›Œë“œ N ì†Œëª¨(ê°€ëŠ¥í•  ë•Œë§Œ)</option>
            </select>
          </div>
          <div>
            <div class="passLabel">ì¡°ê±´ ìŠ¤íƒ¯</div>
            <select id="arCondStat" class="select">
              <option value="power">ìœ„ë ¥</option>
              <option value="count">íšŸìˆ˜</option>
              <option value="powerPlusCount">ìœ„ë ¥+íšŸìˆ˜</option>
            </select>
          </div>
        </div>

        <div style="margin-top:10px;" class="skillRow2" id="arCondRowKw1">
          <div>
            <div class="passLabel">í‚¤ì›Œë“œ 1</div>
            <input id="arCondKw1" class="textInput" type="text" placeholder="ì˜ˆ: í˜¸í¡ / í™”ìƒ / ì˜ˆì§€ì•ˆ" />
          </div>
          <div>
            <div class="passLabel">í‚¤ì›Œë“œ 2</div>
            <input id="arCondKw2" class="textInput" type="text" placeholder="ë‘ í‚¤ì›Œë“œ í•© ì¡°ê±´ì—ì„œë§Œ ì‚¬ìš©" />
          </div>
        </div>

        <div style="margin-top:10px;" class="skillRow2" id="arCondRowCmp">
          <div>
            <div class="passLabel">ë¹„êµ</div>
            <select id="arCondOp" class="select">
              <option value=">=">ì´ìƒ (â‰¥)</option>
              <option value="<=">ì´í•˜ (â‰¤)</option>
            </select>
          </div>
          <div>
            <div class="passLabel">N</div>
            <input id="arCondN" class="numInput" type="number" step="1" value="1" />
          </div>
        </div>

        <div style="margin-top:10px;" class="skillRow2" id="arCondRowPer">
          <div>
            <div class="passLabel">Në§ˆë‹¤</div>
            <input id="arCondPerN" class="numInput" type="number" step="1" min="1" value="1" />
          </div>
          <div>
            <div class="passLabel">ì„¤ëª…</div>
            <div style="font-size:12px; color:var(--muted); line-height:1.35; padding-top:6px;">
              ì˜ˆ: <b>í˜¸í¡ ìœ„ë ¥ 6</b>ë‹¹ <b>ê¸°ë³¸ ìœ„ë ¥ +2</b> â†’ ì„¸ë¶€ì¡°ê±´=í‚¤ì›Œë“œ Në§ˆë‹¤, ì¡°ê±´ìŠ¤íƒ¯=ìœ„ë ¥, Në§ˆë‹¤=6, í–‰ë™=ìœ„ë ¥ì¦ê°(ê¸°ë³¸ ìœ„ë ¥ +2)
            </div>
          </div>
        </div>

        <div style="margin-top:10px;" class="skillRow2" id="arCondRowConsume">
          <div>
            <div class="passLabel">ì†Œëª¨ ì¢…ë¥˜</div>
            <select id="arConsumeStat" class="select">
              <option value="power">ìœ„ë ¥ ì†Œëª¨</option>
              <option value="count">íšŸìˆ˜ ì†Œëª¨</option>
            </select>
          </div>
          <div>
            <div class="passLabel">ì†Œëª¨ N</div>
            <input id="arConsumeN" class="numInput" type="number" step="1" min="0" value="0" />
          </div>
        </div>

        <div style="margin-top:12px;" class="box" id="arActionBox">
          <div class="passLabel">í–‰ë™(ê²°ê³¼)</div>

          <div style="margin-top:8px;" class="skillRow2">
            <div>
              <div class="passLabel">í–‰ë™ ì¢…ë¥˜</div>
              <select id="arActType" class="select">
                <option value="powerMod">ìœ„ë ¥ ì¦ê°</option>
                <option value="damageMod">í”¼í•´ëŸ‰ ì¦ê°</option>
                <option value="keywordMod">í‚¤ì›Œë“œ ì¦ê°</option>
                <option value="skillChange">ìŠ¤í‚¬ ë³€ê²½(ë²„íŠ¼ë§Œ)</option>
              </select>
            </div>
            <div>
              <div class="passLabel">ìµœëŒ€ì¹˜(ìº¡, ì„ íƒ)</div>
              <input id="arCap" class="numInput" type="number" step="1" min="0" value="0" />
            </div>
          </div>

          <div style="margin-top:10px;" class="skillRow2" id="arActRowPower">
            <div>
              <div class="passLabel">ìœ„ë ¥ ì¢…ë¥˜</div>
              <select id="arPowerKind" class="select">
                <option value="attackPower">ê³µê²© ìœ„ë ¥</option>
                <option value="clashPower">í•© ìœ„ë ¥</option>
                <option value="basePower">ê¸°ë³¸ ìœ„ë ¥</option>
                <option value="plusCoinPower">ë”í•˜ê¸° ì½”ì¸ ìœ„ë ¥</option>
                <option value="minusCoinPower">ë¹¼ê¸° ì½”ì¸ ìœ„ë ¥</option>
                <option value="defensePower">ìˆ˜ë¹„ ìœ„ë ¥</option>
              </select>
            </div>
            <div>
              <div class="passLabel">ì¦ê°€/ê°ì†Œ</div>
              <div style="display:flex; gap:8px; align-items:center;">
                <select id="arPowerSign" class="select" style="max-width:120px;">
                  <option value="1">ì¦ê°€</option>
                  <option value="-1">ê°ì†Œ</option>
                </select>
                <input id="arPowerAmt" class="numInput" type="number" step="1" min="0" value="1" style="flex:1;" />
              </div>
            </div>
          </div>

          <div style="margin-top:10px;" class="skillRow2" id="arActRowDamage">
            <div>
              <div class="passLabel">í”¼í•´ëŸ‰</div>
              <select id="arDmgKind" class="select">
                <option value="dealUp">í”¼í•´ëŸ‰ ì¦ê°€(ê°€í•˜ëŠ” í”¼í•´)</option>
                <option value="dealDown">í”¼í•´ëŸ‰ ê°ì†Œ(ê°€í•˜ëŠ” í”¼í•´)</option>
              </select>
            </div>
            <div>
              <div class="passLabel">ìŠ¤íƒ ê°’(1=10%)</div>
              <input id="arDmgAmt" class="numInput" type="number" step="1" value="1" />
            </div>
          </div>

          <div style="margin-top:10px;" class="skillRow2" id="arActRowKw">
            <div>
              <div class="passLabel">ë¶€ì—¬/ì¦ê° í‚¤ì›Œë“œ</div>
              <input id="arActKw" class="textInput" type="text" placeholder="ì˜ˆ: í™”ìƒ / í˜¸í¡ / ì˜ˆì§€ì•ˆ" />
            </div>
            <div>
              <div class="passLabel">ìœ„ë ¥ ë³€í™”</div>
              <div style="display:flex; gap:8px; align-items:center;">
                <select id="arActKwPowSign" class="select" style="max-width:120px;">
                  <option value="1">ì¦ê°€</option>
                  <option value="-1">ê°ì†Œ</option>
                </select>
                <input id="arActKwPow" class="numInput" type="number" step="1" min="0" value="0" style="flex:1;" />
              </div>
            </div>
          </div>

          <div style="margin-top:10px;" class="skillRow2" id="arActRowKw2">
            <div>
              <div class="passLabel">íšŸìˆ˜ ë³€í™”</div>
              <div style="display:flex; gap:8px; align-items:center;">
                <select id="arActKwCntSign" class="select" style="max-width:120px;">
                  <option value="1">ì¦ê°€</option>
                  <option value="-1">ê°ì†Œ</option>
                </select>
                <input id="arActKwCnt" class="numInput" type="number" step="1" min="0" value="0" style="flex:1;" />
              </div>
            </div>
            <div>
              <div class="passLabel">ì ì¤‘ ì½”ì¸ ë²ˆí˜¸(ì ì¤‘ì‹œ ì „ìš©)</div>
              <input id="arHitIndex" class="numInput" type="number" step="1" min="1" value="1" />
            </div>
          </div>

          <div style="margin-top:10px; color:var(--muted); font-size:12px; line-height:1.45;" id="arSkillChangeNote">
            ìŠ¤í‚¬ ë³€ê²½ì€ ìœ„í—˜ ê¸°ëŠ¥ì´ë¼ ì•„ì§ ì‹¤í–‰ ë¡œì§ì€ ë§‰ì•„ë’€ì–´. ê·œì¹™ ì €ì¥/í‘œì‹œë§Œ ê°€ëŠ¥.
          </div>
        </div>

        <div style="margin-top:10px;" class="skillRow2">
          <div>
            <div class="passLabel">ê·œì¹™ ë¼ë²¨(í‘œì‹œìš©)</div>
            <input id="arLabel" class="textInput" type="text" placeholder="ì˜ˆ: [ì‚¬ìš©ì‹œ] í˜¸í¡ ìœ„ë ¥ 6ë‹¹ ê¸°ë³¸ìœ„ë ¥ +2 (ìµœëŒ€2)" />
          </div>
          <div>
            <div class="passLabel">ë¯¸ë¦¬ë³´ê¸° í‘œì‹œ</div>
            <select id="arVisible" class="select">
              <option value="1">í‘œì‹œ</option>
              <option value="0">ìˆ¨ê¹€</option>
            </select>
          </div>
        </div>

        <div class="row-actions" style="margin-top:10px;">
          <button type="button" id="arAddBtn">ê·œì¹™ ì¶”ê°€</button>
          <button type="button" id="arPresetPowerBtn">í”„ë¦¬ì…‹: [ì‚¬ìš©ì‹œ] ê³µê²©ìœ„ë ¥ +3</button>
          <button type="button" id="arPresetTransferBtn">í”„ë¦¬ì…‹: [1ì½”ì¸ ì ì¤‘ì‹œ] ëŒ€ìƒì— í™”ìƒ(3/3)</button>
        </div>

        <textarea id="skAutoRulesJson" readonly style="margin-top:10px; width:100%; min-height:140px; background:rgba(0,0,0,.25); color:var(--muted); border:1px solid var(--line); border-radius:14px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;"></textarea>

        <div id="skAutoRuleList" style="margin-top:10px;"></div>
      
        <div class="row-actions" style="margin-top:12px;">
          <button type="button" id="skKeywordBtn">í‚¤ì›Œë“œ</button>
          <button type="button" id="skCoinEffectBtn">ì½”ì¸ íš¨ê³¼</button>
          <button type="button" id="skHighlightBtn">ê°•ì¡°</button>
          <button type="button" id="skGreenBtn">ë…¹ìƒ‰ íš¨ê³¼</button>
          <button type="button" id="skBlueBtn">íŒŒë€ìƒ‰ íš¨ê³¼</button>
          <button type="button" id="skRedBtn">ë¹¨ê°„ìƒ‰ íš¨ê³¼</button>
        </div>
</div>




    </div>

    <!-- (3) RIGHT: ìŠ¤í‚¬ ìˆ˜ì¹˜ -->
    <div class="box">
      <div class="passLabel">ìŠ¤í‚¬ ìˆ˜ì¹˜</div>
      <div style="margin-top:10px;">
        <div class="passLabel">ìŠ¤í‚¬ ìœ í˜•</div>
        <button type="button" id="skSkillTypeBtn" class="stateBtn pos" data-action="attack">ê³µê²© ìŠ¤í‚¬</button>
      </div>

<div style="margin-top:10px;">
  <div class="passLabel" id="skLevelLabel">ê³µê²© ë ˆë²¨</div>
  <input id="skAtkLevel" class="numInput" type="number" step="1" value="0" />
</div>

<div style="margin-top:10px;">
  <div class="passLabel">ì„±ì¥ê³„ìˆ˜</div>
  <input id="skGrowth" class="numInput" type="number" step="1" value="0" />
</div>

      <div style="margin-top:10px;">
  <div class="passLabel">ìŠ¤í‚¬ ìœ„ë ¥</div>
  <input id="skPower" class="numInput" type="number" step="1" value="15" />
</div>

      <div style="margin-top:10px;">
        <div class="passLabel">ì½”ì¸ ìœ„ë ¥</div>
        <div class="coinWrap">
          <button type="button" id="skCoinSignBtn" class="coinSignBtn" data-sign="+">+</button>
          <input id="skCoinPower" class="numInput" type="number" step="1" value="4" />
        </div>
      </div>

      <!-- âœ… ì½”ì¸ ì¢…ë¥˜/ê°œìˆ˜ëŠ” ì—¬ê¸°(ì˜¤ë¥¸ìª½)ì— ë‘”ë‹¤ -->
      <div style="margin-top:10px;">
        <div class="passLabel">ì½”ì¸ ì¢…ë¥˜</div>
        <select id="skCoinType" class="select">
          <option value="normal">ì¼ë°˜ ì½”ì¸</option>
          <option value="fixed">íŒŒê´´ ë¶ˆê°€ ì½”ì¸</option>
          <option value="extract">ì ì¶œ ì½”ì¸</option>
          <option value="annihilate">ì†Œë©¸ ì½”ì¸</option>
        </select>
      </div>

      <div style="margin-top:10px;">
        <div class="passLabel">ì½”ì¸ ê°¯ìˆ˜</div>
        <input id="skCoinCount" class="numInput" type="number" min="1" step="1" value="1" />
      </div>



<div style="margin-top:10px;">
  <div class="passLabel">ê³µê²© ê°€ì¤‘ì¹˜</div>
  <input id="skWeight" class="numInput" type="number" step="1" value="1" />
</div>

<!-- âœ… ìŠ¤í‚¬ ì¢…ë¥˜ í† ê¸€ -->
<div style="margin-top:10px;">
  <div class="passLabel">ìŠ¤í‚¬ ì¢…ë¥˜</div>
  <div class="skKindToggle" id="skKindToggle">
    <button type="button" class="skKindBtn active" data-kind="normal">ì¼ë°˜ ìŠ¤í‚¬</button>
    <button type="button" class="skKindBtn" data-kind="special">íŠ¹ìˆ˜ ìŠ¤í‚¬</button>
  </div>
</div>

<!-- âœ… ì¼ë°˜ ìŠ¤í‚¬ì¼ ë•Œë§Œ í™œì„±í™”ë˜ëŠ” ë“±ì¥ í™•ë¥  -->
<div style="margin-top:10px;" id="skSpawnWrap">
  <div class="passLabel">ìŠ¤í‚¬ ë“±ì¥ í™•ë¥  (%)</div>
  <input id="skillSpawnChance" class="numInput" type="number" min="0" max="100" step="1" value="100" />
  <div style="margin-top:6px; color:var(--muted); font-size:12px;">ì¼ë°˜ ìŠ¤í‚¬ë§Œ ì‚¬ìš©ë¨</div>
</div>

      <div class="row-actions" style="margin-top:12px;">
        <button type="button" class="primary" id="skSaveBtn">ì €ì¥</button>
        <button type="button" id="skNewBtn">ìƒˆ ìŠ¤í‚¬</button>
        <button type="button" class="btnDanger" id="skDeleteBtn">ì‚­ì œ</button>
      </div>

      <div class="toast" id="skToast"></div>
    </div>

  </div><!-- /.skillTopGrid -->

  <!-- âœ… ì•„ë˜: ì €ì¥ëœ ìŠ¤í‚¬ì„ â€œë§¨ ì•„ë˜ ì „ì²´í­â€ìœ¼ë¡œ ë¶„ë¦¬ -->
<div class="box skillSavedBox">
  <div class="passLabel">ì¼ë°˜ ìŠ¤í‚¬ ëª©ë¡</div>
  <div class="skList" id="skListNormal"></div>

  <div style="height:14px;"></div>

  <div class="passLabel">íŠ¹ìˆ˜ ìŠ¤í‚¬ ëª©ë¡</div>
  <div class="skList" id="skListSpecial"></div>
</div>

</div><!-- /.skillEditorGrid -->
</section>

          <!-- ì „ìš© í‚¤ì›Œë“œ -->
            <section id="panel-dk" class="hidden">
            <div class="dkPage">
              <div class="frame">
                <div class="hdr">ì „ìš© í‚¤ì›Œë“œ í¸ì§‘ <span class="slash"></span></div>
                <div class="body">
                  <div class="dkTop">
                    <div class="box">
                      <div class="dkIconPreview">
                        <img id="dkIconImg" alt="ì „ìš© í‚¤ì›Œë“œ ì•„ì´ì½˜" />
                        <div class="ph" id="dkIconPh">ì´ë¯¸ì§€</div>
                      </div>
                      <div class="dkButtons">
                        <button class="primary file" type="button">
                          ì´ë¯¸ì§€ ì—…ë¡œë“œ
                          <input id="dkIconFile" type="file" accept="image/*" />
                        </button>
                        <button type="button" id="dkIconClear">ì´ë¯¸ì§€ ì œê±°</button>
                      </div>
                    </div>

                    <div class="box dkContentArea">
                      <div style="display:flex; flex-direction:column; gap:10px;">
                        <div style="color: rgba(243,211,154,.95); font-weight:900;">í‚¤ì›Œë“œ ì´ë¦„</div>
                        <input id="dkName" class="textInput" type="text" placeholder="í‚¤ì›Œë“œ ì´ë¦„" />

                        <div style="color: rgba(243,211,154,.95); font-weight:900; margin-top:6px;">ë‚´ìš©</div>
                        <textarea id="dkText" placeholder="ë‚´ìš©"></textarea>
                      </div>
                    </div>

                    <div class="box dkActionCol">
                      <button type="button" id="dkStateBtn" class="stateBtn buff">ë²„í”„</button>
                      <button type="button" id="dkSaveBtn" class="primary">ì €ì¥</button>
                      <button type="button" id="dkDeleteBtn" class="btnDanger">í‚¤ì›Œë“œ ì‚­ì œ</button>
                      <div class="toast" id="dkToast"></div>
                    </div>
                  </div>

                  <div class="dkListBox" style="margin-top:14px;">
                    <div style="color:var(--muted); font-size:13px;">
                      ì•„ë˜ ëª©ë¡ì—ì„œ í‚¤ì›Œë“œë¥¼ ì„ íƒí•˜ë©´ ìœ„ì—ì„œ ìˆ˜ì •í•  ìˆ˜ ìˆì–´.
                    </div>
                    <div id="dkList"></div>
                    <div class="dkFooterBar">
                      <button class="primary" type="button" id="dkAddBtn">í‚¤ì›Œë“œ ì¶”ê°€</button>
                    </div>
                  </div>

                </div>
              </div>
            </div>
          </section>

        </main>
      </div>
    </section>
  </div>

  <!-- âœ… í‚¤ì›Œë“œ í”¼ì»¤ ëª¨ë‹¬ (script ë°–!) -->
  <div id="kwModal" class="hidden" style="
    position:fixed; inset:0; background:rgba(0,0,0,.55);
    align-items:center; justify-content:center;
    padding:18px; z-index:9999;">
    <div style="
      width:min(720px, 100%); max-height:80vh; overflow:auto;
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      background:rgba(10,10,12,.96);
      box-shadow:0 18px 60px rgba(0,0,0,.60);
      padding:12px;">
<div style="display:flex; align-items:center; gap:10px; padding:6px 6px 10px;">
  <div style="font-weight:900; color:rgba(243,211,154,.95);" id="kwModalTitle">í‚¤ì›Œë“œ</div>

  <!-- âœ… íƒ­ -->
  <div class="kwTabs" role="tablist" aria-label="í‚¤ì›Œë“œ íƒ­">
    <button type="button" class="kwTab active" data-tab="base" aria-selected="true">ê¸°ë³¸</button>
    <button type="button" class="kwTab" data-tab="rep" aria-selected="false">ëŒ€í‘œ</button>
    <button type="button" class="kwTab" data-tab="ded" aria-selected="false">ì „ìš©</button>
  </div>

  <div style="margin-left:auto;">
    <button type="button" id="kwStateToggle" class="kwStateToggle buff">ë²„í”„</button>
    <button type="button" id="kwCloseBtn">ë‹«ê¸°</button>
  </div>
</div>

<div id="kwModalList" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>
  </div>

  <!-- âœ… í‚¤ì›Œë“œ íˆ´íŒ (ì—¬ê¸°ë¡œ ì´ë™!) -->
  <div id="kwTip" class="kwTip hidden" role="tooltip" aria-hidden="true">
    <div class="kwTipBox">
      <div class="kwTipIcon"><img id="kwTipImg" alt=""></div>
      <div class="kwTipBody">
        <div id="kwTipTitle" class="kwTipTitle"></div>
        <div id="kwTipText" class="kwTipText"></div>
      </div>
    </div>
  </div>

  <script>
// âœ… ìŠ¤í‚¬ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° í‚¤ëŠ” KEY_SK í•˜ë‚˜ë§Œ ì‚¬ìš©
function saveSkillsStore(skillsArr) {
  try {
    localStorage.setItem(KEY_SK, JSON.stringify(skillsArr || []));
  } catch (e) {
    console.error("ìŠ¤í‚¬ ì €ì¥ ì‹¤íŒ¨:", e);
  }
}

function loadSkillsStore() {
  try {
    const raw = localStorage.getItem(KEY_SK);
    if (!raw) return [];
    return normalizeSkills(JSON.parse(raw));
  } catch (e) {
    console.error("ìŠ¤í‚¬ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:", e);
    return [];
  }
}

// ===== [ì¶”ê°€] ì˜›ë‚  ë°ì´í„°/ëˆ„ë½ê°’ ë³´ì • =====
function normalizeSkills(skills) {
  if (!Array.isArray(skills)) return [];

  return skills.map((s, i) => {
    const kind =
      s.kind === "special" || s.type === "special" ? "special" : "normal";

    const rawChance =
      s.spawnChance ?? s.rate ?? 100;

    const spawnChance = Number.isFinite(+rawChance)
      ? Math.max(0, Math.min(100, +rawChance))
      : 100;

    return {
      id: s.id ?? `skill_${i}`,
      name: s.name ?? "ì´ë¦„ ì—†ìŒ",

      // ë‚˜ë¨¸ì§€ ê°’ë“¤ ë¨¼ì € ìœ ì§€
      ...s,

      // ë§ˆì§€ë§‰ì— í†µì¼ í•„ë“œë¡œ ë®ê¸° (í•µì‹¬)
      kind,
      spawnChance
    };
  });
}

/***********************
 * âœ… IndexedDB (ì´ë¯¸ì§€ ì˜êµ¬ ì €ì¥) ìœ í‹¸
 ***********************/
const MEDIA_DB_NAME = "limbus_addon_media_v1";
const MEDIA_DB_VER  = 1;
const MEDIA_STORE   = "images"; // key -> Blob

function openMediaDB(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(MEDIA_DB_NAME, MEDIA_DB_VER);

    req.onupgradeneeded = () => {
      const db = req.result;
      if(!db.objectStoreNames.contains(MEDIA_STORE)){
        db.createObjectStore(MEDIA_STORE); // key: string, value: Blob
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbPutBlob(key, blob){
  const db = await openMediaDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(MEDIA_STORE, "readwrite");
    tx.objectStore(MEDIA_STORE).put(blob, key);
    tx.oncomplete = () => { db.close(); resolve(true); };
    tx.onerror = () => { db.close(); reject(tx.error); };
  });
}

async function idbGetBlob(key){
  const db = await openMediaDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(MEDIA_STORE, "readonly");
    const req = tx.objectStore(MEDIA_STORE).get(key);
    req.onsuccess = () => { db.close(); resolve(req.result || null); };
    req.onerror = () => { db.close(); reject(req.error); };
  });
}

async function idbDel(key){
  const db = await openMediaDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(MEDIA_STORE, "readwrite");
    tx.objectStore(MEDIA_STORE).delete(key);
    tx.oncomplete = () => { db.close(); resolve(true); };
    tx.onerror = () => { db.close(); reject(tx.error); };
  });
}

function dataURLToBlob(dataURL){
  const [head, body] = String(dataURL).split(",", 2);
  const mime = (head.match(/data:(.*?);base64/)||[])[1] || "application/octet-stream";
  const bin = atob(body || "");
  const len = bin.length;
  const arr = new Uint8Array(len);
  for(let i=0;i<len;i++) arr[i] = bin.charCodeAt(i);
  return new Blob([arr], { type: mime });
}

function blobToDataURL(blob){
  return new Promise((resolve, reject) => {
    const r = new FileReader();
    r.onload = () => resolve(String(r.result || ""));
    r.onerror = reject;
    r.readAsDataURL(blob);
  });
}

async function exportCharacterToFile(charId){
  const data = loadCharData(charId);
  if(!data){
    alert("ìºë¦­í„° ë°ì´í„°ê°€ ì—†ì–´.");
    return;
  }

  // 1) ì–´ë–¤ ì´ë¯¸ì§€ í‚¤ë¥¼ í¬í•¨í• ì§€ ìˆ˜ì§‘
  const mediaKeys = new Set();

  // core portrait
  const corePortraitKey = data?.core?.portraitKey || "";
  if(corePortraitKey) mediaKeys.add(corePortraitKey);

  // dedicated keyword icons
  const dks = Array.isArray(data?.dedicatedKeywords) ? data.dedicatedKeywords : [];
  for(const k of dks){
    if(k?.iconKey) mediaKeys.add(k.iconKey);
  }

  // skill images
  const skills = Array.isArray(data?.skills) ? data.skills : [];
  for(const s of skills){
    if(s?.imgKey) mediaKeys.add(s.imgKey);
  }

  // 2) IndexedDBì—ì„œ Blob ì½ì–´ì„œ dataURLë¡œ íŒ¨í‚¹
  const media = {}; // key -> dataURL
  for(const key of mediaKeys){
    try{
      const blob = await idbGetBlob(key);
      if(blob){
        media[key] = await blobToDataURL(blob);
      }
    }catch(e){
      console.warn("media export fail:", key, e);
    }
  }

  // 3) ìµœì¢… ë‚´ë³´ë‚´ê¸° payload
  const payload = {
    kind: "limbus_char_export",
    version: 1,
    exportedAt: nowISO(),
    char: data,     // core/passives/skills/dedicatedKeywords ê·¸ëŒ€ë¡œ
    media: media    // ì´ë¯¸ì§€ë“¤(Blob -> dataURL)
  };

  const json = JSON.stringify(payload);
  const blob = new Blob([json], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;

  const safeName = String(data?.name || "character").trim().replace(/[\\/:*?"<>|]/g, "_");
  a.download = `${safeName}.limbuschar.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();

  setTimeout(() => URL.revokeObjectURL(url), 500);
}

async function importCharacterFromFile(file){
  const text = await file.text();
  let pack = null;

  try{
    pack = JSON.parse(text);
  }catch(e){
    alert("íŒŒì¼ì´ JSONì´ ì•„ë‹ˆì•¼.");
    return;
  }

  if(!pack || pack.kind !== "limbus_char_export"){
    alert("ì´ íŒŒì¼ì€ ë‚´ë³´ë‚¸ ìºë¦­í„° íŒŒì¼ì´ ì•„ë‹Œ ê²ƒ ê°™ì•„.");
    return;
  }

  const data = pack.char;
  const media = pack.media || {};

  if(!data || !data.core){
    alert("ìºë¦­í„° ë°ì´í„°ê°€ ë¹„ì •ìƒ(ê¹¨ì§).");
    return;
  }

  // âœ… ìƒˆ ìºë¦­í„°ë¡œ ì €ì¥í•  ê±°ë¼ë©´ id ìƒˆë¡œ ë°œê¸‰
  // (ê¸°ì¡´ id ê·¸ëŒ€ë¡œ ë®ì–´ì“°ë©´ ì¶©ëŒ ê°€ëŠ¥)
  const newId = charUid();

  // 1) media ë³µì›: dataURL -> Blob -> IndexedDBì— key ê·¸ëŒ€ë¡œ ì €ì¥
  // (key ì´ë¦„ì´ core_portrait_v1 ê°™ì€ ê³ ì •í‚¤ë©´ ë‹¤ë¥¸ ìºë¦­í„°ì™€ ì¶©ëŒë‚  ìˆ˜ ìˆìŒ)
  // ê·¸ë˜ì„œ "í‚¤ ì¬ë§¤í•‘"ì´ ì•ˆì „í•¨. ì•„ë˜ëŠ” ì¬ë§¤í•‘ ë°©ì‹.

  const remap = {}; // oldKey -> newKey

  function remapKey(oldKey){
    if(!oldKey) return "";
    if(remap[oldKey]) return remap[oldKey];

    // ìºë¦­í„°ë³„ë¡œ ë¶„ë¦¬ë˜ê²Œ í‚¤ë¥¼ ìƒˆë¡œ ë§Œë“¦
    // ì˜ˆ: core_portrait_v1 -> core_portrait_<newId>
    const nk = `${oldKey}__${newId}`;
    remap[oldKey] = nk;
    return nk;
  }

  // core portraitKey remap
  if(data.core.portraitKey){
    data.core.portraitKey = remapKey(data.core.portraitKey);
  }

  // dk iconKey remap
  if(Array.isArray(data.dedicatedKeywords)){
    for(const k of data.dedicatedKeywords){
      if(k.iconKey) k.iconKey = remapKey(k.iconKey);
    }
  }

  // skill imgKey remap
  if(Array.isArray(data.skills)){
    for(const s of data.skills){
      if(s.imgKey) s.imgKey = remapKey(s.imgKey);
    }
  }

  // media ì €ì¥(ì¬ë§¤í•‘ëœ í‚¤ë¡œ)
  for(const [oldKey, dataURL] of Object.entries(media)){
    const newKey = remapKey(oldKey);
    try{
      const blob = dataURLToBlob(dataURL);
      await idbPutBlob(newKey, blob);
    }catch(e){
      console.warn("media import fail:", oldKey, e);
    }
  }

  // 2) char data ì €ì¥
  const name = (data?.name || data?.core?.name || "ê°€ì ¸ì˜¨ ìºë¦­í„°").trim();

  // char ì €ì¥ í¬ë§·(ë„¤ snapshotCurrentWorkspace êµ¬ì¡°ë‘ ë§ì¶¤)
  const saved = {
    version: 1,
    savedAt: nowISO(),
    name,
    core: data.core || null,
    passives: data.passives || [],
    skills: data.skills || [],
    dedicatedKeywords: data.dedicatedKeywords || [],
  };

  // charList ê°±ì‹ 
  const list = loadCharList();
  list.unshift({
    id: newId,
    name,
    createdAt: nowISO(),
    updatedAt: nowISO(),
  });
  saveCharList(list);
  saveCharData(newId, saved);

  alert(`ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ: ${name}`);
  renderCharacterLibrary();
}

function makeObjectURLFromBlob(blob){
  return URL.createObjectURL(blob);
}

/***********************
 * âœ… ObjectURL ëˆ„ìˆ˜ ë°©ì§€(ë¦¬í”„ë ˆì‹œ/ì¬ë Œë” ì‹œ URL í•´ì œ)
 ***********************/
let _portraitObjectURL = "";
function setPortraitFromObjectURL(url){
  if(_portraitObjectURL){
    try{ URL.revokeObjectURL(_portraitObjectURL); }catch(e){}
    _portraitObjectURL = "";
  }
  if(!url){
    setPortrait("");
    return;
  }
  _portraitObjectURL = url;
  setPortrait(url);
}

// dk / modal ì•„ì´ì½˜ url í•´ì œìš©
const _iconObjectURLMap = new Map(); // key -> objectURL
function revokeIconURL(key){
  const u = _iconObjectURLMap.get(key);
  if(u){
    try{ URL.revokeObjectURL(u); }catch(e){}
    _iconObjectURLMap.delete(key);
  }
}

async function applyIconKeyToImg(imgEl, iconKey){
  const prevKey = imgEl?.dataset?.iconKey || "";
  if(prevKey && prevKey !== iconKey){
    revokeIconURL(prevKey);
  }
  if(imgEl?.dataset) imgEl.dataset.iconKey = iconKey || "";

  if(!iconKey){
    imgEl.src = "";
    imgEl.style.display = "none";
    return;
  }
  const blob = await idbGetBlob(iconKey);
  if(!blob){
    imgEl.src = "";
    imgEl.style.display = "none";
    return;
  }
  if(!_iconObjectURLMap.has(iconKey)){
    _iconObjectURLMap.set(iconKey, makeObjectURLFromBlob(blob));
  }
  imgEl.src = _iconObjectURLMap.get(iconKey);
  imgEl.style.display = "block";
}

/***********************
 * âœ… Character Save/Load (v1)
 ***********************/
const KEY_CHAR_LIST = "limbus_char_list_v1";       // [{id,name,updatedAt,createdAt}]
const KEY_CHAR_DATA_PREFIX = "limbus_char_";       // limbus_char_<id>_v1
const KEY_CHAR_DATA_SUFFIX = "_v1";

function nowISO(){ return new Date().toISOString(); }
function charUid(){ return "c_" + Math.random().toString(16).slice(2) + Date.now().toString(16); }

let APP_MODE = "edit"; // "edit" | "view"
function setAppMode(mode){
  APP_MODE = (mode === "view") ? "view" : "edit";
  document.body.classList.toggle("readonly", APP_MODE === "view");

  // âœ… íƒ­ ë¼ë²¨ì€ ë³´ê¸° ëª¨ë“œì—ì„œë§Œ ë³€ê²½
  applyViewTabLabels();

  if(APP_MODE === "view"){
    applyViewCoreUI();
  }else{
    // âœ… í¸ì§‘ ëª¨ë“œë¡œ ëŒì•„ì˜¬ ë•Œ view ì „ìš© ì”ìƒ ì œê±°
    cleanupViewArtifacts();
  }
}

function applyViewTabLabels(){
  const coreBtn  = document.getElementById("tab-core");
  const pvBtn    = document.getElementById("tab-passive");
  const skBtn    = document.getElementById("tab-skill");   // âœ… ì¶”ê°€
  const dkBtn    = document.getElementById("tab-dk");      // (ë‚˜ì¤‘ìš©)

  // ì—†ìœ¼ë©´ ì¢…ë£Œ
  if(!coreBtn || !pvBtn || !skBtn) return;

  // ì›ë˜ í…ìŠ¤íŠ¸ ë°±ì—…(1íšŒ)
  if(!coreBtn.dataset.origText) coreBtn.dataset.origText = coreBtn.textContent;
  if(!pvBtn.dataset.origText)   pvBtn.dataset.origText   = pvBtn.textContent;
  if(!skBtn.dataset.origText)   skBtn.dataset.origText   = skBtn.textContent; // âœ… ì¶”ê°€
  if(dkBtn && !dkBtn.dataset.origText) dkBtn.dataset.origText = dkBtn.textContent;

  if(APP_MODE === "view"){
    coreBtn.textContent = coreBtn.dataset.origText; // í•µì‹¬ ì •ë³´ ê·¸ëŒ€ë¡œ
    pvBtn.textContent   = "íŒ¨ì‹œë¸Œ";
    skBtn.textContent   = "ìŠ¤í‚¬";                   // âœ… ì—¬ê¸°!
    dkBtn.textContent = "ì „ìš© í‚¤ì›Œë“œ";           // ë‚˜ì¤‘ì— ì¼œë©´ ë¨
  }else{
    coreBtn.textContent = coreBtn.dataset.origText;
    pvBtn.textContent   = pvBtn.dataset.origText;
    skBtn.textContent   = skBtn.dataset.origText;   // âœ… ë³µêµ¬
    if(dkBtn) dkBtn.textContent = dkBtn.dataset.origText;
  }
}

function cleanupViewArtifacts(){
  // âœ… ë³´ê¸° ëª¨ë“œì—ì„œ ë§Œë“¤ì–´ë‘” traitLine(ì¹© ìš”ì•½)ì´ í¸ì§‘ ëª¨ë“œì— ë‚¨ì•„ ë³´ì´ëŠ” ë¬¸ì œ ë°©ì§€
  const traitSection = [...document.querySelectorAll("#panel-core .frame")].find(f => {
    const h = f.querySelector(".hdr");
    return h && h.textContent.includes("íŠ¹ì„± í‚¤ì›Œë“œ");
  });
  const body = traitSection?.querySelector(".body");
  const old = body?.querySelector(".traitLine");
  if(old) old.remove();
}

function applyViewCoreUI(){
  if(APP_MODE !== "view") return;

  // 1) ì´ë¦„: ì…ë ¥ì¹¸ì„ "íƒ€ì´í‹€"ì²˜ëŸ¼ ë³´ì´ê²Œ
  const nameInput = document.getElementById("charName");
  if(nameInput){
    nameInput.style.fontSize = "26px";
    nameInput.style.fontWeight = "1000";
    nameInput.style.letterSpacing = "-0.02em";
    nameInput.style.color = "rgba(243,211,154,.98)";
    nameInput.style.textShadow = "0 2px 18px rgba(0,0,0,.55)";
    nameInput.style.textAlign = "left";
  }

  // 2) íŠ¹ì„± í‚¤ì›Œë“œ: 1ì¤„ ìš”ì•½ ìƒì„±
  const traitFrameBody = document.querySelector("#panel-core .frame .hdr:nth-child(1)"); // ì•ˆì „í•˜ì§€ ì•Šì•„ì„œ ì•„ë˜ ë°©ì‹ ì‚¬ìš©
  const traitSection = [...document.querySelectorAll("#panel-core .frame")].find(f => {
    const h = f.querySelector(".hdr");
    return h && h.textContent.includes("íŠ¹ì„± í‚¤ì›Œë“œ");
  });

  if(traitSection){
    const body = traitSection.querySelector(".body");
    if(body){
      // ê¸°ì¡´ ìš”ì•½ë°” ìˆìœ¼ë©´ ì œê±° í›„ ì¬ìƒì„±
      const old = body.querySelector(".traitLine");
      if(old) old.remove();

// âœ… í˜„ì¬ UIì— ë¡œë“œëœ í‚¤ì›Œë“œ ì½ê¸°(ì‚­ì œí‘œì‹œ í¬í•¨)
const rows = [...document.querySelectorAll("#traitKwList .kwRow")];

const items = rows
  .map(r => ({
    text: (r.querySelector(".kwInput")?.value || "").trim(),
    deleted: r.classList.contains("deleted")
  }))
  .filter(x => x.text);

const line = document.createElement("div");
line.className = "traitLine";

if(items.length === 0){
  line.textContent = "íŠ¹ì„± í‚¤ì›Œë“œ ì—†ìŒ";
} else {
  const wrap = document.createElement("div");
  wrap.className = "traitChips";

  for(const it of items){
    const chip = document.createElement("span");
    chip.className = "traitChip" + (it.deleted ? " deleted" : "");
    chip.textContent = it.text;
    wrap.appendChild(chip);
  }

  line.appendChild(wrap);
}

body.appendChild(line);
    }
  }
}

function loadCharList(){
  try{
    const raw = JSON.parse(localStorage.getItem(KEY_CHAR_LIST) || "[]");
    return Array.isArray(raw) ? raw : [];
  }catch(e){ return []; }
}
function saveCharList(list){
  localStorage.setItem(KEY_CHAR_LIST, JSON.stringify(list || []));
}
function charDataKey(id){
  return `${KEY_CHAR_DATA_PREFIX}${id}${KEY_CHAR_DATA_SUFFIX}`;
}
function loadCharData(id){
  try{
    return JSON.parse(localStorage.getItem(charDataKey(id)) || "null");
  }catch(e){ return null; }
}
function saveCharData(id, data){
  localStorage.setItem(charDataKey(id), JSON.stringify(data));
}

// âœ… workspace keys (ì—¬ê¸° í•œ ë²ˆë§Œ!)
const KEY_CORE = "limbus_addon_core_v10";
const KEY_PV   = "limbus_addon_passives_v1";
const KEY_SK   = "limbus_addon_skills_v1";
const KEY_DK   = "limbus_addon_dedicated_keywords_v3";

// âœ… ë¶€íŒ… ì‹œ 1íšŒ: ì„ íƒí•œ ìºë¦­í„°ë¥¼ ë¨¼ì € ì‘ì—…ê³µê°„ì— ì£¼ì…
(function bootOnceLoadCharacter(){
  const loadId = localStorage.getItem("limbus_load_char_once");
  if(!loadId) return;

  const mode = localStorage.getItem("limbus_app_mode_once") || "edit";
  localStorage.removeItem("limbus_load_char_once");
  localStorage.removeItem("limbus_app_mode_once");

  const data = loadCharData(loadId);
  if(!data) return;

  localStorage.setItem(KEY_CORE, JSON.stringify(data.core || null));
  localStorage.setItem(KEY_PV,   JSON.stringify(data.passives || []));
  localStorage.setItem(KEY_SK,   JSON.stringify(data.skills || []));
  localStorage.setItem(KEY_DK,   JSON.stringify(data.dedicatedKeywords || []));

  // ëª¨ë“œëŠ” â€œë°”ë¡œ ì ìš©â€ ë§ê³ , ì•„ë˜ì—ì„œ í•œ ë²ˆë§Œ ì½ì–´ì„œ ì ìš©í•  ìš©ë„
  localStorage.setItem("limbus_app_mode_boot", mode);
})();

// âœ… ë¶€íŒ… ëª¨ë“œ 1íšŒ ì ìš©(ë°˜ë“œì‹œ setAppMode ë°–!)
(() => {
  const bootMode = localStorage.getItem("limbus_app_mode_boot");
  if(bootMode){
    localStorage.removeItem("limbus_app_mode_boot");
    setAppMode(bootMode);
  }
})();

const viewLibrary = document.getElementById("view-library");
const libToast = document.getElementById("libToast");
const charListEl = document.getElementById("charList");

const btnImportCharacter = document.getElementById("btn-import-character");
const importFileInput = document.getElementById("importFile");

btnImportCharacter?.addEventListener("click", () => {
  importFileInput?.click();
});

importFileInput?.addEventListener("change", async (e) => {
  const file = e.target.files && e.target.files[0];
  if(!file) return;

  try{
    await importCharacterFromFile(file);
    toast(libToast, "íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!");
  }catch(err){
    console.error(err);
    toast(libToast, "íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨!");
  }finally{
    // ê°™ì€ íŒŒì¼ ë‹¤ì‹œ ì„ íƒ ê°€ëŠ¥í•˜ê²Œ ì´ˆê¸°í™”
    importFileInput.value = "";
  }
});

function normalizeSkill(skill){
  return {
    ...skill,
    kind: skill.kind === "special" ? "special" : "normal",
    spawnChance: Number.isFinite(+skill.spawnChance)
      ? Math.max(0, Math.min(100, +skill.spawnChance))
      : 100,
  };
}

function renderCharacterLibrary(){
  if(!charListEl) return;
  charListEl.innerHTML = "";

  const list = loadCharList();
  if(list.length === 0){
    const d = document.createElement("div");
    d.style.color = "rgba(238,241,255,.55)";
    d.style.fontSize = "13px";
    d.textContent = "ì•„ì§ ì €ì¥ëœ ìºë¦­í„°ê°€ ì—†ì–´. 'í˜„ì¬ ì‘ì—…ì„ ìºë¦­í„°ë¡œ ì €ì¥'ì„ ëˆŒëŸ¬ë´.";
    charListEl.appendChild(d);
    return;
  }

  for(const it of list){
    const row = document.createElement("div");
    row.style.cssText = "border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18);border-radius:16px;padding:12px;display:flex;align-items:center;gap:10px;cursor:pointer;";
    // âœ… row ì „ì²´ í´ë¦­ ì‹œ ê¸°ë³¸ ë™ì‘ = ë³´ê¸°
    row.dataset.action = "view";
    row.dataset.id = it.id;
    row.dataset.name = it.name || "";

    const title = document.createElement("div");
    title.style.fontWeight = "900";
    title.textContent = it.name || "(ì´ë¦„ ì—†ìŒ)";

    const meta = document.createElement("div");
    meta.style.cssText = "margin-left:auto;display:flex;gap:8px;";

    const mkBtn = (txt, action, cls="") => {
      const b = document.createElement("button");
      b.type = "button";
      b.textContent = txt;
      if(cls) b.className = cls;
      b.dataset.action = action;
      b.dataset.id = it.id;
      b.dataset.name = it.name || "";
      return b;
    };

    meta.appendChild(mkBtn("ë³´ê¸°", "view"));
    meta.appendChild(mkBtn("í¸ì§‘", "edit", "primary"));
    meta.appendChild(mkBtn("ë‚´ë³´ë‚´ê¸°", "export"));
    meta.appendChild(mkBtn("ì‚­ì œ", "delete", "btnDanger"));

    row.appendChild(title);
    row.appendChild(meta);
    charListEl.appendChild(row);
  }
}

charListEl.addEventListener("click", async (e) => {
  // 1) ë²„íŠ¼ì´ë©´ ë²„íŠ¼ action, ì•„ë‹ˆë©´ row action(view)
  const btn = e.target.closest("button[data-action]");
  const row = e.target.closest("div[data-action][data-id]");

  const act = (btn?.dataset.action || row?.dataset.action || "");
  const id  = (btn?.dataset.id || row?.dataset.id || "");
  const nm  = (btn?.dataset.name || row?.dataset.name || "");

  if(!act || !id) return;

  e.preventDefault();
  e.stopPropagation();

  if(act === "view" || act === "edit"){
    localStorage.setItem("limbus_app_mode_once", act === "view" ? "view" : "edit");
    localStorage.setItem("limbus_load_char_once", id);
    localStorage.setItem("limbus_load_char_name_once", nm); // âœ… ì•ˆì „ì¥ì¹˜
    location.reload();
    return;
  }

  if(act === "export"){
    try{ await exportCharacterToFile(id); }
    catch(err){ console.error(err); alert("ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨(ì´ë¯¸ì§€/ì €ì¥ê³µê°„ ë¬¸ì œì¼ ìˆ˜ ìˆì–´)."); }
    return;
  }

  if(act === "delete"){
    if(!confirm(`"${nm || "(ì´ë¦„ ì—†ìŒ)"}" ìºë¦­í„°ë¥¼ ì‚­ì œí• ê¹Œ? (ì´ë¯¸ì§€ëŠ” DBì— ë‚¨ì„ ìˆ˜ ìˆì–´)`)) return;
    const list2 = loadCharList().filter(x => x.id !== id);
    saveCharList(list2);
    localStorage.removeItem(charDataKey(id));
    toast(libToast, "ì‚­ì œ ì™„ë£Œ!");
    renderCharacterLibrary();
  }
});

document.getElementById("btn-go-library").addEventListener("click", () => {
  hide(viewHome); hide(viewEditor);
  show(viewLibrary);
  setAppMode("edit"); // ë¼ì´ë¸ŒëŸ¬ë¦¬ ìì²´ëŠ” ì¡°ì‘ ê°€ëŠ¥
  renderCharacterLibrary();
});

document.getElementById("btn-lib-back").addEventListener("click", () => {
  setAppMode("edit");               // âœ… ì¶”ê°€
  hide(viewLibrary);
  show(viewHome);
});

document.getElementById("btn-save-as-character").addEventListener("click", () => {
  const snap = snapshotCurrentWorkspace();
  const id = charUid();

  // ëª©ë¡ ì €ì¥
  const list = loadCharList();
  list.unshift({
    id,
    name: snap.name,
    createdAt: nowISO(),
    updatedAt: nowISO(),
  });
  saveCharList(list);

  // ë³¸ë¬¸ ì €ì¥
  saveCharData(id, snap);

  toast(libToast, `ìºë¦­í„° ì €ì¥ ì™„ë£Œ: ${snap.name}`);
  renderCharacterLibrary();
});

    // ===== view switch =====
    const viewHome = document.getElementById("view-home");
    const viewEditor = document.getElementById("view-editor");
    
    const homeToast = document.getElementById("home-toast");

    function show(el){ el.classList.remove("hidden"); }
    function hide(el){ el.classList.add("hidden"); }
    function toast(el, msg){
      if(!el) return;
      el.textContent = msg;
      el.style.display = "block";
    }
    function clearToast(el){
      if(!el) return;
      el.textContent = "";
      el.style.display = "none";
    }

// ===== PLAY/MATCH views =====
const viewPlayMode = document.getElementById("view-play-mode");
const viewPlay  = document.getElementById("view-play");
const viewMatch = document.getElementById("view-match");

const playMyChar = document.getElementById("playMyChar");
const playEnemyChar = document.getElementById("playEnemyChar");
const btnAiWaveInfo = document.getElementById("btnAiWaveInfo");
const btnAiWaveInfoClose = document.getElementById("btnAiWaveInfoClose");
const aiWaveInfoPanel = document.getElementById("aiWaveInfoPanel");
const aiWaveInfoList = document.getElementById("aiWaveInfoList");
const playToast = document.getElementById("playToast");
const playMyCharMeta = document.getElementById("playMyCharMeta");
const playEnemyCharMeta = document.getElementById("playEnemyCharMeta");
const playBattleBg = document.getElementById("playBattleBg");
const playBattleBgMeta = document.getElementById("playBattleBgMeta");
const playBattleBgm = document.getElementById("playBattleBgm");
const playBattleBgmMeta = document.getElementById("playBattleBgmMeta");
const playBgFrame = document.getElementById("playBgFrame");
const playBgmFrame = document.getElementById("playBgmFrame");
let _charBattleBgm = null;
let _charBattleBgmKey = "";

const matchTitle = document.getElementById("matchTitle");
const matchLog = document.getElementById("matchLog");
const matchToast = document.getElementById("matchToast");

/* ===== MATCH STATE ===== */
let MATCH_STATE = null;

/* ===== MATCH UI elements ===== */
const EL_MATCH = {
  myName: document.getElementById("myNameView"),
  enemyName: document.getElementById("enemyNameView"),
  mySpd: document.getElementById("mySpd"),
  enemySpd: document.getElementById("enemySpd"),

  myPortraitImg: document.getElementById("myPortraitMiniImg"),
  enemyPortraitImg: document.getElementById("enemyPortraitMiniImg"),

  myStats: document.getElementById("myStatsMini"),
  enemyStats: document.getElementById("enemyStatsMini"),

  myStagger: document.getElementById("myStaggerMini"),
  enemyStagger: document.getElementById("enemyStaggerMini"),

  myPhys: document.getElementById("myPhysMini"),
  enemyPhys: document.getElementById("enemyPhysMini"),
  mySin: document.getElementById("mySinMini"),
  enemySin: document.getElementById("enemySinMini"),

  myKeywords: document.getElementById("myKeywordsMini"),
  enemyKeywords: document.getElementById("enemyKeywordsMini"),

  myStatus: document.getElementById("myStatusChips"),
  enemyStatus: document.getElementById("enemyStatusChips"),

  myPassivePrev: document.getElementById("myPassivePreview"),
  enemyPassivePrev: document.getElementById("enemyPassivePreview"),

  mySlots: document.getElementById("mySlots"),
  enemySlots: document.getElementById("enemySlots"),

  mySpecialSkills: document.getElementById("mySpecialSkills"),
  enemyPickedSkills: document.getElementById("enemyPickedSkills"),
  myPickedSkills: document.getElementById("myPickedSkills"),

  turnNo: document.getElementById("matchTurnNo"),
  mySlotInfo: document.getElementById("mySlotInfo"),
  enemySlotInfo: document.getElementById("enemySlotInfo"),

  btnRoll: document.getElementById("btn-match-roll"),
  btnMyPassive: document.getElementById("btnMyPassive"),
  btnEnemyPassive: document.getElementById("btnEnemyPassive"),
};

const EL_CINE = {
  wrap: document.getElementById("matchCinematic"),
  sub: document.getElementById("matchCineSub"),
  tag: document.getElementById("matchCineTag"),
  myName: document.getElementById("cineMyName"),
  mySkill: document.getElementById("cineMySkill"),
  myMeta: document.getElementById("cineMyMeta"),
  myCoins: document.getElementById("cineMyCoins"),
  enemyName: document.getElementById("cineEnemyName"),
  enemySkill: document.getElementById("cineEnemySkill"),
  enemyMeta: document.getElementById("cineEnemyMeta"),
  enemyCoins: document.getElementById("cineEnemyCoins"),
  round: document.getElementById("cineRound"),
  score: document.getElementById("cineScore"),
  result: document.getElementById("cineResult"),
  attack: document.getElementById("cineAttack"),
};
let MATCH_BATTLE_BUSY = false;

/* ===== safe helpers ===== */
function escHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}
const LOG_ICONS = {
  burn: "assets/icon_rep_burn.png",
  bleed: "assets/icon_rep_bleed.png",
  sinking: "assets/icon_rep_sinking.png",
  rupture: "assets/icon_rep_rupture.png",
  tremorBurst: "assets/icon_rep_tremor_boom.png",
  crit: "assets/icon_rep_breath.png",
};
function appendMatchLogIcon(iconKey, line, opts={}){
  const icon = LOG_ICONS[iconKey];
  if(icon){
    const html = `<img class="logIcon" src="${escHtml(icon)}" alt="">${escHtml(line)}`;
    appendMatchLog(html, {...opts, html:true});
  }else{
    appendMatchLog(line, opts);
  }
}
function appendMatchLog(line, opts={}){
  if(!matchLog) return;
  const row = document.createElement("div");
  row.className = `matchLogLine ${opts.cls||""}`.trim();
  if(opts.html) row.innerHTML = String(line || "");
  else row.textContent = String(line ?? "");
  matchLog.appendChild(row);
  matchLog.scrollTop = matchLog.scrollHeight;
}

function appendMatchLogColored(line, cls){
  appendMatchLog(line, {cls});
}

function clamp(n,min,max){ return Math.max(min, Math.min(max, Number(n)||0)); }

function getUnitSanity(unit){
  if(!unit) return 0;
  if(unit.panicLock){ return -45; }
  return clamp(unit.sanity ?? unit?.core?.status?.sanity ?? unit?.core?.sanity ?? 0, -45, 45);
}

function setUnitSanity(unit, value){
  if(!unit) return 0;
  if(unit.panicLock){
    unit.sanity = -45;
    unit.core = unit.core || {};
    unit.core.status = unit.core.status || {};
    unit.core.status.sanity = -45;
    unit.core.sanity = -45;
    return -45;
  }
  const next = clamp(value, -45, 45);
  unit.sanity = next;
  unit.core = unit.core || {};
  unit.core.status = unit.core.status || {};
  unit.core.status.sanity = next;
  unit.core.sanity = next;
  if(next <= -45){
    unit.panicLock = true;
    unit.panicTurnsLeft = 2;
    unit.sanity = -45;
    unit.core.status.sanity = -45;
    unit.core.sanity = -45;
    appendMatchLog(`${getUnitLabel(unit.side)} íŒ¨ë‹‰! ì´ë²ˆ í„´ê³¼ ë‹¤ìŒ í„´ ë™ì•ˆ ì •ì‹ ë ¥ -45 ê³ ì •`);
  }
  return next;
}

function addUnitSanity(unit, delta){
  if(!unit) return 0;
  return setUnitSanity(unit, getUnitSanity(unit) + (Number(delta)||0));
}

function getCoinHeadChance(unit){
  const s = getUnitSanity(unit);
  return clamp(0.5 + (s / 100), 0.05, 0.95);
}

function getSanityColor(value){
  const s = clamp(value, -45, 45);
  if(s === 0) return 'rgba(255,255,255,.92)';
  if(s > 0){
    const t = s / 45;
    return `rgb(${Math.round(255 - 95*t)}, ${Math.round(255 - 35*t)}, 255)`;
  }
  const t = Math.abs(s) / 45;
  return `rgb(255, ${Math.round(255 - 155*t)}, ${Math.round(255 - 155*t)})`;
}

function sanityDisplayText(unit){
  const s = getUnitSanity(unit);
  return unit?.panicLock ? `${s} (íŒ¨ë‹‰)` : String(s);
}

function processPanicTurnStart(unit){
  if(!unit?.panicLock) return;
  unit.panicTurnsLeft = Math.max(0, Number(unit.panicTurnsLeft || 0) - 1);
  unit.sanity = -45;
  unit.core.status.sanity = -45;
  unit.core.sanity = -45;
  if(unit.panicTurnsLeft <= 0){
    unit.panicLock = false;
    unit.sanity = 0;
    unit.core.status.sanity = 0;
    unit.core.sanity = 0;
    appendMatchLog(`${getUnitLabel(unit.side)} íŒ¨ë‹‰ ì¢…ë£Œ / ì •ì‹ ë ¥ 0ìœ¼ë¡œ ì´ˆê¸°í™”`);
  }
}

const MATCH_SFX = {
  battleStart: "assets/sfx_battle_start.mp3",
  coinHead: "assets/sfx_coin_head.mp3",
  coinTail: "assets/sfx_coin_tail.mp3",
  clashBreak: "assets/sfx_clash_break.mp3",
  clashDraw: "assets/sfx_clash_draw.mp3",
  crit: "assets/sfx_critical_hit.mp3",
  tremorBurst: "assets/sfx_tremor_burst.mp3",
};

function playMatchSfx(path, vol=0.65){
  try{
    const a = new Audio(path);
    a.volume = vol;
    a.play().catch(()=>{});
  }catch(_e){}
}

function coinBackIconPath(type){
  const map = {
    normal: "assets/icon_coin_normal_back.png",
    fixed: "assets/icon_coin_fixed_back.png",
    extract: "assets/icon_coin_extract_back.png",
    annihilate: "assets/icon_coin_annihilate_back.png"
  };
  return map[String(type||'normal')] || map.normal;
}

function getSkillCoinCount(skill){
  return Math.max(1, Number(skill?.coinCount ?? skill?.qty ?? 1) || 1);
}

function getUnitLabel(unitKey){
  return unitKey === 'my' ? 'ë‚´ íŒ€' : 'ì ';
}

function getSelectedSkillForUnit(unit){
  if(!unit) return null;
  if(isUnitStaggerLocked(unit)) return null; // ííŠ¸ëŸ¬ì§„ í„´ì—ëŠ” í–‰ë™ ë¶ˆê°€
  const idx = Math.max(0, Number(unit.selectedSlot||0));
  return unit.pickedSkills?.[idx] || unit.pickedSkills?.[0] || null;
}

function isUnbreakableCoinSkill(skill){
  const t = String(skill?.coinType || 'normal').toLowerCase();
  return t === 'fixed';
}

function getSkillAtkLevel(skill, unit){
  const base = Math.max(0, Number(skill?.atkLevel ?? skill?.attackLevel ?? unit?.core?.status?.atkLv ?? unit?.core?.atkLevel ?? unit?.core?.atkLv ?? 0) || 0);
  const level = Math.max(0, Number(unit?.core?.status?.level ?? unit?.core?.level ?? 0) || 0);
  const growth = Number(skill?.growth ?? 0) || 0;
  const growthBonus = level * growth;
  return Math.max(0, base + growthBonus + getStatusPower(unit, ["ê³µê²© ë ˆë²¨ ì¦ê°€"]) - getStatusPower(unit, ["ê³µê²© ë ˆë²¨ ê°ì†Œ"]));
}


function getUnitDefLevel(unit){
  const base = Math.max(0, Number(unit?.core?.status?.defLv ?? unit?.core?.defLevel ?? unit?.core?.defLv ?? 0) || 0);
  return Math.max(0, base + getStatusPower(unit, ["ë°©ì–´ ë ˆë²¨ ì¦ê°€"]) - getStatusPower(unit, ["ë°©ì–´ ë ˆë²¨ ê°ì†Œ"]));
}

function getStatusPower(unit, names){
  const st = getStatusStack(unit, names);
  return Math.max(0, Number(st?.power || 0));
}

function shouldExpireWhenCountZero(name){
  const n = String(name||'').replace(/\s+/g,'');
  return ['í™”ìƒ','ì¶œí˜ˆ','ì§„ë™','íŒŒì—´','ì¹¨ì ','í˜¸í¡'].includes(n);
}
function cleanupStatusIfNeeded(unit, st){
  if(!unit || !st) return;
  const cnt = Math.max(0, Number(st.count||0));
  const pow = Math.max(0, Number(st.power||0));
  if(shouldExpireWhenCountZero(st.name)){
    if(cnt <= 0){
      unit.statusChips = (unit.statusChips||[]).filter(x => x !== st);
    }
  }else if(cnt <= 0 && pow <= 0){
    unit.statusChips = (unit.statusChips||[]).filter(x => x !== st);
  }
}



// ===== AUTO RULE RUNTIME (v1) =====
// NOTE: ìš°ì„  ê°€ì¥ ì•ˆì „í•œ 1ë‹¨ê³„ë§Œ êµ¬í˜„í•œë‹¤.
// - trigger: 'use'(ì‚¬ìš©ì‹œ)ë§Œ ì ìš©
// - refTarget/applyTarget: 'self'ë§Œ ì§€ì› (targetì€ ì´í›„ ë‹¨ê³„ì—ì„œ í™•ì¥)
// - effect: basePower / coinPower / clashPower (ìˆ«ì ë³´ì •)ë§Œ ì§€ì›
function getStatusStackByName(unit, name){
  if(!unit) return null;
  const n = String(name||'').replace(/\s+/g,'');
  if(!n) return null;
  const chips = Array.isArray(unit.statusChips) ? unit.statusChips : [];
  return chips.find(s => String(s?.name||'').replace(/\s+/g,'') === n) || null;
}

function evalAutoRuleRefValueSelf(unit, rule){
  const from = String(rule?.from||'fixed');
  const name = String(rule?.name||'').trim();
  if(from === 'fixed') return 1; // fixedëŠ” value ìì²´ë¥¼ ì“°ë„ë¡(ì•„ë˜ì—ì„œ ì²˜ë¦¬)
  if(from === 'debuffCount'){
    if(!name) return 0;
    const st = getStatusStackByName(unit, name);
    return Math.max(0, Number(st?.count||0) || 0);
  }
  if(from === 'keywordPower'){
    if(!name) return 0;
    const st = getStatusStackByName(unit, name);
    return Math.max(0, Number(st?.power||0) || 0);
  }
  if(from === 'keywordCount'){
    if(!name) return 0;
    const st = getStatusStackByName(unit, name);
    return Math.max(0, Number(st?.count||0) || 0);
  }
  if(from === 'keywordCountPer'){
    if(!name) return 0;
    const st = getStatusStackByName(unit, name);
    const cnt = Math.max(0, Number(st?.count||0) || 0);
    const per = Math.max(1, Number(rule?.per || 1) || 1);
    return Math.floor(cnt / per);
  }
  if(from === 'keywordPowerPlusCount'){
    if(!name) return 0;
    const st = getStatusStackByName(unit, name);
    return Math.max(0, (Number(st?.power||0)||0) + (Number(st?.count||0)||0));
  }
  return 0;
}

let __AUTO_RULE_TARGET_UNIT = null;
let __AUTO_RULE_DEBUG = true;

function getOpponentUnit(unit){
  try{
    if(typeof MATCH_STATE === 'undefined' || !MATCH_STATE) return null;
    if(!unit) return null;
    if(unit.side === 'my') return MATCH_STATE.enemy || null;
    if(unit.side === 'enemy') return MATCH_STATE.my || null;
    return null;
  }catch(_e){ return null; }
}


function getAutoRuleStatValue(unit, kwName, statKind){
  if(!unit) return 0;
  const st = getStatusStackByName(unit, kwName);
  const p = Math.max(0, Number(st?.power||0) || 0);
  const c = Math.max(0, Number(st?.count||0) || 0);
  const k = String(statKind||"power");
  if(k === "count") return c;
  if(k === "powerPlusCount") return p + c;
  return p;
}

function checkCompare(op, a, b){
  const x = Number(a||0)||0;
  const y = Number(b||0)||0;
  return (String(op||'>=') === '<=') ? (x <= y) : (x >= y);
}

// v2 ì¡°ê±´ í‰ê°€: ëª‡ ë²ˆ 'ë°œë™'í• ì§€(times) ë°˜í™˜
function evalAutoRuleCondTimesV2(rule, refUnit){
  const r = normalizeAutoRule(rule);
  if(r.v !== 2) return 0;

  const cond = String(r.condType||"none");
  if(cond === "none") return 1;

  const kw1 = String(r.kw1||"").trim();
  const kw2 = String(r.kw2||"").trim();
  const stat = String(r.condStat||"power");

  if(cond === "kwCompare"){
    if(!kw1) return 0;
    const v = getAutoRuleStatValue(refUnit, kw1, stat);
    return checkCompare(r.op, v, r.n) ? 1 : 0;
  }

  if(cond === "kwSumCompare"){
    if(!kw1 || !kw2) return 0;
    const v1 = getAutoRuleStatValue(refUnit, kw1, stat);
    const v2 = getAutoRuleStatValue(refUnit, kw2, stat);
    return checkCompare(r.op, v1+v2, r.n) ? 1 : 0;
  }

  if(cond === "kwPer"){
    if(!kw1) return 0;
    const v = getAutoRuleStatValue(refUnit, kw1, stat);
    const perN = Math.max(1, Number(r.perN||1)||1);
    const t = Math.floor(v / perN);
    return Math.max(0, t);
  }

  if(cond === "kwConsume"){
    if(!kw1) return 0;
    const kind = String(r.consumeStat||"power");
    const v = getAutoRuleStatValue(refUnit, kw1, kind === "count" ? "count" : "power");
    const need = Math.max(0, Number(r.consumeN||0)||0);
    return (v >= need && need > 0) ? 1 : 0;
  }

  return 0;
}

function applyAutoRuleConsumeV2(rule, refUnit){
  const r = normalizeAutoRule(rule);
  if(r.v !== 2) return false;
  if(String(r.condType||"") !== "kwConsume") return false;

  const kw = String(r.kw1||"").trim();
  if(!kw || !refUnit) return false;

  const need = Math.max(0, Number(r.consumeN||0)||0);
  if(need <= 0) return false;

  const st = getStatusStackByName(refUnit, kw);
  if(!st) return false;

  if(String(r.consumeStat||"power") === "count"){
    if((Number(st.count||0)||0) < need) return false;
    st.count = Math.max(0, (Number(st.count||0)||0) - need);
  }else{
    if((Number(st.power||0)||0) < need) return false;
    st.power = Math.max(0, (Number(st.power||0)||0) - need);
  }
  cleanupStatusIfNeeded(refUnit, st);
  return true;
}

function getAutoRuleNumericBonus(skill, unit, trigger, effect, phase){
  const rules = Array.isArray(skill?.autoRules) ? skill.autoRules : [];
  if(!rules.length) return 0;

  const trg = String(trigger||'use');
  const eff = String(effect||'');
  const ph  = String(phase||'attack');

  let sum = 0;

  for(const r0 of rules){
    const r = normalizeAutoRule(r0);

    // ---- v1 (ë ˆê±°ì‹œ) ----
    if(r.v === 1){
      if(String(r.trigger||'use') !== trg) continue;
      if(String(r.applyTarget||'self') !== 'self') continue;

      let refUnit = (String(r.refTarget||'self') === 'target') ? (__AUTO_RULE_TARGET_UNIT||null) : unit;
      if(!refUnit && String(r.refTarget||'self') === 'target') refUnit = getOpponentUnit(unit);
      if(String(r.from||'fixed') !== 'fixed' && !refUnit) continue;

      if(String(r.effect||'') !== eff) continue;
      if(eff === 'clashPower' && ph !== 'clash') continue;

      let amt = 0;
      if(String(r.from||'fixed') === 'fixed'){
        amt = Number(r.value||0) || 0;
      }else{
        const refV = evalAutoRuleRefValueSelf(refUnit, r);
        amt = (Number(refV)||0) * (Number(r.value||0)||0);
      }
      if(r.max > 0) amt = Math.min(amt, Number(r.max||0));
      sum += amt;
      continue;
    }

    // ---- v2 (ê°œí¸) ----
    const rTrg = String(r.trigger||"use");
    if(!(rTrg === trg || (rTrg === "always" && trg === "use") || (rTrg === "always" && trg === "onHit"))){
      // ìƒì‹œëŠ” use/onHit í‰ê°€ì— í•¨ê»˜ ì„ì´ë„ë¡(ê°€ì¥ ë¬´ë‚œ)
      continue;
    }

    // action type filter
    if(String(r.actType||"") !== "powerMod") continue;

    // map effect key
    const kind = String(r.powerKind||"attackPower");
    const effectKey =
      (kind === "clashPower") ? "clashPower" :
      (kind === "basePower") ? "basePower" :
      (kind === "plusCoinPower") ? "plusCoinPower" :
      (kind === "minusCoinPower") ? "minusCoinPower" :
      (kind === "defensePower") ? "defensePower" :
      "attackPower";

    if(effectKey !== eff) continue;
    if(effectKey === "clashPower" && ph !== "clash") continue;

    // ì ìš© ëŒ€ìƒì´ selfê°€ ì•„ë‹ ë•ŒëŠ” ìˆ«ì ë³´ë„ˆìŠ¤ ê³„ì‚°ì—ì„œ ì œì™¸(ìŠ¤í‚¬ ìœ„ë ¥ì€ 'ì‹œì „ì'ì—ë§Œ ì ìš©í•˜ëŠ” ê²Œ ì•ˆì „)
    if(String(r.applyTarget||"self") !== "self") continue;

    // ref unit
    let refUnit = unit;
    if(String(r.refTarget||"self") === "target"){
      refUnit = (__AUTO_RULE_TARGET_UNIT || getOpponentUnit(unit) || null);
    }else if(String(r.refTarget||"self") === "none"){
      refUnit = null;
    }

    // times
    let times = 1;
    if(r.condType !== "none"){
      if(!refUnit) continue;
      times = evalAutoRuleCondTimesV2(r, refUnit);
    }
    if(times <= 0) continue;

    // cap on times
    if(r.cap > 0) times = Math.min(times, Number(r.cap||0));

    const amt = (Number(r.powerAmt||0)||0) * times;
    sum += amt;
  }

  return Math.trunc(sum);
}


// ===== AUTO RULE RUNTIME (v2 - onHit: grantKeyword) =====
// ìµœì†Œ êµ¬í˜„: "ì ì¤‘ì‹œ(onHit) + ì½”ì¸ ë²ˆí˜¸(hitIndex) + ëŒ€ìƒì—ê²Œ í‚¤ì›Œë“œ ë¶€ì—¬(grantKeyword)"
// - í˜„ì¬ êµ¬í˜„ì€ ê°€ì¥ ì•ˆì „í•œ í˜•íƒœë¡œ, "ë¶€ì—¬"ë§Œ ì§€ì›í•œë‹¤(ì†Œëª¨/ë³µí•©ì€ ì´í›„ í™•ì¥).
// ìƒíƒœ ì´ë¦„ì´ ë””ë²„í”„ì¸ì§€ ëŒ€ì¶© íŒì •(í‘œì‹œìš©). ì •í™•í•œ ë¶„ë¥˜ëŠ” ì´í›„ í™•ì¥ ê°€ëŠ¥.
function isKnownDebuff(name){
  const n = String(name||"").trim();
  if(!n) return true;
  const debuffs = ["í™”ìƒ","ì¶œí˜ˆ","ì§„ë™","ì§„ë™í­ë°œ","íŒŒì—´","ì¹¨ì ","ì†ë°•","ë§ˆë¹„","ì·¨ì•½","ì•½í™”","ì €ì£¼","ì¤‘ë…","ë¶„ë…¸","ìš°ìš¸","ë‚˜íƒœ","ìƒ‰ìš•","íƒì‹","ì§ˆíˆ¬","ì˜¤ë§Œ"];
  const buffs = ["í˜¸í¡","ì˜ˆì§€ì•ˆ","ë³´í˜¸ë§‰","ì •ì‹ ë ¥"];
  if(buffs.some(k=>n.includes(k))) return false;
  if(debuffs.some(k=>n.includes(k))) return true;
  return true;
}

function addOrGetStatus(unit, name){
  if(!unit) return null;
  unit.statusChips = Array.isArray(unit.statusChips) ? unit.statusChips : [];
  const n = String(name||'').trim();
  if(!n) return null;
  let st = unit.statusChips.find(s => String(s?.name||'').trim() === n);
  if(!st){
    st = { name:n, state:isKnownDebuff(n)?'debuff':'buff', power:0, count:0 };
    unit.statusChips.push(st);
  }
  return st;
}
function addStatusStacks(unit, name, powerAdd=0, countAdd=0){
  // Special: ì§„ë™ í­ë°œì€ 'ìƒíƒœë¡œ ìœ ì§€'ë˜ì§€ ì•Šê³ , íšŸìˆ˜ ë¶€ì—¬ ì¦‰ì‹œ í­ë°œ ì²˜ë¦¬ í›„ ì‚­ì œëœë‹¤.
  // - ìœ„ë ¥(power)ì€ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
  // - íšŸìˆ˜(count) * (ì§„ë™ ìœ„ë ¥) ë§Œí¼ ííŠ¸ëŸ¬ì§ì„ ì„ ì•ë‹¹ê¸´ë‹¤.
  const kwNorm = String(name||'').replace(/\s+/g,'');
  if(kwNorm === 'ì§„ë™í­ë°œ'){
    const burstCount = Math.max(0, Number(countAdd)||0);
    // 0ì´ë©´ ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•ŠìŒ
    if(burstCount > 0){
      try{ applyTremorBurstPull(unit.side === 'enemy' ? 'enemy' : 'my', burstCount); }catch(_e){}
      try{
        const tremP = Math.max(0, Number(getStatusPower(unit, ["ì§„ë™"])||0));
        const amt = burstCount * tremP;
        appendMatchLogIcon("tremorBurst", `${unit.side==="my"?"ë‚´ íŒ€":"ì "} ííŠ¸ì„  ì••ë‹¹ê¹€ +${amt} (ì§„ë™ í­ë°œ)`, {cls:"tremor"});
      }catch(_e){}
    }
    // í˜¹ì‹œ ê¸°ì¡´ì— ì¹©ì´ ìˆë‹¤ë©´ ì •ë¦¬
    try{ unit.statusChips = (unit.statusChips||[]).filter(s => String(s?.name||'').replace(/\s+/g,'') !== 'ì§„ë™í­ë°œ'); }catch(_e){}
  }else{
    const st = addOrGetStatus(unit, name);
    if(!st) return;
    const p = Math.max(0, Number(st.power||0) + (Number(powerAdd)||0));
    const c = Math.max(0, Number(st.count||0) + (Number(countAdd)||0));
    st.power = p;
    st.count = c;
    cleanupStatusIfNeeded(unit, st);
  }

  // ìƒíƒœì¹© UI ì¦‰ì‹œ ê°±ì‹ (ì˜µì…˜)
  try{
    if(typeof STATUS_RENDER_REALTIME !== 'undefined' && STATUS_RENDER_REALTIME && typeof MATCH_STATE !== 'undefined' && MATCH_STATE && typeof EL_MATCH !== 'undefined' && EL_MATCH){
      const el = (unit && unit.side === 'my') ? EL_MATCH.myStatus : (unit && unit.side === 'enemy') ? EL_MATCH.enemyStatus : null;
      if(el){
        renderChipWrap(el, (unit.statusChips||[]));
        ensureKwTooltipBound(el);
        // ë²„íŠ¼ ìƒíƒœ(í˜¸íŠ¸/í•´ì œ ë“±)ë„ ì¦‰ì‹œ ë°˜ì˜
        if(typeof ensureStatusActionButtons === 'function') ensureStatusActionButtons();
      }
    }
  }catch(_e){}
}
// onHit íŠ¸ë¦¬ê±° ì²˜ë¦¬(ì½”ì¸ ë‹¨ìœ„)

function applyAutoRulesOnHit(skill, attackerUnit, defenderUnit, coinIndex){
  const rules = Array.isArray(skill?.autoRules) ? skill.autoRules : [];
  if(!rules.length) return;

  const hitIdx = Math.max(1, Number(coinIndex||1) || 1);

  for(const r0 of rules){
    const r = normalizeAutoRule(r0);

    // ---- v1 ----
    if(r.v === 1){
      if(String(r.trigger||'') !== 'onHit') continue;
      const needIdx = Math.max(1, Number(r.hitIndex||1) || 1);
      if(needIdx !== hitIdx) continue;
      if(String(r.effect||'') !== 'grantKeyword') continue;

      const tgt = (String(r.applyTarget||'target') === 'self') ? attackerUnit : defenderUnit;
      if(!tgt) continue;

      const key = String(r.name||'').trim();
      if(!key) continue;

      const powerAdd = Number(r.value||0) || 0;
      const countAdd = Number(r.max||0) || 0;
      addStatusStacks(tgt, key, powerAdd, countAdd);
      appendMatchLog?.(`[ìë™ê·œì¹™] ${hitIdx}ì½”ì¸ ì ì¤‘: ${tgt.side==="my"?"ë‚´ íŒ€":"ì "} ${key} +${powerAdd}${countAdd?` / íšŸìˆ˜ +${countAdd}`:''}`);
      continue;
    }

    // ---- v2 ----
    const trg = String(r.trigger||"");
    if(trg !== "onHit" && trg !== "always") continue;

    if(trg === "onHit"){
      const needIdx = Math.max(1, Number(r.hitIndex||1) || 1);
      if(needIdx !== hitIdx) continue;
    }

    // targets
    const applyUnit =
      (String(r.applyTarget||"self")==="target") ? defenderUnit :
      (String(r.applyTarget||"self")==="none") ? null :
      attackerUnit;

    if(!applyUnit) continue;

    let refUnit =
      (String(r.refTarget||"self")==="target") ? defenderUnit :
      (String(r.refTarget||"self")==="none") ? null :
      attackerUnit;

    let times = 1;
    if(r.condType !== "none"){
      if(!refUnit) continue;
      times = evalAutoRuleCondTimesV2(r, refUnit);
      if(times <= 0) continue;
    }
    if(r.cap > 0) times = Math.min(times, Number(r.cap||0));

    // consume condition -> consume once (times is 1 anyway)
    if(r.condType === "kwConsume"){
      if(!applyAutoRuleConsumeV2(r, refUnit)) continue;
    }

    const act = String(r.actType||"");
    if(act === "keywordMod"){
      const key = String(r.actKw||"").trim();
      if(!key) continue;
      const pAdd = (Number(r.actKwPow||0)||0) * times;
      const cAdd = (Number(r.actKwCnt||0)||0) * times;
      addStatusStacks(applyUnit, key, pAdd, cAdd);
      appendMatchLog?.(`[ìë™ê·œì¹™] ${hitIdx}ì½”ì¸ ì ì¤‘: ${applyUnit.side==="my"?"ë‚´ íŒ€":"ì "} ${key} ${pAdd?`ìœ„ë ¥ ${pAdd>=0?`+${pAdd}`:pAdd}`:''}${cAdd?` / íšŸìˆ˜ ${cAdd>=0?`+${cAdd}`:cAdd}`:''}`);
      continue;
    }

    if(act === "damageMod"){
      // ê¸°ì¡´ í”¼í•´ëŸ‰ ì‹œìŠ¤í…œê³¼ ìì—°ìŠ¤ëŸ½ê²Œ ì„ì´ë„ë¡ ìƒíƒœë¡œ í™˜ì‚°(1ìŠ¤íƒ=10%)
      const amt = (Number(r.dmgAmt||0)||0) * times;
      if(amt === 0) continue;
      const isDown = String(r.dmgKind||"dealUp") === "dealDown";
      const kw = isDown ? "í”¼í•´ëŸ‰ ê°ì†Œ" : "í”¼í•´ëŸ‰ ì¦ê°€";
      addStatusStacks(attackerUnit, kw, amt, 0);
      appendMatchLog?.(`[ìë™ê·œì¹™] ${hitIdx}ì½”ì¸ ì ì¤‘: ${getUnitLabel(attackerUnit?.side)} ${kw} ${amt>=0?`+${amt}`:amt}(ìŠ¤íƒ)`);
      continue;
    }

    if(act === "skillChange"){
      appendMatchLog?.(`[ìë™ê·œì¹™] (ì ê¸ˆ) ìŠ¤í‚¬ ë³€ê²½ ê·œì¹™ì´ ë°œë™ ì¡°ê±´ì„ ë§Œì¡±í–ˆì§€ë§Œ ì‹¤í–‰ì€ ë§‰í˜€ìˆì–´: ${r.label||autoRuleSummary(r)}`);
      continue;
    }

    // powerModëŠ” 'ìŠ¤í‚¬ êµ´ë¦¼' ê³„ì‚°ì‹ì— ë“¤ì–´ê°€ëŠ” í¸ì´ ì•ˆì „í•´ì„œ ì—¬ê¸°ì„œëŠ” ì§ì ‘ ì ìš©í•˜ì§€ ì•ŠìŒ
  }
}

// use íŠ¸ë¦¬ê±° ì²˜ë¦¬// use íŠ¸ë¦¬ê±° ì²˜ë¦¬(ìŠ¤í‚¬ ì‚¬ìš© ì‹œì  1íšŒ)
// - "ì‚¬ìš©ì‹œ í‚¤ì›Œë“œ Nì˜ ìœ„ë ¥/íšŸìˆ˜ ì¦ê°€" ê°™ì€ ìƒíƒœ ë³€í™”ê°€ í•„ìš”í•´ì„œ ì¶”ê°€
// - ë™ì¼ ìŠ¤í‚¬ì´ ê°™ì€ í„´ì— ê°™ì€ ìœ ë‹›ì—ì„œ ì—¬ëŸ¬ ë²ˆ í‰ê°€ë˜ëŠ” ê²ƒì„ ë§‰ê¸° ìœ„í•´ í„´ ê¸°ë°˜ ê°€ë“œë¥¼ ë‘”ë‹¤.
function applyAutoRulesOnUse(skill, userUnit, targetUnit){
  try{
    const rules = Array.isArray(skill?.autoRules) ? skill.autoRules : [];
    if(!rules.length || !userUnit) return;

    const turn = (MATCH_STATE && Number(MATCH_STATE.turn||0)) ? Number(MATCH_STATE.turn||0) : 0;
    const sid = String(userUnit.side||'');
    const skId = String(skill?.id || skill?.uid || skill?._id || skill?.name || 'skill');
    const guardKey = `${sid}::${skId}::${turn}`;
    userUnit.__autoUseApplied = userUnit.__autoUseApplied || {};
    if(userUnit.__autoUseApplied[guardKey]) return;
    userUnit.__autoUseApplied[guardKey] = true;

    for(const r0 of rules){
      const r = normalizeAutoRule(r0);

      // ---- v1 ----
      if(r.v === 1){
        if(String(r.trigger||'use') !== 'use') continue;
        if(String(r.effect||'') !== 'grantKeyword') continue;

        const tgt = (String(r.applyTarget||'self') === 'target') ? (targetUnit || __AUTO_RULE_TARGET_UNIT || getOpponentUnit(userUnit)) : userUnit;
        if(!tgt) continue;

        const key = String(r.name||'').trim();
        if(!key) continue;

        const powerAdd = Number(r.value||0) || 0;
        let countAdd;
        const rawMax = r.max;
        const hasExplicitMax = !(rawMax === undefined || rawMax === null || (typeof rawMax === 'string' && rawMax.trim() === ''));
        if(hasExplicitMax) countAdd = Number(rawMax||0) || 0;
        else countAdd = powerAdd;

        addStatusStacks(tgt, key, powerAdd, countAdd);
        appendMatchLog?.(`[ìë™ê·œì¹™] ì‚¬ìš©ì‹œ: ${tgt.side==="my"?"ë‚´ íŒ€":"ì "} ${key} +${powerAdd}${countAdd?` / íšŸìˆ˜ +${countAdd}`:''}`, {cls:'muted'});
        continue;
      }

      // ---- v2 ----
      const trg = String(r.trigger||"use");
      if(trg !== "use" && trg !== "always") continue;

      // targets
      const applyUnit =
        (String(r.applyTarget||"self")==="target") ? (targetUnit || __AUTO_RULE_TARGET_UNIT || getOpponentUnit(userUnit) || null) :
        (String(r.applyTarget||"self")==="none") ? null :
        userUnit;

      if(!applyUnit) continue;

      let refUnit =
        (String(r.refTarget||"self")==="target") ? (targetUnit || __AUTO_RULE_TARGET_UNIT || getOpponentUnit(userUnit) || null) :
        (String(r.refTarget||"self")==="none") ? null :
        userUnit;

      let times = 1;
      if(r.condType !== "none"){
        if(!refUnit) continue;
        times = evalAutoRuleCondTimesV2(r, refUnit);
        if(times <= 0) continue;
      }
      if(r.cap > 0) times = Math.min(times, Number(r.cap||0));

      if(r.condType === "kwConsume"){
        if(!applyAutoRuleConsumeV2(r, refUnit)) continue;
      }

      const act = String(r.actType||"");
      if(act === "keywordMod"){
        const key = String(r.actKw||"").trim();
        if(!key) continue;
        const pAdd = (Number(r.actKwPow||0)||0) * times;
        const cAdd = (Number(r.actKwCnt||0)||0) * times;
        addStatusStacks(applyUnit, key, pAdd, cAdd);
        appendMatchLog?.(`[ìë™ê·œì¹™] ì‚¬ìš©ì‹œ: ${applyUnit.side==="my"?"ë‚´ íŒ€":"ì "} ${key} ${pAdd?`ìœ„ë ¥ ${pAdd>=0?`+${pAdd}`:pAdd}`:''}${cAdd?` / íšŸìˆ˜ ${cAdd>=0?`+${cAdd}`:cAdd}`:''}`, {cls:'muted'});
        continue;
      }

      if(act === "damageMod"){
        const amt = (Number(r.dmgAmt||0)||0) * times;
        if(amt === 0) continue;
        const isDown = String(r.dmgKind||"dealUp") === "dealDown";
        const kw = isDown ? "í”¼í•´ëŸ‰ ê°ì†Œ" : "í”¼í•´ëŸ‰ ì¦ê°€";
        addStatusStacks(userUnit, kw, amt, 0);
        appendMatchLog?.(`[ìë™ê·œì¹™] ì‚¬ìš©ì‹œ: ${getUnitLabel(userUnit?.side)} ${kw} ${amt>=0?`+${amt}`:amt}(ìŠ¤íƒ)`, {cls:'muted'});
        continue;
      }

      if(act === "skillChange"){
        appendMatchLog?.(`[ìë™ê·œì¹™] (ì ê¸ˆ) ìŠ¤í‚¬ ë³€ê²½ ê·œì¹™ì´ ë°œë™ ì¡°ê±´ì„ ë§Œì¡±í–ˆì§€ë§Œ ì‹¤í–‰ì€ ë§‰í˜€ìˆì–´: ${r.label||autoRuleSummary(r)}`, {cls:'muted'});
        continue;
      }

      // powerModëŠ” ë³„ë„ì˜ ìˆ˜ì¹˜ ë³´ë„ˆìŠ¤ ê³„ì‚°(getAutoRuleNumericBonus)ì—ì„œ ì²˜ë¦¬
    }
  }catch(_e){}
}


function applyAutoRulesOnClashResult(skill, selfUnit, targetUnit, result){
  // result: "win" | "lose"
  try{
    const rules = Array.isArray(skill?.autoRules) ? skill.autoRules : [];
    if(!rules.length || !selfUnit) return;

    const trgNeed = (result === "win") ? "clashWin" : "clashLose";

    for(const r0 of rules){
      const r = normalizeAutoRule(r0);
      if(r.v !== 2) continue; // v1ì€ clash íŠ¸ë¦¬ê±°ê°€ ì—†ì—ˆìŒ

      const trg = String(r.trigger||"");
      if(trg !== trgNeed && trg !== "always") continue;

      const applyUnit =
        (String(r.applyTarget||"self")==="target") ? targetUnit :
        (String(r.applyTarget||"self")==="none") ? null :
        selfUnit;
      if(!applyUnit) continue;

      const refUnit =
        (String(r.refTarget||"self")==="target") ? targetUnit :
        (String(r.refTarget||"self")==="none") ? null :
        selfUnit;

      let times = 1;
      if(r.condType !== "none"){
        if(!refUnit) continue;
        times = evalAutoRuleCondTimesV2(r, refUnit);
        if(times <= 0) continue;
      }
      if(r.cap > 0) times = Math.min(times, Number(r.cap||0));

      if(r.condType === "kwConsume"){
        if(!applyAutoRuleConsumeV2(r, refUnit)) continue;
      }

      const act = String(r.actType||"");
      if(act === "keywordMod"){
        const key = String(r.actKw||"").trim();
        if(!key) continue;
        const pAdd = (Number(r.actKwPow||0)||0) * times;
        const cAdd = (Number(r.actKwCnt||0)||0) * times;
        addStatusStacks(applyUnit, key, pAdd, cAdd);
        appendMatchLog?.(`[ìë™ê·œì¹™] í•© ${result==="win"?"ìŠ¹ë¦¬":"íŒ¨ë°°"}: ${applyUnit.side==="my"?"ë‚´ íŒ€":"ì "} ${key} ${pAdd?`ìœ„ë ¥ ${pAdd>=0?`+${pAdd}`:pAdd}`:''}${cAdd?` / íšŸìˆ˜ ${cAdd>=0?`+${cAdd}`:cAdd}`:''}`, {cls:'muted'});
        continue;
      }

      if(act === "damageMod"){
        const amt = (Number(r.dmgAmt||0)||0) * times;
        if(amt === 0) continue;
        const isDown = String(r.dmgKind||"dealUp") === "dealDown";
        const kw = isDown ? "í”¼í•´ëŸ‰ ê°ì†Œ" : "í”¼í•´ëŸ‰ ì¦ê°€";
        addStatusStacks(selfUnit, kw, amt, 0);
        appendMatchLog?.(`[ìë™ê·œì¹™] í•© ${result==="win"?"ìŠ¹ë¦¬":"íŒ¨ë°°"}: ${getUnitLabel(selfUnit?.side)} ${kw} ${amt>=0?`+${amt}`:amt}(ìŠ¤íƒ)`, {cls:'muted'});
        continue;
      }

      if(act === "skillChange"){
        appendMatchLog?.(`[ìë™ê·œì¹™] (ì ê¸ˆ) í•© ${result} ìŠ¤í‚¬ ë³€ê²½ ê·œì¹™(ì‹¤í–‰ ë§‰í˜): ${r.label||autoRuleSummary(r)}`, {cls:'muted'});
        continue;
      }
    }
  }catch(_e){}
}

function getSkillPowerBonus(skill, unit, phase="attack", targetUnit=null){
  // NOTE: 'í•©ê°€ëŠ¥ ë°˜ê²©(clash_counter)'ì€ íŒì •ì€ ê³µê²© ìŠ¤í‚¬ì²˜ëŸ¼ í•˜ì§€ë§Œ,
  // ìœ„ë ¥ ì¦ê°ì€ ê³µê²© ìœ„ë ¥/ê°ì†Œê°€ ì•„ë‹ˆë¼ ìˆ˜ë¹„ ìœ„ë ¥ ì¦ê°ì˜ ì˜í–¥ì„ ë°›ëŠ”ë‹¤.
  const atkType = String(skill?.atkType || skill?.type || '').toLowerCase();
  const atk = (atkType === 'clash_counter') ? false : isAttackSkillAction(skill);

  const baseUp = getStatusPower(unit, ["ìœ„ë ¥ ì¦ê°€"]);
  const baseDn = getStatusPower(unit, ["ìœ„ë ¥ ê°ì†Œ"]);
  const atkUp  = atk ? getStatusPower(unit, ["ê³µê²© ìœ„ë ¥ ì¦ê°€"]) : 0;
  const atkDn  = atk ? getStatusPower(unit, ["ê³µê²© ìœ„ë ¥ ê°ì†Œ"]) : 0;
  const defUp  = !atk ? getStatusPower(unit, ["ìˆ˜ë¹„ ìœ„ë ¥ ì¦ê°€"]) : 0;
  const defDn  = !atk ? getStatusPower(unit, ["ìˆ˜ë¹„ ìœ„ë ¥ ê°ì†Œ"]) : 0;
  const clashUp = (phase === "clash") ? getStatusPower(unit, ["í•© ìœ„ë ¥ ì¦ê°€"]) : 0;
  const clashDn = (phase === "clash") ? getStatusPower(unit, ["í•© ìœ„ë ¥ ê°ì†Œ"]) : 0;

  const __prevAutoTarget = __AUTO_RULE_TARGET_UNIT;
  if(targetUnit) __AUTO_RULE_TARGET_UNIT = targetUnit;

  const arBase  = getAutoRuleNumericBonus(skill, unit, 'use', 'basePower', phase);
  const arClash = getAutoRuleNumericBonus(skill, unit, 'use', 'clashPower', phase);

  // v2 í™•ì¥: ê³µê²©/ìˆ˜ë¹„ ìœ„ë ¥ ì „ìš©
  const arAtk   = atk ? getAutoRuleNumericBonus(skill, unit, 'use', 'attackPower', phase) : 0;
  const arDef   = !atk ? getAutoRuleNumericBonus(skill, unit, 'use', 'defensePower', phase) : 0;

  __AUTO_RULE_TARGET_UNIT = __prevAutoTarget;

  return baseUp - baseDn + atkUp - atkDn + defUp - defDn + clashUp - clashDn + arBase + arClash + arAtk + arDef;
}


function getCoinPowerStatusBonus(skill, unit, targetUnit=null){
  const __prevAutoTarget = __AUTO_RULE_TARGET_UNIT;
  if(targetUnit) __AUTO_RULE_TARGET_UNIT = targetUnit;
  try{
    const sign = String(skill?.coinSign || '+') === '-' ? -1 : 1;

    if(sign > 0){
      const stBonus = getStatusPower(unit, ["ë”í•˜ê¸° ì½”ì¸ ì¦ê°€"]) - getStatusPower(unit, ["ë”í•˜ê¸° ì½”ì¸ ì•½í™”", "ë”í•˜ê¸° ì½”ì¸ ê°ì†Œ"]);
      const arLegacy = getAutoRuleNumericBonus(skill, unit, 'use', 'coinPower', 'attack'); // v1 í˜¸í™˜
      const arPlus   = getAutoRuleNumericBonus(skill, unit, 'use', 'plusCoinPower', 'attack');
      return stBonus + arLegacy + arPlus;
    }

    const stBonus = getStatusPower(unit, ["ë¹¼ê¸° ì½”ì¸ ì¦ê°€"]) - getStatusPower(unit, ["ë¹¼ê¸° ì½”ì¸ ì•½í™”", "ë¹¼ê¸° ì½”ì¸ ê°ì†Œ"]);
    const arLegacy = getAutoRuleNumericBonus(skill, unit, 'use', 'coinPower', 'attack');
    const arMinus  = getAutoRuleNumericBonus(skill, unit, 'use', 'minusCoinPower', 'attack');
    return stBonus + arLegacy + arMinus;
  } finally {
    __AUTO_RULE_TARGET_UNIT = __prevAutoTarget;
  }
}


function consumeParalysisForCoin(unit){
  const st = getStatusStack(unit, ["ë§ˆë¹„"]);
  if(!st) return false;
  if(Number(st.power || 0) <= 0) return false;
  st.power = Math.max(0, Number(st.power || 0) - 1);
  if(Number(st.power || 0) <= 0 && Number(st.count || 0) <= 0){
    unit.statusChips = unit.statusChips.filter(x => x !== st);
  }
  appendMatchLog(`- ${getUnitLabel(unit?.side)} ë§ˆë¹„ ë°œë™! ì´ë²ˆ ì½”ì¸ ìœ„ë ¥ 0`, {cls:'sinking'});
  return true;
}

function getDamageDealtMultiplier(unit){
  const up = getStatusPower(unit, ["í”¼í•´ëŸ‰ ì¦ê°€"]);
  const dn = getStatusPower(unit, ["í”¼í•´ëŸ‰ ê°ì†Œ"]);
  return Math.max(0.1, 1 + ((up - dn) * 0.1));
}

function getDamageTakenMultiplier(unit){
  const fragile = getStatusPower(unit, ["ì·¨ì•½"]);
  const prot = getStatusPower(unit, ["ë³´í˜¸"]);
  return Math.max(0.1, 1 + ((fragile - prot) * 0.1));
}

function getClashAtkLevelBonus(skill, enemySkill, unit, enemyUnit){
  const diff = getSkillAtkLevel(skill, unit) - getSkillAtkLevel(enemySkill, enemyUnit);
  return diff > 0 ? Math.floor(diff / 3) : 0;
}


function getDamageLevelMultiplier(skill, attackerUnit, defenderUnit){
  const atk = getSkillAtkLevel(skill, attackerUnit);
  const de = getUnitDefLevel(defenderUnit);
  const diff = atk - de;
  const bonus = diff / ((Math.abs(diff) + 25) || 25);
  return 1 + bonus;
}


function getResistMultiplier(unit, atkType){
  if(unit?.isStaggered){
    const tier = Math.max(0, Number(unit?.staggerTier||0));
    if(tier >= 2) return 3.0;
    if(tier === 1) return 2.5;
    return 2.0;
  }
  const phys = normalizePhysRes(unit?.core?.physRes || unit?.core?.physicalRes || unit?.core?.phys || {});
  const keyMap = { slash:'ì°¸ê²©', pierce:'ê´€í†µ', blunt:'íƒ€ê²©' };
  const label = phys[keyMap[String(atkType||'slash')]] || 'ë³´í†µ';
  if(String(label).includes('ì•½ì ')) return 2.0;
  if(String(label).includes('ê²¬ë”¤')) return 0.75;
  if(String(label).includes('ë‚´ì„±')) return 0.5;
  return 1.0;
}

async function playSkillActivationAudio(skill){
  if(!skill) return false;
  return await playSkillAudioSpec(skill.hitSfx || "", skill.hitSfxKey || "", 0.78);
}

async function playSkillCoinAudio(skill, coinIndex){
  if(!skill) return false;
  const paths = Array.isArray(skill.coinSfxPaths) ? skill.coinSfxPaths : [];
  const keys = Array.isArray(skill.coinSfxKeys) ? skill.coinSfxKeys : [];
  const idx = Math.max(1, Number(coinIndex||1)) - 1;
  return await playSkillAudioSpec(paths[idx] || "", keys[idx] || "", 0.72);
}

function flipCoinForSkill(skill, unit, bonusCoinPower=0, phase="attack", coinIndex=1, targetUnit=null){
  if(!targetUnit) targetUnit = (__AUTO_RULE_TARGET_UNIT || null);
  const headChance = getCoinHeadChance(unit);
  const head = Math.random() < headChance;
  const sign = String(skill?.coinSign || '+') === '-' ? -1 : 1;
  const paralyzed = consumeParalysisForCoin(unit);
  const statusCoinBonus = paralyzed ? 0 : getCoinPowerStatusBonus(skill, unit, targetUnit);
  const coinPower = paralyzed ? 0 : ((Number(skill?.coinPower || 0) || 0) + (Number(bonusCoinPower||0) || 0) + statusCoinBonus);
  playMatchSfx(head ? MATCH_SFX.coinHead : MATCH_SFX.coinTail, 0.33);
  return {
    head,
    value: head ? (sign * coinPower) : 0,
    icon: head ? coinIconPath(skill?.coinType || 'normal') : coinBackIconPath(skill?.coinType || 'normal'),
    headChance,
    coinPower
  };
}


function rollSkillTotal(skill, unit, remainingCoins, bonusCoinPower=0, clashBonus=0, targetUnit=null){
  applyBleedOnSkillUse(unit, skill, getUnitLabel(unit?.side));
  const baseBonus = getSkillPowerBonus(skill, unit, "clash", targetUnit);
  const base = (Number(skill?.power || 0) || 0) + baseBonus;
  let total = base + (Number(clashBonus||0) || 0);
  const flips = [];
  const icons = [];
  for(let i=0;i<remainingCoins;i++){
    const f = flipCoinForSkill(skill, unit, bonusCoinPower, "clash", i+1, targetUnit);
    total += f.value;
    flips.push(f.head ? 'ì•' : 'ë’¤');
    icons.push(f.icon);
  }
  return { total, flips, icons, base, remainingCoins, clashBonus:(Number(clashBonus||0)||0), baseBonus };
}


function performClash(skillA, skillB, unitA, unitB, labelA, labelB){
  let aRemain = getSkillCoinCount(skillA);
  let bRemain = getSkillCoinCount(skillB);
  let aDestroyed = 0;
  let bDestroyed = 0;
  let safety = 0;
  appendMatchLog(`[í•©] ${labelA} â†” ${labelB}`);

  // ìë™ê·œì¹™(use) - ìƒíƒœ ë¶€ì—¬ëŠ” í•© ì‹œì‘ ì‹œì ì— 1íšŒë§Œ ì ìš©
  applyAutoRulesOnUse(skillA, unitA, unitB);
  applyAutoRulesOnUse(skillB, unitB, unitA);

  const aIsClashGuard = getDefenseMode(skillA) === 'clashGuard';
  const bIsClashGuard = getDefenseMode(skillB) === 'clashGuard';
  // í•©ê°€ëŠ¥ ìˆ˜ë¹„(clashGuard): ì½”ì¸ íŒŒê´´ ë¶ˆê°€. í•© ìì²´ëŠ” ì¼ë°˜ í•©ê³¼ ë™ì¼í•˜ê²Œ ê³„ì† ì§„í–‰í•œë‹¤.
  // ë‹¨, í•©ê°€ëŠ¥ ìˆ˜ë¹„ê°€ ê³„ì† íŒ¨ë°°í•´ì„œ ìƒëŒ€ ì½”ì¸ì´ íŒŒê´´ë˜ì§€ ì•ŠëŠ” ê²½ìš° ë¬´í•œ ë£¨í”„ë¥¼ ë§‰ê¸° ìœ„í•´ ë¼ìš´ë“œ ìƒí•œ(safety)ì„ ë‘”ë‹¤.
  let aLastTotal = 0;
  let bLastTotal = 0;
  while(safety++ < 120){
    const aClashBonus = getClashAtkLevelBonus(skillA, skillB, unitA, unitB);
    const bClashBonus = getClashAtkLevelBonus(skillB, skillA, unitB, unitA);
    const aRoll = rollSkillTotal(skillA, unitA, aRemain, 0, aClashBonus, unitB);
    const bRoll = rollSkillTotal(skillB, unitB, bRemain, 0, bClashBonus, unitA);
    appendMatchLog(`- ${labelA}: ${aRoll.total} (${aRoll.flips.join('/')})${aClashBonus?` / ê³µë ™ë³´ì • +${aClashBonus}`:''}`);
    appendMatchLog(`- ${labelB}: ${bRoll.total} (${bRoll.flips.join('/')})${bClashBonus?` / ê³µë ™ë³´ì • +${bClashBonus}`:''}`);
    if(aRoll.total === bRoll.total){
      playMatchSfx(MATCH_SFX.clashDraw, 0.5);
      appendMatchLog(`= ë¬´ìŠ¹ë¶€. ë‹¤ì‹œ í•©`);
      continue;
    }
    if(aRoll.total > bRoll.total){
      playMatchSfx(MATCH_SFX.clashBreak, 0.6);
      bDestroyed += 1;
      bRemain -= 1;
      appendMatchLog(`> ${labelA} ìŠ¹ë¦¬ / ${labelB} ì½”ì¸ 1ê°œ íŒŒê´´`);
      if(bRemain <= 0){
        return { winner:'A', aRemain, bRemain:0, aDestroyed, bDestroyed };
      }
    }else{
      playMatchSfx(MATCH_SFX.clashBreak, 0.6);
      aDestroyed += 1;
      aRemain -= 1;
      appendMatchLog(`> ${labelB} ìŠ¹ë¦¬ / ${labelA} ì½”ì¸ 1ê°œ íŒŒê´´`);
      if(aRemain <= 0){
        return { winner:'B', aRemain:0, bRemain, aDestroyed, bDestroyed };
      }
    }
  }
  return { winner:'DRAW', aRemain, bRemain, aDestroyed, bDestroyed, aLastTotal, bLastTotal };
}


function applyDamageToUnit(unit, amount, sourceSkill, attackerLabel, attackerUnit, opts={}){
  if(!unit) return 0;
  const resistMult = getResistMultiplier(unit, sourceSkill?.atkType);
  const levelMult = getDamageLevelMultiplier(sourceSkill, attackerUnit, unit);
  const critMult = Number(opts?.critMult || 1) || 1;
  const dealtMult = getDamageDealtMultiplier(attackerUnit);
  const takenMult = getDamageTakenMultiplier(unit);

  let dmg = Math.round((Number(amount)||0) * resistMult * levelMult * critMult * dealtMult * takenMult);
  if(Number(amount||0) > 0) dmg = Math.max(1, dmg);
  else dmg = Math.max(0, dmg);

  // ë³´í˜¸ë§‰(ì„ì‹œì²´ë ¥): í”¼í•´ë¥¼ ë¨¼ì € í¡ìˆ˜í•˜ê³ , ë‚¨ì€ í”¼í•´ë§Œ HPì— ì ìš©
  unit.core.status = unit.core.status || {};
  unit.shield = Number(unit.shield||0) || 0;
  let absorbed = 0;
  if(unit.shield > 0 && dmg > 0){
    absorbed = Math.min(unit.shield, dmg);
    unit.shield = Math.max(0, unit.shield - absorbed);
    dmg = Math.max(0, dmg - absorbed);
    unit.core.status.shield = unit.shield;
  }

  unit.currentHp = Math.max(0, Number(unit.currentHp||0) - dmg);
  unit.core.status.hp = unit.currentHp;

  const critTxt = critMult > 1 ? ` / ì¹˜ëª…íƒ€ x${critMult.toFixed(2)}` : '';
  const shieldTxt = absorbed > 0 ? ` / ë³´í˜¸ë§‰ í¡ìˆ˜ ${absorbed}` : '';
  appendMatchLog(`- ${attackerLabel} ê³µê²© ì ì¤‘: í”¼í•´ ${dmg}${shieldTxt} (ë‚´ì„± x${resistMult.toFixed(2)} / ê³µë ™ë³´ì • x${levelMult.toFixed(2)} / í”¼í•´ë³´ì • x${dealtMult.toFixed(2)} / ë³´í˜¸Â·ì·¨ì•½ x${takenMult.toFixed(2)}${critTxt})`);
  checkAndApplyStagger(unit);
  return dmg;
}

function attackAfterClash(attackerSkill, remainCoins, destroyedCoins, attackerUnit, defenderUnit, attackerLabel){
  if(!attackerSkill || !attackerUnit || !defenderUnit) return 0;
  // í•©ê°€ëŠ¥ ìˆ˜ë¹„ëŠ” ê³µê²©í•˜ì§€ ì•ŠëŠ”ë‹¤
  if(getDefenseMode(attackerSkill) === 'clashGuard') return 0;
  const unbreak = isUnbreakableCoinSkill(attackerSkill);
  const count = unbreak ? getSkillCoinCount(attackerSkill) : Math.max(1, Number(remainCoins||1));
  const bonus = unbreak ? Number(destroyedCoins||0) : 0;
  let running = (Number(attackerSkill?.power || 0) || 0) + getSkillPowerBonus(attackerSkill, attackerUnit, "attack");
  // í•©ê°€ëŠ¥ ìˆ˜ë¹„ íŒ¨ë°°ë¡œ ì¸í•œ 'ê³µê²© ì „ ìœ„ë ¥ ê°ì†Œ' ì ìš©(ê³µê²© ì‹œì‘ ì „ì—)
  // âœ… í•©ê°€ëŠ¥ ìˆ˜ë¹„ íŒ¨ë°°ë¡œ ì¸í•œ 'ê³µê²© ì „ ìœ„ë ¥ ê°ì†Œ'ëŠ” ê³µê²© ì‹œì‘ ì „ì— ì¦‰ì‹œ ë°˜ì˜
  if(prePowerReduce && Number(prePowerReduce) > 0){
    const __pr = Math.max(0, Number(prePowerReduce)||0);
    const __before = running;
    running = Math.max(0, running - __pr);
    appendMatchLog(`[í•©ê°€ëŠ¥ ìˆ˜ë¹„] ìƒëŒ€ ìœ„ë ¥ ê°ì†Œ ì ìš©: ${__before} â†’ ${running} (-${__pr})`, {cls:'guard'}, {cls:'guard'});
  }
  let total = 0;
  // ë°œë™ ì‹œ ìŒì„±: ì‹¤ì œ ê³µê²© ì§ì „ 1íšŒë§Œ
  playSkillActivationAudio(attackerSkill);
  for(let i=0;i<count;i++){
    applyBleedOnSkillUse(attackerUnit, attackerSkill, getUnitLabel(attackerUnit?.side));
    // ì½”ì¸ë³„ ìŒì„±: í•´ë‹¹ ì½”ì¸ ê³µê²© ì§ì „ì—ë§Œ 1íšŒ
    playSkillCoinAudio(attackerSkill, i+1);
    const f = flipCoinForSkill(attackerSkill, attackerUnit, bonus, "attack", i+1);
    if(f.head) running += f.value;
    const crit = getBreathCritResult(attackerUnit);
    const dmg = applyDamageToUnit(defenderUnit, running, attackerSkill, `${attackerLabel} ${i+1}íƒ€`, attackerUnit, {critMult: crit.mult});
    applyOnHitDefenderStatuses(defenderUnit, `${attackerLabel} ${i+1}íƒ€`);
    applyAutoRulesOnHit(attackerSkill, attackerUnit, defenderUnit, i+1);
    total += dmg;
    if(crit.crit){ appendMatchLogIcon("crit", `- ${attackerLabel} CRIT!`, {cls:"crit"}); }
  }
  appendMatchLog(`[ê³µê²© ì¢…ë£Œ] ${attackerLabel} ì´ í”¼í•´ ${total}`);
  return total;
}

function resolveSelectedSlotBattle(){
  if(!MATCH_STATE) return false;
  const myUnit = MATCH_STATE.my;
  const enUnit = MATCH_STATE.enemy;

  const myPicked = getSelectedSkillForUnit(myUnit);
  const enPicked = getSelectedSkillForUnit(enUnit);
  // __PURE_DEFENSE_GUARD__
  // ê¸°ì¡´ ë°ì´í„° í˜¸í™˜(atkType) í¬í•¨í•œ ìˆœìˆ˜ë°©ì–´ íŒì •
  myUnit.activeDefense = (myPicked && isPureDefenseSkill(myPicked)) ? { mode:getDefenseMode(myPicked), skill:myPicked, broken:false } : null;
  enUnit.activeDefense = (enPicked && isPureDefenseSkill(enPicked)) ? { mode:getDefenseMode(enPicked), skill:enPicked, broken:false } : null;
  const __mySkillOld = myUnit.activeDefense ? null : myPicked;
  const __enSkillOld = enUnit.activeDefense ? null : enPicked;


  // ìˆœìˆ˜ë°©ì–´(íšŒí”¼/ìˆ˜ë¹„/ë°˜ê²©)ëŠ” ê³µê²©/í•©ì— ì°¸ì—¬í•˜ì§€ ì•Šê³  ë°©ì–´ ìƒíƒœë¡œ ì „í™˜
  myUnit.activeDefense = (myPicked && isPureDefenseSkill(myPicked)) ? { mode:getDefenseMode(myPicked), skill:myPicked, broken:false } : null;
  enUnit.activeDefense = (enPicked && isPureDefenseSkill(enPicked)) ? { mode:getDefenseMode(enPicked), skill:enPicked, broken:false } : null;

  const mySkill = myUnit.activeDefense ? null : myPicked;
  const enSkill = enUnit.activeDefense ? null : enPicked;
if(!mySkill && !enSkill){
    toast(matchToast, 'ë¨¼ì € ì†ë„/ìŠ¤í‚¬ ë½‘ê¸°ë¥¼ í•´ì¤˜.');
    return false;
  }

  playMatchSfx(MATCH_SFX.battleStart, 0.6);
  appendMatchLog(`=== í„´ ${MATCH_STATE.turn} ì „íˆ¬ ì‹¤í–‰ ===`);

  const myLabel = `ë‚´ íŒ€ ${getSkillName(mySkill||{})}`;
  const enLabel = `ì  ${getSkillName(enSkill||{})}`;

  if(myUnit.activeDefense && enUnit.activeDefense){
    appendMatchLog(`[ìˆœìˆ˜ë°©ì–´] ì–‘ì¸¡ ëª¨ë‘ ë°©ì–´ ìì„¸`);
    renderMatchScreen();
    return true;
  }

  if(mySkill && enSkill){
    const clash = performClash(mySkill, enSkill, myLabel, enLabel);
    if(clash.winner === 'A'){
      adjustSanityAfterClashResult(myUnit, enUnit);
      try{ applyAutoRulesOnClashResult(mySkill, myUnit, enUnit, 'win'); }catch(_e){}
      try{ applyAutoRulesOnClashResult(enSkill, enUnit, myUnit, 'lose'); }catch(_e){}
      attackAfterClash(mySkill, clash.aRemain, clash.aDestroyed, myUnit, enUnit, myLabel);
      if(isUnbreakableCoinSkill(enSkill)){
        attackAfterClash(enSkill, getSkillCoinCount(enSkill), clash.bDestroyed, enUnit, myUnit, enLabel);
      }
    }else if(clash.winner === 'B'){
      adjustSanityAfterClashResult(enUnit, myUnit);
      try{ applyAutoRulesOnClashResult(enSkill, enUnit, myUnit, 'win'); }catch(_e){}
      try{ applyAutoRulesOnClashResult(mySkill, myUnit, enUnit, 'lose'); }catch(_e){}
      attackAfterClash(enSkill, clash.bRemain, clash.bDestroyed, enUnit, myUnit, enLabel);
      if(isUnbreakableCoinSkill(mySkill)){
        attackAfterClash(mySkill, getSkillCoinCount(mySkill), clash.aDestroyed, myUnit, enUnit, myLabel);
      }
    }else{
      appendMatchLog('= í•© ì¢…ë£Œ íŒì • ì—†ìŒ');
    }
  }else if(mySkill){
    appendMatchLog(`[ì¼ë°©ê³µê²©] ${myLabel}`);
    attackAfterClash(mySkill, getSkillCoinCount(mySkill), 0, myUnit, enUnit, myLabel);
    // âœ… ë°˜ê²©(ìˆœìˆ˜ë°©ì–´): ìƒëŒ€ ê³µê²© í›„ 1íšŒ ê³µê²©
    if(enUnit.activeDefense) tryDoCounter(enUnit, myUnit);
  }else if(enSkill){
    appendMatchLog(`[ì¼ë°©ê³µê²©] ${enLabel}`);
    attackAfterClash(enSkill, getSkillCoinCount(enSkill), 0, enUnit, myUnit, enLabel);
    // âœ… ë°˜ê²©(ìˆœìˆ˜ë°©ì–´): ìƒëŒ€ ê³µê²© í›„ 1íšŒ ê³µê²©
    if(myUnit.activeDefense) tryDoCounter(myUnit, enUnit);
  }

  renderMatchScreen();
  return true;
}


function waitMs(ms){ return new Promise(r => setTimeout(r, ms)); }

function setCineTag(text, cls){
  if(!EL_CINE.tag) return;
  EL_CINE.tag.textContent = text;
  EL_CINE.tag.className = `matchCineTag ${cls||''}`.trim();
}

function renderCineCoins(el, icons, brokenFrom=999){
  if(!el) return;
  el.innerHTML = '';
  (icons || []).forEach((src, idx) => {
    const coin = document.createElement('div');
    coin.className = 'matchCineCoin' + (idx >= brokenFrom ? ' broken' : '');
    const img = document.createElement('img');
    img.src = src || coinBackIconPath('normal');
    img.alt = 'coin';
    coin.appendChild(img);
    el.appendChild(coin);
  });
}

function buildBackIcons(skill, remain){
  const count = Math.max(1, Number(remain||1));
  return Array.from({length:count}, ()=> coinBackIconPath(skill?.coinType || 'normal'));
}


function formatCineMetaHTML(skill, unit, phase="clash", remainCoins=null){
  const base = Number(skill?.power||0)||0;
  const coin = Number(skill?.coinPower ?? skill?.coin ?? 0)||0;
  const coinCnt = (remainCoins != null) ? Math.max(0, Number(remainCoins)||0) : getSkillCoinCount(skill);
  const atkLv = getSkillAtkLevel(skill, unit);
  const baseB = (unit && skill) ? (Number(getSkillPowerBonus(skill, unit, phase))||0) : 0;
  const coinB = (unit && skill) ? (Number(getCoinPowerStatusBonus(skill, unit))||0) : 0;

  const baseBoostTxt = baseB ? ` <span class="miniChip">+${baseB}</span>` : '';
  const coinBoostTxt = coinB ? ` <span class="miniChip">+${coinB}</span>` : '';
  return `
    <span class="metaTag"><span class="metaKey">ê¸°ë³¸ìœ„ë ¥</span> <b>${base}</b>${baseBoostTxt}</span>
    <span class="metaSep">Â·</span>
    <span class="metaTag"><span class="metaKey">ì½”ì¸ìœ„ë ¥</span> <b>${coin}</b>${coinBoostTxt}</span>
    <span class="metaSep">Â·</span>
    <span class="metaTag"><span class="metaKey">${remainCoins!=null?'ë‚¨ì€ ì½”ì¸':'ì½”ì¸ìˆ˜'}</span> <b>${coinCnt}</b></span>
    <span class="metaSep">Â·</span>
    <span class="metaTag"><span class="metaKey">ê³µë ™</span> <b>${atkLv}</b></span>
  `.trim();
}

function setupClashCinematic(skillA, skillB, labelA, labelB){
  EL_CINE.myName.textContent = 'ë‚´ íŒ€';
  EL_CINE.enemyName.textContent = 'ì ';
  EL_CINE.mySkill.textContent = getSkillName(skillA || {});
  EL_CINE.enemySkill.textContent = getSkillName(skillB || {});
  EL_CINE.myMeta.innerHTML = formatCineMetaHTML(skillA||{}, MATCH_STATE?.my, 'clash');
  EL_CINE.enemyMeta.innerHTML = formatCineMetaHTML(skillB||{}, MATCH_STATE?.enemy, 'clash');
  EL_CINE.sub.textContent = `${labelA} â†” ${labelB}`;
  EL_CINE.round.textContent = 'ROUND 1';
  EL_CINE.score.textContent = '-';
  EL_CINE.result.textContent = 'ì–‘ì¸¡ì´ í•©ì„ ì¤€ë¹„ ì¤‘...';
  EL_CINE.attack.innerHTML = '';
  setCineTag('í•© ì§„í–‰', '');
  renderCineCoins(EL_CINE.myCoins, buildBackIcons(skillA, getSkillCoinCount(skillA)));
  renderCineCoins(EL_CINE.enemyCoins, buildBackIcons(skillB, getSkillCoinCount(skillB)));
}

function setupAttackCinematic(skill, attackerLabel, defenderLabel, remainCoins){
  EL_CINE.sub.textContent = `${attackerLabel} â†’ ${defenderLabel}`;
  EL_CINE.round.textContent = 'ê³µê²©';
  EL_CINE.score.textContent = '-';
  EL_CINE.result.textContent = 'ë‚¨ì€ ì½”ì¸ìœ¼ë¡œ ê³µê²© ì¤€ë¹„';
  EL_CINE.attack.innerHTML = `<span class="matchCineTag win">ê³µê²©</span><span>${attackerLabel}</span>`;
  if(attackerLabel.includes('ë‚´ íŒ€')){
    EL_CINE.mySkill.textContent = getSkillName(skill || {});
    const __u = attackerLabel.includes('ë‚´ íŒ€') ? MATCH_STATE?.my : MATCH_STATE?.enemy;
    EL_CINE.myMeta.innerHTML = formatCineMetaHTML(skill||{}, __u, 'attack', remainCoins);
    renderCineCoins(EL_CINE.myCoins, buildBackIcons(skill, remainCoins));
  }else{
    EL_CINE.enemySkill.textContent = getSkillName(skill || {});
    const __u = attackerLabel.includes('ë‚´ íŒ€') ? MATCH_STATE?.my : MATCH_STATE?.enemy;
    EL_CINE.enemyMeta.innerHTML = formatCineMetaHTML(skill||{}, __u, 'attack', remainCoins);
    renderCineCoins(EL_CINE.enemyCoins, buildBackIcons(skill, remainCoins));
  }
}

async function animateRollOnSide(side, skill, unit, remainCoins, bonusCoinPower=0, clashBonus=0){
  applyBleedOnSkillUse(unit, skill, getUnitLabel(unit?.side));
  const container = side === 'A' ? EL_CINE.myCoins : EL_CINE.enemyCoins;
  const count = Math.max(1, Number(remainCoins||1));
  const base = (Number(skill?.power || 0) || 0) + getSkillPowerBonus(skill, unit, "clash");
  const sign = String(skill?.coinSign || '+') === '-' ? -1 : 1;
  let total = base + (Number(clashBonus||0) || 0);
  const flips = [];
  const icons = buildBackIcons(skill, count);
  renderCineCoins(container, icons);
  const refreshScore = ()=>{
    if(side === 'A') EL_CINE.myCoins.dataset.total = String(total);
    else EL_CINE.enemyCoins.dataset.total = String(total);
    const nowA = Number(EL_CINE.myCoins?.dataset.total || 0);
    const nowB = Number(EL_CINE.enemyCoins?.dataset.total || 0);
    EL_CINE.score.textContent = `${nowA} : ${nowB}`;
  };
  if(side === 'A') EL_CINE.myCoins.dataset.total = String(total);
  else EL_CINE.enemyCoins.dataset.total = String(total);
  refreshScore();

  for(let i=0;i<count;i++){
    await waitMs(110);
    const f = flipCoinForSkill(skill, unit, bonusCoinPower, "clash");
    const head = f.head;
    icons[i] = f.icon;
    renderCineCoins(container, icons);
    const coinEl = container.children[i];
    if(coinEl){
      coinEl.classList.add('flip');
      setTimeout(()=> coinEl.classList.remove('flip'), 90);
    }
    if(head) total += f.value;
    flips.push(head ? 'ì•' : 'ë’¤');
    if(side === 'A') EL_CINE.myCoins.dataset.total = String(total);
    else EL_CINE.enemyCoins.dataset.total = String(total);
    refreshScore();
  }
  return { total, flips, icons, base, remainingCoins: count, clashBonus:(Number(clashBonus||0)||0) };
}


async function performClashCinematic(skillA, skillB, unitA, unitB, labelA, labelB){
  let aRemain = getSkillCoinCount(skillA);
  let bRemain = getSkillCoinCount(skillB);
  let aDestroyed = 0;
  let bDestroyed = 0;
  const aIsClashGuard = (getDefenseMode(skillA) === "clashGuard");
  const bIsClashGuard = (getDefenseMode(skillB) === "clashGuard");
  let safety = 0;
  setupClashCinematic(skillA, skillB, labelA, labelB);
  appendMatchLog(`[í•©] ${labelA} â†” ${labelB}`);

  while(safety++ < 60){
    const aClashBonus = getClashAtkLevelBonus(skillA, skillB, unitA, unitB);
    const bClashBonus = getClashAtkLevelBonus(skillB, skillA, unitB, unitA);
    EL_CINE.round.textContent = `ROUND ${safety}`;
    EL_CINE.result.textContent = 'ì–‘ì¸¡ ì½”ì¸ì„ ëª¨ë‘ êµ´ë¦¬ëŠ” ì¤‘...';

    // í•© ì—°ì¶œ ë©”íƒ€: ê¸°ë³¸ìœ„ë ¥/ì½”ì¸ìœ„ë ¥/ë‚¨ì€ ì½”ì¸/ê³µë ™ (ë¼ë²¨ ì¤‘ë³µ ë°©ì§€)
    EL_CINE.myMeta.innerHTML = formatCineMetaHTML(skillA||{}, unitA, 'clash', aRemain);
    EL_CINE.enemyMeta.innerHTML = formatCineMetaHTML(skillB||{}, unitB, 'clash', bRemain);
    EL_CINE.myCoins.dataset.total = String((Number(skillA?.power||0)||0) + aClashBonus);
    EL_CINE.enemyCoins.dataset.total = String((Number(skillB?.power||0)||0) + bClashBonus);
    renderCineCoins(EL_CINE.myCoins, buildBackIcons(skillA, aRemain));
    renderCineCoins(EL_CINE.enemyCoins, buildBackIcons(skillB, bRemain));
    EL_CINE.score.textContent = `${EL_CINE.myCoins.dataset.total} : ${EL_CINE.enemyCoins.dataset.total}`;
    await waitMs(120);

    const aPromise = animateRollOnSide('A', skillA, unitA, aRemain, 0, aClashBonus);
    const bPromise = animateRollOnSide('B', skillB, unitB, bRemain, 0, bClashBonus);
    const [aRoll, bRoll] = await Promise.all([aPromise, bPromise]);

    aLastTotal = aRoll.total;
    bLastTotal = bRoll.total;

    EL_CINE.score.textContent = `${aRoll.total} : ${bRoll.total}`;
    appendMatchLog(`- ${labelA}: ${aRoll.total} (${aRoll.flips.join('/')})${aClashBonus?` / ê³µë ™ë³´ì • +${aClashBonus}`:''}`);
    appendMatchLog(`- ${labelB}: ${bRoll.total} (${bRoll.flips.join('/')})${bClashBonus?` / ê³µë ™ë³´ì • +${bClashBonus}`:''}`);

    if(aRoll.total === bRoll.total){
      playMatchSfx(MATCH_SFX.clashDraw, 0.5);
      EL_CINE.result.textContent = 'ë¬´ìŠ¹ë¶€! ë‹¤ì‹œ í•©';
      setCineTag('ë¬´ìŠ¹ë¶€', 'draw');
      appendMatchLog(`= ë¬´ìŠ¹ë¶€. ë‹¤ì‹œ í•©`);
      await waitMs(360);
      continue;
    }

    if(aRoll.total > bRoll.total){
      playMatchSfx(MATCH_SFX.clashBreak, 0.6);
      if(!bIsClashGuard){
        bDestroyed += 1;
        bRemain -= 1;
        EL_CINE.result.textContent = `${labelA} ìŠ¹ë¦¬! ${labelB} ì½”ì¸ 1ê°œ íŒŒê´´`;
        appendMatchLog(`> ${labelA} ìŠ¹ë¦¬ / ${labelB} ì½”ì¸ 1ê°œ íŒŒê´´`);
        renderCineCoins(EL_CINE.enemyCoins, bRoll.icons, Math.max(0, bRemain));
        await waitMs(380);
      }else{
        // í•©ê°€ëŠ¥ ìˆ˜ë¹„: ì½”ì¸ íŒŒê´´ ë¶ˆê°€ + íŒ¨ë°°í•˜ë©´ ì¦‰ì‹œ ë°©ì–´ ë‹¨ê³„ë¡œ ì „í™˜(ë” ì´ìƒ í•© ì§„í–‰ X)
        EL_CINE.result.textContent = `${labelA} ìŠ¹ë¦¬! (í•©ê°€ëŠ¥ ìˆ˜ë¹„ íŒ¨ë°°: ì¦‰ì‹œ ë°©ì–´ ì „í™˜)`;
        appendMatchLog(`> ${labelA} ìŠ¹ë¦¬ / ${labelB} ì½”ì¸ íŒŒê´´ ë¶ˆê°€(í•©ê°€ëŠ¥ ìˆ˜ë¹„, ì¦‰ì‹œ ë°©ì–´ ì „í™˜)`);
        await waitMs(360);
        return { winner:'A', aRemain, bRemain, aDestroyed, bDestroyed, aLastTotal, bLastTotal, reason:'CLASH_GUARD_LOST' };
      }
      if(bRemain <= 0){
        return { winner:'A', aRemain, bRemain:Math.max(0,bRemain), aDestroyed, bDestroyed, aLastTotal, bLastTotal };
      }
    }else{
      playMatchSfx(MATCH_SFX.clashBreak, 0.6);
      if(!aIsClashGuard){
        aDestroyed += 1;
        aRemain -= 1;
        EL_CINE.result.textContent = `${labelB} ìŠ¹ë¦¬! ${labelA} ì½”ì¸ 1ê°œ íŒŒê´´`;
        appendMatchLog(`> ${labelB} ìŠ¹ë¦¬ / ${labelA} ì½”ì¸ 1ê°œ íŒŒê´´`);
        renderCineCoins(EL_CINE.myCoins, aRoll.icons, Math.max(0, aRemain));
        await waitMs(380);
      }else{
        // í•©ê°€ëŠ¥ ìˆ˜ë¹„: ì½”ì¸ íŒŒê´´ ë¶ˆê°€ + íŒ¨ë°°í•˜ë©´ ì¦‰ì‹œ ë°©ì–´ ë‹¨ê³„ë¡œ ì „í™˜(ë” ì´ìƒ í•© ì§„í–‰ X)
        EL_CINE.result.textContent = `${labelB} ìŠ¹ë¦¬! (í•©ê°€ëŠ¥ ìˆ˜ë¹„ íŒ¨ë°°: ì¦‰ì‹œ ë°©ì–´ ì „í™˜)`;
        appendMatchLog(`> ${labelB} ìŠ¹ë¦¬ / ${labelA} ì½”ì¸ íŒŒê´´ ë¶ˆê°€(í•©ê°€ëŠ¥ ìˆ˜ë¹„, ì¦‰ì‹œ ë°©ì–´ ì „í™˜)`);
        await waitMs(360);
        return { winner:'B', aRemain, bRemain, aDestroyed, bDestroyed, aLastTotal, bLastTotal, reason:'CLASH_GUARD_LOST' };
      }
      if(aRemain <= 0){
        return { winner:'B', aRemain:Math.max(0,aRemain), bRemain, aDestroyed, bDestroyed, aLastTotal, bLastTotal };
      }
    }
  }
    // safety ìƒí•œ ë„ë‹¬: ë§ˆì§€ë§‰ í•© ìˆ˜ì¹˜ë¡œ ìŠ¹íŒ¨ ê²°ì •(ë¬´í•œí•© ë°©ì§€)
  if(aLastTotal && bLastTotal && aLastTotal !== bLastTotal){
    return { winner:(aLastTotal > bLastTotal ? 'A' : 'B'), aRemain, bRemain, aDestroyed, bDestroyed, aLastTotal, bLastTotal, reason:'SAFETY' };
  }
  return { winner:'DRAW', aRemain, bRemain, aDestroyed, bDestroyed, aLastTotal, bLastTotal, reason:'SAFETY' };
}



async function attackAfterClashCinematic(attackerSkill, remainCoins, destroyedCoins, attackerUnit, defenderUnit, attackerLabel, prePowerReduce=0){
  if(attackerUnit && isUnitStaggerLocked(attackerUnit)){ appendMatchLog?.(`[í–‰ë™ ë¶ˆê°€] ííŠ¸ëŸ¬ì§ ìƒíƒœë¼ ê³µê²©í•  ìˆ˜ ì—†ìŒ`); return 0; }

  if(!attackerSkill || !attackerUnit || !defenderUnit) return 0;
  const defenderLabel = attackerLabel.includes('ë‚´ íŒ€') ? 'ì ' : 'ë‚´ íŒ€';
  const side = attackerLabel.includes('ë‚´ íŒ€') ? 'A' : 'B';
  const evSide = side === "A" ? "B" : "A";
  // ìë™ê·œì¹™(use): ê³µê²© ìŠ¤í‚¬ ì‚¬ìš© ì‹œì  1íšŒ(ëŒ€ìƒ ì°¸ì¡° ê°€ëŠ¥)
  {
    const __prevAR = __AUTO_RULE_TARGET_UNIT;
    __AUTO_RULE_TARGET_UNIT = defenderUnit;
    applyAutoRulesOnUse(attackerSkill, attackerUnit, defenderUnit);
    __AUTO_RULE_TARGET_UNIT = __prevAR;
  }
  
  // ìˆœìˆ˜ë°©ì–´: íšŒí”¼(í•© íŒì • ì•„ë‹˜) - ê³µê²© ì½”ì¸ë§ˆë‹¤ íšŒí”¼ ì½”ì¸ìœ¼ë¡œ ë¹„êµ
  const evState = defenderUnit?.activeDefense;
  const evSkill = (evState && evState.mode === "evade") ? evState.skill : null;
  // ìë™ê·œì¹™(use): ë°©ì–´ ìŠ¤í‚¬ë„ "ì‚¬ìš©ì‹œ"ì— ë°œë™(ê³µê²©ì=ëŒ€ìƒ)
  if(evState && evState.skill) applyAutoRulesOnUse(evState.skill, defenderUnit, attackerUnit);
  const evCoinCount = evSkill ? 1 : 0; // íšŒí”¼ëŠ” í•­ìƒ 1ì½”ì¸(ë§¤ íƒ€ê²©ë§ˆë‹¤ ìƒˆë¡œ êµ´ë¦¼)
  const evBase = evSkill ? ((Number(evSkill?.power||0)||0) + getSkillPowerBonus(evSkill, defenderUnit, "defense")) : 0;
  let __evadeSuccessVoicePlayed = false;
  let __evadeFailVoicePlayed = false;
  // ìˆœìˆ˜ë°©ì–´: ìˆ˜ë¹„(ë³´í˜¸ë§‰) - ê³µê²© í˜ì´ì¦ˆì— 1íšŒ êµ´ë ¤ì„œ ì´ë²ˆ í„´ ë™ì•ˆ ì„ì‹œì²´ë ¥(ë³´í˜¸ë§‰) íšë“
  const gdState = defenderUnit?.activeDefense;
  const gdSkill = (gdState && gdState.mode === "guard") ? gdState.skill : null;
  const gdBase = gdSkill ? ((Number(gdSkill?.power||0)||0) + getSkillPowerBonus(gdSkill, defenderUnit, "defense")) : 0;
  // í•œ í„´/í•œ ê³µê²© í˜ì´ì¦ˆì—ì„œ ì—¬ëŸ¬ ë²ˆ ë§ì•„ë„ ìˆ˜ë¹„ëŠ” 1íšŒë§Œ ë°œë™
  let __guardRolledThisAttack = false;

const unbreak = isUnbreakableCoinSkill(attackerSkill);
  const coinCount = unbreak ? getSkillCoinCount(attackerSkill) : Math.max(1, Number(remainCoins||1));
  const bonus = unbreak ? Number(destroyedCoins||0) : 0;
  setupAttackCinematic(attackerSkill, attackerLabel, defenderLabel, coinCount);

  // âœ… ìˆ˜ë¹„(ë³´í˜¸ë§‰) ë°œë™: ê³µê²© ì‹œì‘ ì‹œ 1íšŒë§Œ êµ´ë¦°ë‹¤(íšŒí”¼ì²˜ëŸ¼ ì ì´ ë•Œë¦¬ëŠ” í˜ì´ì¦ˆ)
  if(gdSkill && !__guardRolledThisAttack){
    const gf = flipCoinForSkill(gdSkill, defenderUnit, 0, "defense", 1);
    const gdVal = gdBase + (gf.head ? gf.value : 0);

    // ì‹œë„¤ë§ˆí‹±(íšŒí”¼ì²˜ëŸ¼): ìˆ˜ë¹„ ìŠ¤í‚¬ëª…/ë©”íƒ€/ì½”ì¸ 1ê°œ í‘œì‹œ
    const gdTgt = (side === "A")
      ? { skill: EL_CINE.enemySkill, meta: EL_CINE.enemyMeta, coins: EL_CINE.enemyCoins }
      : { skill: EL_CINE.mySkill, meta: EL_CINE.myMeta, coins: EL_CINE.myCoins };

    if(gdTgt.skill) gdTgt.skill.textContent = getSkillName(gdSkill);
    if(gdTgt.meta) gdTgt.meta.textContent = `ê¸°ë³¸ê°’ ${gdBase} / ì½”ì¸ 1 / ë°©ë ™ ${getUnitDefLevel(defenderUnit)}`;

    const gdIcons = buildBackIcons(gdSkill, 1);
    if(gdIcons && gdTgt.coins){
      renderCineCoins(gdTgt.coins, gdIcons);
      gdIcons[0] = gf.icon;
      renderCineCoins(gdTgt.coins, gdIcons);
      const gdEl = gdTgt.coins.children[0];
      if(gdEl){
        gdEl.classList.add('flip');
        setTimeout(()=> gdEl.classList.remove('flip'), 110);
      }
    }

    defenderUnit.shield = (Number(defenderUnit.shield||0)||0) + gdVal;
    defenderUnit.core.status = defenderUnit.core.status || {};
    defenderUnit.core.status.shield = defenderUnit.shield;

    appendMatchLog(`[ìˆ˜ë¹„] ${getSkillName(gdSkill)}: ${gdVal} (${gf.head?'ì•':'ë’¤'}) â†’ ë³´í˜¸ë§‰ +${gdVal} (í˜„ì¬ ë³´í˜¸ë§‰ ${defenderUnit.shield})`, {cls:'guard'}, {cls:'guard'});
    __guardRolledThisAttack = true;
    renderMatchScreen();
    await waitMs(140);
  }


  const evContainer = evSide === "A" ? EL_CINE.myCoins : EL_CINE.enemyCoins;
  const evIcons = evSkill ? buildBackIcons(evSkill, 1) : null;
  if(evIcons) renderCineCoins(evContainer, evIcons);

  
  // __EV_CINE_LABEL_FIX__
  // íšŒí”¼ê°€ í™œì„±í™”ëœ ê²½ìš°: "ìºë¦­í„°ëª…"ì€ ìœ ì§€í•˜ê³ , ìŠ¤í‚¬ëª…/ë©”íƒ€ë§Œ íšŒí”¼ ìŠ¤í‚¬ë¡œ í‘œì‹œ
  if(evSkill && evState && evState.mode === "evade"){
    const tgt = (evSide === "A")
      ? { skill: EL_CINE.mySkill, meta: EL_CINE.myMeta, coins: EL_CINE.myCoins }
      : { skill: EL_CINE.enemySkill, meta: EL_CINE.enemyMeta, coins: EL_CINE.enemyCoins };

    if(tgt.skill) tgt.skill.textContent = getSkillName(evSkill);
    if(tgt.meta) tgt.meta.textContent = `ê¸°ë³¸ê°’ ${evBase} / ì½”ì¸ 1 / ë°©ë ™ ${getUnitDefLevel(defenderUnit)}`;
    // ì½”ì¸ ì•„ì´ì½˜ì€ íšŒí”¼ 1ê°œê°€ ê³„ì† ë’¤ì§‘íˆë¯€ë¡œ ì´ë¯¸ evIconsë¡œ ë Œë”ë¨
  }
const container = side === 'A' ? EL_CINE.myCoins : EL_CINE.enemyCoins;
  let running = (Number(attackerSkill?.power || 0) || 0) + getSkillPowerBonus(attackerSkill, attackerUnit, "attack");
  let totalDmg = 0;
  const icons = buildBackIcons(attackerSkill, coinCount);
  renderCineCoins(container, icons);
  EL_CINE.score.textContent = String(running);
  EL_CINE.result.textContent = `ì½”ì¸ë³„ ê³µê²© ì§„í–‰...`;

  // ë°œë™ ì‹œ ìŒì„±: ì‹¤ì œ ê³µê²© ì§ì „ 1íšŒë§Œ
  await playSkillActivationAudio(attackerSkill);
  await waitMs(90);

  for(let i=0;i<coinCount;i++){
    // íšŒí”¼ê°€ í™œì„±ì´ê³  ì•„ì§ ê¹¨ì§€ì§€ ì•Šì•˜ìœ¼ë©´, ì´ë²ˆ ì½”ì¸ì— ëŒ€í•´ íšŒí”¼ íŒì •(ì½”ì¸ êµ´ë¦¼)
    let evSuccessThisHit = false;

    applyBleedOnSkillUse(attackerUnit, attackerSkill, getUnitLabel(attackerUnit?.side));
    await playSkillCoinAudio(attackerSkill, i+1);
    await waitMs(70);
    const f = flipCoinForSkill(attackerSkill, attackerUnit, bonus, "attack", i+1);
    icons[i] = f.icon;
    renderCineCoins(container, icons);
    const coinEl = container.children[i];
    if(coinEl){
      coinEl.classList.add('flip');
      setTimeout(()=> coinEl.classList.remove('flip'), 110);
    }
    if(f.head) running += f.value;
    EL_CINE.score.textContent = String(running);

    
    // íšŒí”¼ íŒì •(ìˆœìˆ˜ë°©ì–´): ë§¤ íƒ€ê²©ë§ˆë‹¤ ë…ë¦½ì ìœ¼ë¡œ ì½”ì¸ 1ê°œë¥¼ "ìƒˆë¡œ" êµ´ë ¤ ë¹„êµ (í•© íŒì • ì•„ë‹˜)
    if(evSkill && evState && !evState.broken){
      const atkVal = running; // ì´ë²ˆ íƒ€ê²©ì˜ ê³µê²© ê°’(ê³µê²© ìŠ¤í‚¬ì€ ëˆ„ì )
      // íšŒí”¼ëŠ” ë§¤ íƒ€ê²©ë§ˆë‹¤ base(+ì½”ì¸)ë§Œ ê³„ì‚°(ëˆ„ì  ì•ˆ í•¨)
      const evFlip = flipCoinForSkill(evSkill, defenderUnit, 0, "defense", 1);
      const evVal = evBase + (evFlip.head ? evFlip.value : 0);

      // íšŒí”¼ ì½”ì¸ ì—°ì¶œ(í•­ìƒ 1ê°œ)
      if(evIcons){
        evIcons[0] = evFlip.icon;
        renderCineCoins(evContainer, evIcons);
        const evEl = evContainer.children[0];
        if(evEl){
          evEl.classList.add('flip');
          setTimeout(()=> evEl.classList.remove('flip'), 110);
        }
      }

      appendMatchLog(`[íšŒí”¼] ${getSkillName(evSkill)}: ${evVal} (${evFlip.head?'ì•':'ë’¤'}) vs ê³µê²© ${atkVal}`, {cls:'evade'}, {cls:'evade'});
      if(EL_CINE.score) EL_CINE.score.textContent = `${atkVal} VS ${evVal}`;

      if(evVal >= atkVal){
        evSuccessThisHit = true;
        // âœ… íšŒí”¼ ì„±ê³µ ìŒì„±(=ìŠ¬ë¡¯1) 1íšŒë§Œ ì¬ìƒ
        if(!__evadeSuccessVoicePlayed){
          const __sp = pickEvadeVoiceSpec(evSkill, 'success');
          await playSkillAudioSpec(__sp.path, __sp.key, 0.78);
          __evadeSuccessVoicePlayed = true;
        }
EL_CINE.attack.innerHTML = `<span class="matchCineTag win">${i+1}íƒ€</span><span style="color:#cfe9ff;font-weight:1000;">EVADE ${evVal} â‰¥ ${atkVal}</span>`;
        await waitMs(140);
      }else{
        // ì‹¤íŒ¨í•˜ë©´ ì¦‰ì‹œ ì†Œë©¸(ì´ íƒ€ê²©ì€ ì •ìƒì ìœ¼ë¡œ ë§ìŒ)
        evState.broken = true;
        // âœ… íšŒí”¼ ì‹¤íŒ¨ ìŒì„±(=ìŠ¬ë¡¯2) 1íšŒë§Œ ì¬ìƒ
        if(!__evadeFailVoicePlayed){
          const __fp = pickEvadeVoiceSpec(evSkill, 'fail');
          await playSkillAudioSpec(__fp.path, __fp.key, 0.78);
          __evadeFailVoicePlayed = true;
        }
        appendMatchLog(`- íšŒí”¼ ì‹¤íŒ¨! íšŒí”¼ ì†Œë©¸`, {cls:'evade'});
        EL_CINE.attack.innerHTML = `<span class="matchCineTag lose">${i+1}íƒ€</span><span style="color:#ffb5b5;font-weight:1000;">EVADE FAIL ${evVal} < ${atkVal}</span>`;
        await waitMs(140);
      }
    }
    if(evSuccessThisHit){
      continue;
    }

const crit = getBreathCritResult(attackerUnit);
    const dmg = applyDamageToUnit(defenderUnit, running, attackerSkill, `${attackerLabel} ${i+1}íƒ€`, attackerUnit, {critMult: crit.mult});
    applyOnHitDefenderStatuses(defenderUnit, `${attackerLabel} ${i+1}íƒ€`);
    applyAutoRulesOnHit(attackerSkill, attackerUnit, defenderUnit, i+1);
    totalDmg += dmg;
    if(crit.crit){ appendMatchLogIcon("crit", `- ${attackerLabel} CRIT!`, {cls:'crit'}); }
    const critHtml = crit.crit ? `<span style="color:#ffd84d;font-weight:1000;">CRIT!</span>` : '';
    EL_CINE.attack.innerHTML = `<span class="matchCineTag win">${i+1}íƒ€</span><span>${defenderLabel}ì—ê²Œ ${dmg}</span>${critHtml}` + (bonus ? `<span class="matchCineTag">ë³´ì • +${bonus}</span>` : '');
    await waitMs(260);
  }

  EL_CINE.result.textContent = `ì´ í”¼í•´ ${totalDmg}`;
  return totalDmg;
}


function getDefenseMode(skill){
  // âœ… ê¸°ì¡´ ì €ì¥ë°ì´í„° í˜¸í™˜: atkTypeë„ ë°©ì–´ ë¶„ë¥˜ë¡œ ì¸ì •
  const dm = String(skill?.defenseMode || "").trim();
  if(dm) return dm;

  const at = String(skill?.atkType || "").trim();
  if(at === "evade") return "evade";
  if(at === "guard") return "guard";
  if(at === "counter") return "counter";
  if(at === "clashGuard" || at === "clash_guard") return "clashGuard";
  if(at === "clashCounter" || at === "clash_counter") return "clashCounter";

  return "";
}
function isPureDefenseSkill(skill){
  const m = getDefenseMode(skill);
  return m === "evade" || m === "guard" || m === "counter";
}
function isEvadeSkill(skill){
  return getDefenseMode(skill) === "evade";
}
async function resolveSelectedSlotBattleAsync(){
  if(isUnitStaggerLocked(MATCH_STATE?.my) && isUnitStaggerLocked(MATCH_STATE?.enemy)){
    appendMatchLog(`[í–‰ë™ ë¶ˆê°€] ì–‘ì¸¡ ëª¨ë‘ ííŠ¸ëŸ¬ì§ ìƒíƒœ`);
    return;
  }

  if(!MATCH_STATE) return false;
  const myUnit = MATCH_STATE.my;
  const enUnit = MATCH_STATE.enemy;
  const myPicked = getSelectedSkillForUnit(myUnit);
  const enPicked = getSelectedSkillForUnit(enUnit);

  // ìˆœìˆ˜ë°©ì–´(íšŒí”¼/ìˆ˜ë¹„/ë°˜ê²©)ëŠ” ê³µê²©/í•©ì— ì°¸ì—¬í•˜ì§€ ì•Šê³  ë°©ì–´ ìƒíƒœë¡œ ì „í™˜
  myUnit.activeDefense = (myPicked && isPureDefenseSkill(myPicked)) ? { mode: getDefenseMode(myPicked), skill: myPicked, broken:false } : null;
  enUnit.activeDefense = (enPicked && isPureDefenseSkill(enPicked)) ? { mode: getDefenseMode(enPicked), skill: enPicked, broken:false } : null;

  const mySkill = myUnit.activeDefense ? null : myPicked;
  const enSkill = enUnit.activeDefense ? null : enPicked;

  if(!mySkill && !enSkill){
    // ì–‘ìª½ ëª¨ë‘ ìˆœìˆ˜ë°©ì–´ê±°ë‚˜(ë˜ëŠ” ìŠ¤í‚¬ ì—†ìŒ) -> ì „íˆ¬ ì‹¤í–‰í•  ê³µê²©ì´ ì—†ìŒ
    if(myUnit.activeDefense || enUnit.activeDefense){
      toast(matchToast, "ìˆœìˆ˜ë°©ì–´ ìƒíƒœ: ê³µê²©ì´ ì—†ì–´ ì „íˆ¬ê°€ ì§„í–‰ë˜ì§€ ì•Šì•„.");
      appendMatchLog("[ìˆœìˆ˜ë°©ì–´] ì–‘ì¸¡ ê³µê²© ìŠ¤í‚¬ ì—†ìŒ");
      return true;
    }
    toast(matchToast, 'ë¨¼ì € ì†ë„/ìŠ¤í‚¬ ë½‘ê¸°ë¥¼ í•´ì¤˜.');
    return false;
  }
playMatchSfx(MATCH_SFX.battleStart, 0.6);
  appendMatchLog(`=== í„´ ${MATCH_STATE.turn} ì „íˆ¬ ì‹¤í–‰ ===`);

  const myLabel = `ë‚´ íŒ€ ${getSkillName(mySkill||{})}`;
  const enLabel = `ì  ${getSkillName(enSkill||{})}`;

  
  // ìˆœìˆ˜ë°©ì–´ê°€ ìˆëŠ” ìª½ì€ ê³µê²©í•˜ì§€ ì•ŠìŒ. ê³µê²© ìŠ¤í‚¬ì´ ìˆëŠ” ìª½ì´ ì¼ë°©ì ìœ¼ë¡œ ê³µê²©í•˜ë©°,
  // íšŒí”¼ëŠ” ê³µê²© ì½”ì¸ ë£¨í”„ì—ì„œ ë°©ì–´ íŒì •ìœ¼ë¡œ ì²˜ë¦¬ëœë‹¤(í•© íŒì • ì•„ë‹˜).
  if(myUnit.activeDefense && enSkill){
    playMatchSfx(MATCH_SFX.battleStart, 0.6);
    appendMatchLog(`=== í„´ ${MATCH_STATE.turn} ì „íˆ¬ ì‹¤í–‰ ===`);
    const enLabel = `ì  ${getSkillName(enSkill||{})}`;
    await waitMs(120);
    await attackAfterClashCinematic(enSkill, getSkillCoinCount(enSkill), 0, enUnit, myUnit, enLabel);
    // âœ… ë°˜ê²©(ìˆœìˆ˜ë°©ì–´): ìƒëŒ€ ê³µê²© í›„ 1íšŒ ê³µê²©
    await tryDoCounterCinematic(myUnit, enUnit);
    return true;
  }
  if(enUnit.activeDefense && mySkill){
    playMatchSfx(MATCH_SFX.battleStart, 0.6);
    appendMatchLog(`=== í„´ ${MATCH_STATE.turn} ì „íˆ¬ ì‹¤í–‰ ===`);
    const myLabel = `ë‚´ íŒ€ ${getSkillName(mySkill||{})}`;
    await waitMs(120);
    await attackAfterClashCinematic(mySkill, getSkillCoinCount(mySkill), 0, myUnit, enUnit, myLabel);
    // âœ… ë°˜ê²©(ìˆœìˆ˜ë°©ì–´): ìƒëŒ€ ê³µê²© í›„ 1íšŒ ê³µê²©
    await tryDoCounterCinematic(enUnit, myUnit);
    return true;
  }
if(mySkill && enSkill){
    const clash = await performClashCinematic(mySkill, enSkill, myUnit, enUnit, myLabel, enLabel);
    const myIsClashGuard = getDefenseMode(mySkill) === "clashGuard";
    const enIsClashGuard = getDefenseMode(enSkill) === "clashGuard";

    if(clash.winner === 'A'){
      // âœ… í•©ê°€ëŠ¥ ìˆ˜ë¹„ ìŠ¹ë¦¬: ìƒëŒ€ ííŠ¸ëŸ¬ì§ êµ¬ê°„ì„ ë‹¹ê¸´ë‹¤(= staggerPull ì¦ê°€)
      if(myIsClashGuard){
        const pull = Math.max(0, Number(clash.aLastTotal||0));
        enUnit.staggerPull = Math.max(0, Number(enUnit.staggerPull||0) + pull);
        appendMatchLog(`[í•©ê°€ëŠ¥ ìˆ˜ë¹„ ìŠ¹ë¦¬] ${getUnitLabel(enUnit.side)} ííŠ¸ëŸ¬ì§ êµ¬ê°„ +${pull}`, {cls:'guard'}, {cls:'guard'});
      }
      // âœ… í•©ê°€ëŠ¥ ìˆ˜ë¹„ íŒ¨ë°°: ìƒëŒ€ ê³µê²© ì „, íŒŒê´´ëœ ì½”ì¸ ìƒíƒœë¡œ 1íšŒ êµ´ë ¤ ìƒëŒ€ ìœ„ë ¥ ê°ì†Œ
      let preReduce = 0;
      if(enIsClashGuard){
        preReduce = await rollClashGuardMitigation(enSkill, enUnit);
      }

      adjustSanityAfterClashResult(myUnit, enUnit);
      try{ applyAutoRulesOnClashResult(mySkill, myUnit, enUnit, 'win'); }catch(_e){}
      try{ applyAutoRulesOnClashResult(enSkill, enUnit, myUnit, 'lose'); }catch(_e){}
      await waitMs(140);
      if(!myIsClashGuard){
        await attackAfterClashCinematic(mySkill, clash.aRemain, clash.aDestroyed, myUnit, enUnit, myLabel, preReduce);
      }else{
        appendMatchLog(`[í•©ê°€ëŠ¥ ìˆ˜ë¹„] ìŠ¹ë¦¬: ê³µê²©í•˜ì§€ ì•Šê³  ííŠ¸ëŸ¬ì§ êµ¬ê°„ë§Œ ë‹¹ê¹€`, {cls:'guard'}, {cls:'guard'});
      }

      if(isUnbreakableCoinSkill(enSkill) && getDefenseMode(enSkill) !== 'clashGuard'){
        await attackAfterClashCinematic(enSkill, getSkillCoinCount(enSkill), clash.bDestroyed, enUnit, myUnit, enLabel);
      }
    }else if(clash.winner === 'B'){
      if(enIsClashGuard){
        const pull = Math.max(0, Number(clash.bLastTotal||0));
        myUnit.staggerPull = Math.max(0, Number(myUnit.staggerPull||0) + pull);
        appendMatchLog(`[í•©ê°€ëŠ¥ ìˆ˜ë¹„ ìŠ¹ë¦¬] ${getUnitLabel(myUnit.side)} ííŠ¸ëŸ¬ì§ êµ¬ê°„ +${pull}`, {cls:'guard'}, {cls:'guard'});
      }

      let preReduce = 0;
      if(myIsClashGuard){
        preReduce = await rollClashGuardMitigation(mySkill, myUnit);
      }

      adjustSanityAfterClashResult(enUnit, myUnit);
      try{ applyAutoRulesOnClashResult(enSkill, enUnit, myUnit, 'win'); }catch(_e){}
      try{ applyAutoRulesOnClashResult(mySkill, myUnit, enUnit, 'lose'); }catch(_e){}
      await waitMs(140);
      if(!enIsClashGuard){
        await attackAfterClashCinematic(enSkill, clash.bRemain, clash.bDestroyed, enUnit, myUnit, enLabel, preReduce);
      }else{
        appendMatchLog(`[í•©ê°€ëŠ¥ ìˆ˜ë¹„] ìŠ¹ë¦¬: ê³µê²©í•˜ì§€ ì•Šê³  ííŠ¸ëŸ¬ì§ êµ¬ê°„ë§Œ ë‹¹ê¹€`, {cls:'guard'}, {cls:'guard'});
      }

      if(isUnbreakableCoinSkill(mySkill) && getDefenseMode(mySkill) !== 'clashGuard'){
        await attackAfterClashCinematic(mySkill, getSkillCoinCount(mySkill), clash.aDestroyed, myUnit, enUnit, myLabel);
      }
    }else{
      appendMatchLog('= í•© ì¢…ë£Œ íŒì • ì—†ìŒ');
      EL_CINE.result.textContent = 'í•© ì¢…ë£Œ íŒì • ì—†ìŒ';
    }
  }else if(mySkill){
    // âœ… í•©ê°€ëŠ¥ ìˆ˜ë¹„ëŠ” ê³µê²© ìŠ¤í‚¬ì´ ì•„ë‹ˆë¼ ë°©ì–´ ìŠ¤í‚¬ì´ë‹¤.
    // ìƒëŒ€ê°€ ìŠ¤í‚¬ì„ ì•ˆ ëƒˆë‹¤ë©´(ì¼ë°©ê³µê²© ìƒí™©) ë•Œë¦¬ëŠ” ê²Œ ì•„ë‹ˆë¼ "ëŒ€ê¸°(ë°©ì–´ ìì„¸)"ë§Œ í•œë‹¤.
    if(getDefenseMode(mySkill) === "clashGuard"){
      myUnit.activeDefense = { mode:"clashGuard", skill: myPicked, broken:false };
      appendMatchLog(`[í•©ê°€ëŠ¥ ìˆ˜ë¹„] ìƒëŒ€ ê³µê²©ì´ ì—†ì–´ ë°œë™í•˜ì§€ ì•ŠìŒ`, {cls:'guard'}, {cls:'guard'});
      renderMatchScreen();
      return true;
    }
    appendMatchLog(`[ì¼ë°©ê³µê²©] ${myLabel}`);
    await attackAfterClashCinematic(mySkill, getSkillCoinCount(mySkill), 0, myUnit, enUnit, myLabel);
  }else if(enSkill){
    if(getDefenseMode(enSkill) === "clashGuard"){
      enUnit.activeDefense = { mode:"clashGuard", skill: enPicked, broken:false };
      appendMatchLog(`[í•©ê°€ëŠ¥ ìˆ˜ë¹„] ìƒëŒ€ ê³µê²©ì´ ì—†ì–´ ë°œë™í•˜ì§€ ì•ŠìŒ`, {cls:'guard'}, {cls:'guard'});
      renderMatchScreen();
      return true;
    }
    appendMatchLog(`[ì¼ë°©ê³µê²©] ${enLabel}`);
    await attackAfterClashCinematic(enSkill, getSkillCoinCount(enSkill), 0, enUnit, myUnit, enLabel);
  }

  renderMatchScreen();
  return true;
}

function isCounterSkill(skill){
  return getDefenseMode(skill) === "counter";
}

// âœ… ë°˜ê²©: ìƒëŒ€ ê³µê²©ì´ ëë‚œ ë’¤, ë°©ì–´ìê°€ ë°˜ê²© ìŠ¤í‚¬ë¡œ 1íšŒ ê³µê²©í•œë‹¤.
function tryDoCounter(defenderUnit, attackerUnit){
  const st = defenderUnit?.activeDefense;
  if(!st || st.mode !== "counter" || st.broken || !st.skill) return false;
  st.broken = true; // ê°™ì€ í„´/ê°™ì€ êµì „ì—ì„œ ì¤‘ë³µ ë°œë™ ë°©ì§€
  const cs = st.skill;
  const label = `${getUnitLabel(defenderUnit.side)} ${getSkillName(cs||{})}`;
  appendMatchLog(`[ë°˜ê²©] ${label}`);
  attackAfterClash(cs, getSkillCoinCount(cs), 0, defenderUnit, attackerUnit, label);
  return true;
}
async function tryDoCounterCinematic(defenderUnit, attackerUnit){
  const st = defenderUnit?.activeDefense;
  if(!st || st.mode !== "counter" || st.broken || !st.skill) return false;
  st.broken = true; // ê°™ì€ í„´/ê°™ì€ êµì „ì—ì„œ ì¤‘ë³µ ë°œë™ ë°©ì§€
  const cs = st.skill;
  const label = `${getUnitLabel(defenderUnit.side)} ${getSkillName(cs||{})}`;
  appendMatchLog(`[ë°˜ê²©] ${label}`);
  await waitMs(140);
  await attackAfterClashCinematic(cs, getSkillCoinCount(cs), 0, defenderUnit, attackerUnit, label);
  return true;
}



// âœ… í•©ê°€ëŠ¥ ìˆ˜ë¹„(Clash Guard) íŒ¨ë°° ì‹œ: ê³µê²© ì „ì— 1íšŒ ì¶”ê°€ êµ´ë¦¼(íŒŒê´´ëœ ì½”ì¸ ìƒíƒœ)ìœ¼ë¡œ ìƒëŒ€ ìœ„ë ¥ ê°ì†Œ
async function rollClashGuardMitigation(skill, unit){
  try{
    const base = (Number(skill?.power||0)||0) + getSkillPowerBonus(skill, unit, "defense");
    // íŒŒê´´ëœ ì½”ì¸ ìƒíƒœ: ì½”ì¸ ë³´ì •ì€ +1ë¡œ ê³ ì •(ìš”êµ¬ì‚¬í•­: 15+7 -> 15+1)
    const headChance = getCoinHeadChance(unit);
    const head = Math.random() < headChance;
    playMatchSfx(head ? MATCH_SFX.coinHead : MATCH_SFX.coinTail, 0.33);

    const val = base + (head ? 1 : 0);

    // âœ… ê³µê²©(ìƒëŒ€) ì‹œì‘ ì „ì— ì• ë‹ˆë©”ì´ì…˜/í‘œì‹œ ë¨¼ì €
    const tgt = (unit?.side === "my")
      ? { skill: EL_CINE.mySkill, meta: EL_CINE.myMeta, coins: EL_CINE.myCoins }
      : { skill: EL_CINE.enemySkill, meta: EL_CINE.enemyMeta, coins: EL_CINE.enemyCoins };

    if(tgt.skill) tgt.skill.textContent = getSkillName(skill);
    if(tgt.meta) tgt.meta.textContent = `ê¸°ë³¸ê°’ ${base} / ì½”ì¸(íŒŒê´´) +1 / ë°©ë ™ ${getUnitDefLevel(unit)}`;

    const icons = buildBackIcons(skill, 1);
    if(tgt.coins && icons){
      renderCineCoins(tgt.coins, icons);
      icons[0] = head ? coinIconPath(skill?.coinType || 'normal') : coinBackIconPath(skill?.coinType || 'normal');
      renderCineCoins(tgt.coins, icons);
      const el = tgt.coins.children[0];
      if(el){
        el.classList.add('flip');
        setTimeout(()=> el.classList.remove('flip'), 130);
      }
    }
    await waitMs(160);

    appendMatchLog(`[í•©ê°€ëŠ¥ ìˆ˜ë¹„ íŒ¨ë°°] ${getSkillName(skill)} ì¶”ê°€ êµ´ë¦¼: ${val} (${head?'ì•':'ë’¤'}) â†’ ìƒëŒ€ ìœ„ë ¥ -${val}`, {cls:'guard'}, {cls:'guard'});
    return Math.max(0, val);
  }catch(e){
    return 0;
  }
}


function getCoreName(data){
  return data?.name || data?.title || data?.core?.name || "ì´ë¦„ ì—†ìŒ";
}
function getCoreStats(core){
  const st = core?.status || {};
  const hpNow = st?.hp ?? core?.hp ?? core?.HP ?? "-";
  const hpMax = core?.maxHp ?? st?.maxHp ?? hpNow;
  const hpText = (Number.isFinite(Number(hpNow)) && Number.isFinite(Number(hpMax)))
    ? `${Number(hpNow)} / ${Number(hpMax)}`
    : String(hpNow ?? "-");

  return [
    ["HP", hpText],
    ["ë³´í˜¸ë§‰", (Number(core?.status?.shield||0)||0) ? String(Number(core?.status?.shield||0)) : "-"],
    ["ë°©ì–´ Lv", st?.defLv ?? core?.defLevel ?? core?.defLv ?? "-"],
    ["ì •ì‹ ë ¥", "0"],
  ];
}
function parseResWordToShort(v){
  const t = String(v || "").trim();
  if(!t) return "-";
  if(t.includes("ì•½ì ")) return "ì•½ì ";
  if(t.includes("ê²¬ë”¤")) return "ê²¬ë”¤";
  if(t.includes("ì¹˜ëª…")) return "ì¹˜ëª…";
  if(t.includes("ë‚´ì„±")) return "ë‚´ì„±";
  if(t.includes("ë³´í†µ")) return "ë³´í†µ";
  return t;
}

function parsePreviewSummaryToBattleData(preview, fallbackName){
  const summary = String(preview?.summary || "");
  const name = preview?.name || preview?.title || fallbackName || "ì ";

  const out = {
    name,
    core: {
      name,
      status: { hp: "-", spdMin: 1, spdMax: 6, defLv: "-", sp: 0, skillSlots: 1 },
      phys: {},
      sins: {},
      staggers: []
    },
    passives: [],
    skills: [],
    dedicatedKeywords: []
  };

  const mCore = summary.match(/HP\s*([0-9]+)\s*\/\s*ì†ë„\s*([0-9]+)\s*~\s*([0-9]+)\s*\/\s*ë°©ì–´\s*ë ˆë²¨\s*([0-9]+)/);
  if(mCore){
    out.core.status.hp = Number(mCore[1]);
    out.core.status.spdMin = Number(mCore[2]);
    out.core.status.spdMax = Number(mCore[3]);
    out.core.status.defLv = Number(mCore[4]);
  }

  // ííŠ¸ëŸ¬ì§ êµ¬ê°„ì´ summaryì— ì—†ìœ¼ë©´ ë„¤ ì˜ˆì‹œ ê¸°ì¤€ ê¸°ë³¸ê°’ [1,50] ì¤˜ë„ ë¨ (ì›ì¹˜ ì•Šìœ¼ë©´ ì œê±°)
  out.core.staggers = [1, 50];

  const mPhys = summary.match(/ì°¸ê²©:\s*([^\s/]+)\s*\/\s*ê´€í†µ:\s*([^\s/]+)\s*\/\s*íƒ€ê²©:\s*([^\n]+)/);
  if(mPhys){
    out.core.phys = {
      slash: parseResWordToShort(mPhys[1]),
      pierce: parseResWordToShort(mPhys[2]),
      blunt: parseResWordToShort(mPhys[3]),
    };
  }

  const passiveBlock = (summary.match(/\[íŒ¨ì‹œë¸Œ\]([\s\S]*?)(?:\n\s*\[|$)/) || [])[1] || "";
  const passiveLines = passiveBlock
    .split("\n")
    .map(s => s.replace(/^â€¢\s*/, "").trim())
    .filter(Boolean);

  out.passives = passiveLines.map((nm, i) => ({ id:`pv_preview_${i}`, name:nm, text:"" }));

  const kwLine = (summary.match(/\[ì „ìš© í‚¤ì›Œë“œ\]\s*([^\n]+)/) || [])[1] || "";
  out.dedicatedKeywords = kwLine
    .split("/")
    .map(s => s.trim())
    .filter(Boolean)
    .map((name, i) => ({ id:`dk_preview_${i}`, name, state:"buff", text:"" }));

  return out;
}
function getStaggerText(core){
  const arr =
    core?.staggers ||
    core?.staggerThresholds ||
    core?.stagger ||
    core?.staggerPoints ||
    [];

  if(Array.isArray(arr) && arr.length){
    return `êµ¬ê°„: ${arr.join(" / ")}`;
  }
  return "êµ¬ê°„ ì •ë³´ ì—†ìŒ";
}
function collectKeywords(data){
  // ë§¤ì¹˜ í™”ë©´ "í‚¤ì›Œë“œ"ëŠ” ì „ìš© í‚¤ì›Œë“œë§Œ í‘œì‹œ
  const dk = Array.isArray(data?.dedicatedKeywords) ? data.dedicatedKeywords : [];

  const uniq = [...new Set(
    dk.map(k => String(k?.name || "").trim()).filter(Boolean)
  )];

  return uniq.map(name => {
    const info = (typeof findKeywordAny === "function") ? findKeywordAny(name) : null;
    return {
      name,
      state: info?.state === "debuff" ? "debuff" : "buff",
      iconSrc: info?.iconSrc || "",
      iconKey: info?.iconKey || "",
      isDedicated: !!info?.isDedicated
    };
  });
}
function getPassivePreview(data){
  const arr = Array.isArray(data?.passives) ? data.passives : [];
  if(!arr.length) return "-";
  return arr.slice(0,2).map(p => p?.title || p?.name || "(ì´ë¦„ ì—†ìŒ)").join(" / ");
}
function getSkillsByType(data, type){
  const arr = Array.isArray(data?.skills) ? data.skills : [];
  return arr.filter(s => String(s?.skillType || "normal") === type);
}
function getSkillsByType(data, type){
  const arr = Array.isArray(data?.skills) ? data.skills : [];
  return arr.filter(s => {
    const t = String(
      s?.skillType ??
      s?.kind ??       // âœ… ë„¤ JSON ëŒ€ì‘
      s?.type ??
      "normal"
    ).toLowerCase();
    return t === String(type).toLowerCase();
  });
}

function getNormalSkills(data){
  const src = (data && data.char) ? data.char : (data || {});
  const arr = Array.isArray(src?.skills) ? src.skills : [];

  return arr.filter(s => {
    const t = String(
      s?.skillType ??
      s?.kind ??
      s?.type ??
      "normal"
    ).toLowerCase().trim();

    // âœ… êµ¬ë²„ì „/í˜¼í•© ë°ì´í„° ë°©ì–´
    if (s?.isSpecial === true) return false;
    if (t === "special" || t === "íŠ¹ìˆ˜") return false;

    return true;
  });
}

function getSpecialSkills(data){
  const src = (data && data.char) ? data.char : (data || {});
  const arr = Array.isArray(src?.skills) ? src.skills : [];

  return arr.filter(s => {
    const t = String(
      s?.skillType ??
      s?.kind ??
      s?.type ??
      "normal"
    ).toLowerCase().trim();

    if (s?.isSpecial === true) return true;
    return (t === "special" || t === "íŠ¹ìˆ˜");
  });
}

function getSkillName(s){
  return s?.name || s?.title || "ìŠ¤í‚¬";
}

function getSkillWeight(s){
  return s?.weight ?? s?.attackWeight ?? "-";
}

function getSkillAppearRate(s){
  // âœ… spawnChanceê¹Œì§€ ì§€ì›
  const v =
    s?.appearRate ??
    s?.spawnRate ??
    s?.spawnChance ??
    s?.chance;

  return (v === 0 || v) ? `${v}%` : "-";
}

function pickWeightedSkills(skills, count){
  if(!Array.isArray(skills) || !skills.length) return [];

  const pool = skills.map(s => ({
    skill: s,
    // âœ… spawnChanceê¹Œì§€ ì§€ì›
    w: Number(
      s?.appearRate ??
      s?.spawnRate ??
      s?.spawnChance ??
      s?.chance ??
      100
    ) || 100
  }));

  const out = [];
  for(let i=0;i<count;i++){
    let sum = pool.reduce((a,b)=>a + Math.max(1,b.w), 0);
    let r = Math.random() * sum;
    let picked = pool[0];

    for(const p of pool){
      r -= Math.max(1,p.w);
      if(r <= 0){ picked = p; break; }
    }
    out.push(picked.skill);
  }
  return out;
}function randomSpeed(core){
  const st = core?.status || {};
  const min = Number(st?.spdMin ?? core?.speedMin ?? core?.spdMin ?? 1) || 1;
  const max = Number(st?.spdMax ?? core?.speedMax ?? core?.spdMax ?? 6) || 6;

  const lo = Math.min(min, max);
  const hi = Math.max(min, max);
  return Math.floor(Math.random() * (hi - lo + 1)) + lo;
}
function getSlotCount(core){
  const st = core?.status || {};
  return Number(st?.skillSlots ?? core?.skillSlots ?? core?.slots ?? 1) || 1;
}

/* ===== render helpers ===== */
function renderStatMini(el, core){
  if(!el) return;
  const unit = (MATCH_STATE?.my?.core === core) ? MATCH_STATE.my : (MATCH_STATE?.enemy?.core === core ? MATCH_STATE.enemy : null);
  const rows = getCoreStats(core);
  const unitKey = unit?.side || '';

  const maxHp = Number(unit?.maxHp || core?.maxHp || core?.status?.maxHp || core?.status?.hp || core?.hp || 0) || 0;
  const curHp = Number(unit?.currentHp ?? unit?.core?.status?.hp ?? core?.status?.hp ?? 0) || 0;
  const shield = Number(unit?.shield ?? unit?.core?.status?.shield ?? core?.status?.shield ?? 0) || 0;

  const hpPct = (maxHp > 0) ? Math.max(0, Math.min(1, curHp / maxHp)) : 0;
  const shPct = (maxHp > 0) ? Math.max(0, Math.min(1, shield / maxHp)) : 0;

  el.innerHTML = rows.map(([k,v]) => {
    if(k === 'ì •ì‹ ë ¥'){
      const txt = unit ? sanityDisplayText(unit) : '0';
      const col = getSanityColor(unit ? getUnitSanity(unit) : 0);
      return `
        <div class="statMiniCell sanityCell">
          <div class="statMiniTop">
            <b>${escHtml(k)}</b>
            <div class="statMiniSanityWrap">
              <span class="val" style="color:${col};">${escHtml(txt)}</span>
              <div class="statMiniSanityBtns">
                <button type="button" class="miniBtn" data-san-act="down" data-unit="${escHtml(unitKey)}">-</button>
                <button type="button" class="miniBtn" data-san-act="up" data-unit="${escHtml(unitKey)}">+</button>
              </div>
            </div>
          </div>
        </div>`;
    }

    if(k === 'HP'){
      const vv = (v===undefined||v===null)?'-':String(v);
      return `
        <div class="statMiniCell">
          <div class="statMiniTop">
            <b>HP</b>
            <span class="val">${escHtml(vv)}</span>
          </div>
          <div class="statBar" aria-label="HP ë°”">
            <div class="statBarFill hp" style="width:${(hpPct*100).toFixed(1)}%"></div>
          </div>
        </div>`;
    }

    if(k === 'ë³´í˜¸ë§‰'){
      const vv = (v===undefined||v===null)?'-':String(v);
      return `
        <div class="statMiniCell">
          <div class="statMiniTop">
            <b>ë³´í˜¸ë§‰</b>
            <span class="val" style="color:rgba(170,220,255,.98);">${escHtml(vv)}</span>
          </div>
          <div class="statBar" aria-label="ë³´í˜¸ë§‰ ë°”">
            <div class="statBarFill shield" style="width:${(shPct*100).toFixed(1)}%"></div>
          </div>
        </div>`;
    }

    const vv = (v===undefined||v===null)?'-':String(v);
    return `
      <div class="statMiniCell">
        <div class="statMiniTop">
          <b>${escHtml(k)}</b>
          <span class="val">${escHtml(vv)}</span>
        </div>
      </div>`;
  }).join("");

  el.querySelectorAll('[data-san-act]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      if(!MATCH_STATE) return;
      const key = btn.getAttribute('data-unit');
      const unit = MATCH_STATE[key];
      if(!unit) return;
      const dir = btn.getAttribute('data-san-act') === 'up' ? 1 : -1;
      addUnitSanity(unit, dir);
      renderMatchScreen();
    });
  });
}

function getStaggerPoints(core){
  const arr = core?.staggers || core?.staggerThresholds || core?.stagger || core?.staggerPoints || [];
  if(!Array.isArray(arr)) return [];
  return arr
    .map(v => Number(v))
    .filter(v => Number.isFinite(v) && v > 0)
    .sort((a,b)=>a-b);
}

function renderStaggerMini(el, core, unit){
  if(!el) return;
  const basePts = getStaggerPoints(core);
  if(!basePts.length){
    el.innerHTML = `<div class="staggerMiniLine">êµ¬ê°„ ì •ë³´ ì—†ìŒ</div>`;
    return;
  }
  const maxHp = Number(unit?.maxHp || core?.maxHp || core?.status?.maxHp || core?.status?.hp || core?.hp || 0) || 0;
  const consumed = new Set(Array.isArray(unit?.staggerConsumed) ? unit.staggerConsumed : []);
  const pull = Math.max(0, Number(unit?.staggerPull || 0));
  const rows = [];
  for(const pct of basePts){
    if(consumed.has(pct)) continue;
    const hpLine = maxHp > 0 ? Math.ceil(maxHp * (pct/100)) + pull : null;
    rows.push(`<span class="staggerPct">${pct}%</span>${hpLine!==null?`<span class="staggerHp">(${hpLine})</span>`:""}`);
  }
  if(!rows.length){
    el.innerHTML = `<div class="staggerMiniLine">êµ¬ê°„ ì†Œë©¸</div>`;
    return;
  }
  const tier = Number(unit?.staggerTier||0);
  const tag = !unit?.isStaggered ? "ì •ìƒ" : (tier>=2 ? "ííŠ¸ëŸ¬ì§++" : tier===1 ? "ííŠ¸ëŸ¬ì§+" : "ííŠ¸ëŸ¬ì§");
  const stateBadge = unit?.isStaggered ? `<span class="staggerState on">${tag}</span>` : `<span class="staggerState">${tag}</span>`;
  el.innerHTML = `<div class="staggerMiniLine">${stateBadge}<span>êµ¬ê°„: ${rows.join(" / ")}</span></div>`;
}

function normalizePhysRes(raw){
  if(!raw) return {};
  return {
    "ì°¸ê²©": raw["ì°¸ê²©"] ?? raw.slash ?? "-",
    "ê´€í†µ": raw["ê´€í†µ"] ?? raw.pierce ?? "-",
    "íƒ€ê²©": raw["íƒ€ê²©"] ?? raw.blunt ?? "-"
  };
}

function normalizeSinRes(raw){
  if(!raw) return {};

  // âœ… ë“¤ì–´ì˜¤ëŠ” í˜•íƒœê°€ ë‹¤ì–‘í•´ì„œ ìµœëŒ€í•œ ë„“ê²Œ ë°›ìŒ
  const src =
    raw?.sins ||
    raw?.sinRes ||
    raw?.sin ||
    raw;

  const pick = (...vals) => {
    for(const v of vals){
      if(v !== undefined && v !== null && String(v).trim() !== ""){
        return parseResWordToShort(v);
      }
    }
    return "-";
  };

  return {
    "ë¶„ë…¸": pick(src["ë¶„ë…¸"], src.sinWrath, src.wrath, src.Wrath),
    "ìƒ‰ìš•": pick(src["ìƒ‰ìš•"], src.sinLust, src.lust, src.Lust),
    "ë‚˜íƒœ": pick(src["ë‚˜íƒœ"], src.sinSloth, src.sloth, src.Sloth),
    "íƒì‹": pick(src["íƒì‹"], src.sinGluttony, src.gluttony, src.Gluttony),
    "ìš°ìš¸": pick(src["ìš°ìš¸"], src.sinGloom, src.gloom, src.sinMelancholy, src.melancholy, src.Gloom),
    "ì˜¤ë§Œ": pick(src["ì˜¤ë§Œ"], src.sinPride, src.pride, src.Pride),
    "ì§ˆíˆ¬": pick(src["ì§ˆíˆ¬"], src.sinEnvy, src.envy, src.Envy)
  };
}

function renderResLine(el, obj, keys, opts){
  if(!el) return;
  const danger = !!opts?.danger;
  const tier = (opts?.dangerTier !== undefined && opts?.dangerTier !== null) ? Number(opts.dangerTier) : (danger ? 0 : null);
  const mult = tier===2 ? 3.0 : tier===1 ? 2.5 : tier===0 ? 2.0 : null;

  const chips = keys.map(k => {
    let v = obj?.[k];
    if(mult !== null){
      v = `ì•½ì Ã—${mult.toFixed(1)}`;
    }
    return `<span class="resChip ${mult !== null ? "danger" : ""}"><span class="k">${escHtml(k)}</span> <span class="v">${escHtml(v ?? "-")}</span></span>`;
  });
  el.innerHTML = chips.join("");
}
function renderChipWrap(el, items, typeMap){
  if(!el) return;
  if(!items || !items.length){
    el.innerHTML = `<span class="chip empty">ì—†ìŒ</span>`;
    return;
  }
  el.innerHTML = items.map(t => {
    const cls = typeMap?.[t] ? ` ${typeMap[t]}` : "";
    return `<span class="chip${cls}">${escHtml(t)}</span>`;
  }).join("");
}
function renderKeywordWrap(el, items){
  if(!el) return;
  if(!items || !items.length){
    el.innerHTML = `<span class="chip empty">ì—†ìŒ</span>`;
    return;
  }
  // âœ… ë§¤ì¹˜ í™”ë©´ í‚¤ì›Œë“œ ì¹¸ì€ ì•„ì´ì½˜ ì—†ì´ "í…ìŠ¤íŠ¸ ì¹©"ë§Œ í‘œì‹œ (íˆ´íŒì€ ìœ ì§€)
  el.innerHTML = items.map(k => {
    const nm = escHtml(k.name || "");
    const st = (k.state === "debuff") ? "debuff" : "buff";
    return `<span class="pvKW ${st}" data-kw="${nm}" data-state="${st}" data-icon-key="${escHtml(k.iconKey||"")}" data-dedicated="${k.isDedicated?"1":"0"}">${nm}</span>`;
  }).join(" ");
}
function renderSlots(el, unitKey){
  if(!el || !MATCH_STATE) return;
  const unit = MATCH_STATE[unitKey];
  el.innerHTML = "";
  const count = unit.slotCount || 1;
  for(let i=0;i<count;i++){
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = `slotBtn ${unitKey==="enemy" ? "ai" : ""} ${unit.selectedSlot===i ? "active" : ""}`;
    const iconPath = unit.isStaggered ? "assets/icon_skill_slot_stagger_broken.png" : "assets/icon_skill_slot.png";
    btn.innerHTML = `<span class="slotIcWrap"><img class="slotIc" src="${iconPath}" alt="slot"><span class="ph">â—</span></span><span class="slotNum">${i+1}</span>`; const _img=btn.querySelector(".slotIc"); _img?.addEventListener("error",()=>{_img.style.display="none";});(".slotIc"); _img?.addEventListener("error",()=>{_img.style.display="none";});
    btn.addEventListener("click", () => {
      unit.selectedSlot = i;
      renderSlots(EL_MATCH.mySlots, "my");
      renderSlots(EL_MATCH.enemySlots, "enemy");
      refreshTurnSideInfo();
    });
    el.appendChild(btn);
  }
}

function openMatchSkillPreviewModal(skill){
  const s = skill || {};
  document.getElementById("matchSkillPreviewModal")?.remove();

  const modal = document.createElement("div");
  modal.id = "matchSkillPreviewModal";
  modal.style.cssText = "position:fixed;inset:0;z-index:100000;background:rgba(0,0,0,.76);display:flex;align-items:center;justify-content:center;padding:16px;";

  const box = document.createElement("div");
  box.style.cssText = "width:min(1200px,98vw);max-height:92vh;overflow:auto;border:1px solid rgba(255,255,255,.14);border-radius:16px;background:rgba(8,10,14,.98);padding:12px;box-shadow:0 18px 60px rgba(0,0,0,.6);";

  const topBar = document.createElement("div");
  topBar.style.cssText = "display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;";
  topBar.innerHTML = '<div style="font-weight:900;color:rgba(243,211,154,.95);">ìŠ¤í‚¬ ìì„¸íˆ ë³´ê¸°</div><button type="button" id="matchSkillPreviewClose" class="ghost">ë‹«ê¸°</button>';

  const holder = document.createElement("div");
  holder.style.display = "block";

  // âœ… ëª¨ë‹¬ì—ì„œëŠ” ì¶•ì†Œ ì¹´ë“œê°€ ì•„ë‹ˆë¼ í° ì¹´ë“œë¡œ ë Œë”
  renderPickedSkills(holder, [s], { compact:false, showDetailButton:false });

  box.appendChild(topBar);
  box.appendChild(holder);
  modal.appendChild(box);
  document.body.appendChild(modal);

  const close = ()=> modal.remove();
  modal.addEventListener("click",(e)=>{ if(e.target===modal) close(); });
  box.querySelector("#matchSkillPreviewClose")?.addEventListener("click", close);
}

function renderPickedSkills(el, list, opts){
  if(!el) return;
  opts = opts || {};
  const compact = (opts.compact !== false);
  const showDetailButton = (opts.showDetailButton !== false);

  if(!list || !list.length){
    el.innerHTML = `<div class="skillPickItem"><div class="meta">ì•„ì§ ì—†ìŒ</div></div>`;
    return;
  }

  el.innerHTML = "";

  list.forEach((s, idx) => {
    const card = document.createElement("div");
    card.className = compact ? "skListCard matchPickedMini" : "skListCard";
    card.style.marginBottom = compact ? "8px" : "10px";

    const top = document.createElement("div");
    top.className = "skListTop";

    // ì¢Œì¸¡ ì•„íŠ¸
    const art = document.createElement("div");
    art.className = "skListArt";

    const frameBox = document.createElement("div");
    frameBox.className = "skListFrame";

    const frame = document.createElement("img");
    frame.alt = "frame";
    frame.src = (typeof framePath === "function")
      ? framePath(s.sin, Number(s.tier || 1))
      : "";
    frameBox.appendChild(frame);

    const inner = document.createElement("div");
    inner.className = "inner";

    const innerImg = document.createElement("img");
    innerImg.alt = "skill image";

    // âœ… imgKey(ê¸°ì¡´) ë˜ëŠ” imgSrc(JSON ê²½ë¡œ) ì§€ì›
// âœ… imgKey(ê¸°ì¡´) / imgSrc(JSON ê²½ë¡œ) / AI ìŠ¤í‚¬ëª… fallback ì§€ì›
if(s.imgSrc){
  innerImg.src = s.imgSrc;
}else if(s.imgKey && typeof idbGetBlob === "function" && typeof makeObjectURLFromBlob === "function"){
  idbGetBlob(s.imgKey).then(blob => {
    if(blob){
      innerImg.src = makeObjectURLFromBlob(blob);
    }else{
      const fb = (typeof getAiSkillImageFallback === "function") ? getAiSkillImageFallback(getSkillName(s)) : "";
      innerImg.src = fb || "";
    }
  }).catch(()=>{
    const fb = (typeof getAiSkillImageFallback === "function") ? getAiSkillImageFallback(getSkillName(s)) : "";
    innerImg.src = fb || "";
  });
}else{
  const fb = (typeof getAiSkillImageFallback === "function") ? getAiSkillImageFallback(getSkillName(s)) : "";
  innerImg.src = fb || "";
}

    inner.appendChild(innerImg);
    frameBox.appendChild(inner);
    art.appendChild(frameBox);

    // ì½”ì¸ ì•„ì´ì½˜
    const coinRow = document.createElement("div");
    coinRow.className = "skListCoins";
    const coinCount = Math.max(1, Number(s.coinCount || s.qty || 1));
    const coinType  = String(s.coinType || "normal");
    for(let i=0;i<coinCount;i++){
      const c = document.createElement("img");
      c.src = (typeof coinIconPath === "function") ? coinIconPath(coinType) : "";
      c.alt = "coin";
      coinRow.appendChild(c);
    }
    art.appendChild(coinRow);

    // ìš°ì¸¡ ë³¸ë¬¸
    const main = document.createElement("div");
    main.className = "skListMain";
    if(compact) main.style.position = "relative";

const titleBar = document.createElement("div");
    titleBar.className = "skListTitleBar";
    titleBar.style.display = "flex";
    titleBar.style.alignItems = "flex-start";
    titleBar.style.gap = "8px";
    titleBar.style.justifyContent = "space-between";

    const titleEl = document.createElement("div");
    titleEl.className = "skListTitle";
    titleEl.textContent = `${getSkillName(s)}`;
    titleEl.style.flex = "1 1 auto";
    titleEl.style.minWidth = "0";
    titleBar.appendChild(titleEl);

    if(showDetailButton){
      const detailBtn = document.createElement("button");
      detailBtn.type = "button";
      detailBtn.className = "miniBtn";
      detailBtn.textContent = "ìì„¸íˆ ë³´ê¸°";
      detailBtn.style.padding = compact ? "2px 8px" : "4px 10px";
      detailBtn.style.fontSize = compact ? "10px" : "11px";
      detailBtn.style.flex = "0 0 auto";
      detailBtn.addEventListener("click", () => openMatchSkillPreviewModal(s));
      titleBar.appendChild(detailBtn);
    }

    main.appendChild(titleBar);

    const stat = document.createElement("div");
    stat.className = "skListStat";

    const rows = [
      ["ê³µê²© ê°€ì¤‘ì¹˜", String(getSkillWeight(s))],
      ["ë“±ì¥ í™•ë¥ ", String(getSkillAppearRate(s))],
      ["ì£„ì•… ì†ì„±", (typeof sinLabel === "function" ? sinLabel(s.sin) : (s.sin || "-"))],
      ["ê³µê²© ìœ í˜•", (typeof atkLabel === "function" ? atkLabel(s.atkType) : (s.atkType || "-"))],
    ];

    for(const [th, td] of rows){
      const r = document.createElement("div");
      r.className = "skListStatRow";

      const thEl = document.createElement("div");
      thEl.className = "skListStatTh";
      thEl.textContent = th;

      const tdEl = document.createElement("div");
      tdEl.className = "skListStatTd";

      if(th === "ì£„ì•… ì†ì„±" && typeof sinIconPath === "function"){
        const img = document.createElement("img");
        img.className = "skMiniIcon";
        img.src = sinIconPath(s.sin);
        img.alt = td;
        tdEl.appendChild(img);
      }

      if(th === "ê³µê²© ìœ í˜•" && typeof atkIconPath === "function"){
        const img = document.createElement("img");
        img.className = "skMiniIcon";
        img.src = atkIconPath(s.atkType);
        img.alt = td;
        tdEl.appendChild(img);
      }

      const sp = document.createElement("span");
      sp.textContent = td;
      tdEl.appendChild(sp);

      r.appendChild(thEl);
      r.appendChild(tdEl);
      stat.appendChild(r);
    }

    main.appendChild(titleBar);
    main.appendChild(stat);

    // íš¨ê³¼ í…ìŠ¤íŠ¸(ìˆìœ¼ë©´)
    const textRaw = String(s.text || "").trim();
    if(textRaw){
      const eff = document.createElement("div");
      eff.className = "skListFx";
      eff.innerHTML = (typeof skToHtml === "function")
        ? skToHtml(textRaw)
        : escHtml(textRaw).replace(/\n/g, "<br>");
      main.appendChild(eff);

      // âœ… íš¨ê³¼ ì•ˆ í‚¤ì›Œë“œ íˆ´íŒ
      if(typeof bindKwTooltipHover === "function"){
        setTimeout(() => bindKwTooltipHover(eff), 0);
      }
    }

    top.appendChild(art);
    top.appendChild(main);
    card.appendChild(top);
    el.appendChild(card);
  });
}
function renderSpecialSkillList(el){
  if(!el || !MATCH_STATE) return;
  const list = MATCH_STATE.my.specialSkills || [];
  if(!list.length){
    el.innerHTML = `<div class="skillPickItem"><div class="meta">íŠ¹ìˆ˜ ìŠ¤í‚¬ ì—†ìŒ</div></div>`;
    return;
  }
  el.innerHTML = "";
  list.forEach((s) => {
    const wrap = document.createElement("div");
    wrap.className = "skillPickItem";
    wrap.innerHTML = `
      <div class="nm">${escHtml(getSkillName(s))}</div>
      <div class="meta">ê³µê²© ê°€ì¤‘ì¹˜: ${escHtml(getSkillWeight(s))}</div>
      <button type="button">í˜„ì¬ ë½‘ì€ ìŠ¤í‚¬ì— ì¶”ê°€</button>
    `;
    wrap.querySelector("button")?.addEventListener("click", () => {
      MATCH_STATE.my.pickedSkills.push(s);
      renderPickedSkills(EL_MATCH.myPickedSkills, MATCH_STATE.my.pickedSkills);
      appendMatchLog(`ë‚´ íŠ¹ìˆ˜ ìŠ¤í‚¬ ì¶”ê°€: ${getSkillName(s)}`);
    });
    el.appendChild(wrap);
  });
}
function renderChipWrap(el, items, typeMap){
  if(!el) return;
  if(!items || !items.length){
    el.innerHTML = `<span class="chip empty">ì—†ìŒ</span>`;
    return;
  }

  const arr = Array.isArray(items) ? items : [];
  // í™•ì¥í˜• ìƒíƒœì¹© {name,power,count,state}
  if(arr.length && typeof arr[0] === "object"){
    el.innerHTML = arr.map(it => {
      const info = (typeof findKeywordAny === "function") ? findKeywordAny(it.name) : null;
      const state = (it.state === "debuff" || info?.state === "debuff") ? "debuff" : "buff";
      const nm = escHtml(String(it.name || ""));
      const p = Number(it.power || 0);
      const c = Number(it.count || 0);
      const numText = (p>0 && c>0) ? `${p}/${c}` : (p>0 ? `${p}` : (c>0 ? `${c}` : ""));
      const num = numText ? `<span class="stNum">${numText}</span>` : "";
      const icon = `<span class="stIconWrap"><img class="stIcon" ${info?.iconSrc ? `src="${info.iconSrc}"` : ""} alt=""><span class="ph">í‚¤</span></span>`;
      return `<span class="chip stChip ${state}" data-kw="${nm}" data-state="${state}" data-icon-key="${escHtml(info?.iconKey||"")}" data-dedicated="${info?.isDedicated?"1":"0"}">${icon}<span class="nm">${nm}</span>${num}</span>`;
    }).join("");
    el.querySelectorAll('.stChip').forEach(ch => {
      const img = ch.querySelector('.stIcon');
      const ph = ch.querySelector('.stIconWrap .ph');
      if(!img) return;
      const hasSrc = !!img.getAttribute('src');
      if(hasSrc){ if(ph) ph.style.display = 'none'; return; }
      const iconKey = ch.dataset.iconKey || "";
      const isDedicated = ch.dataset.dedicated === "1";
      if(isDedicated && iconKey && typeof applyIconKeyToImg === "function"){
        applyIconKeyToImg(img, iconKey).then(()=>{ if(img.style.display === 'block' && ph) ph.style.display='none'; }).catch(()=>{});
      }else{
        img.style.display = 'none';
      }
    });
    ensureKwTooltipBound(el);
    return;
  }

  el.innerHTML = arr.map(t => {
    const cls = typeMap?.[t] ? ` ${typeMap[t]}` : "";
    return `<span class="chip${cls}">${escHtml(t)}</span>`;
  }).join("");
}



function refreshStatusChipsUI(unit){
  try{
    if(!unit || !MATCH_STATE) return;
    const view = document.getElementById('view-match');
    if(view && view.classList.contains('hidden')) return;
    const el = (unit.side === 'my') ? EL_MATCH.myStatus : EL_MATCH.enemyStatus;
    if(!el) return;
    renderChipWrap(el, unit.statusChips);
    ensureKwTooltipBound(el);
  }catch(e){}
}

function getStatusKeywordCandidates(unitKey){
  const out = [];
  const pushKw = (name, stateHint) => {
    const key = String(name||"").trim();
    if(!key) return;
    const same = out.find(x => String(x.name).replace(/\s+/g,"") === key.replace(/\s+/g,""));
    if(same) return;
    const info = (typeof findKeywordAny === "function") ? findKeywordAny(key) : null;
    out.push({
      name: key,
      state: info?.state || stateHint || "debuff",
      iconSrc: info?.iconSrc || "",
      iconKey: info?.iconKey || "",
      isDedicated: !!info?.isDedicated,
      text: info?.text || ""
    });
  };

  for(const k of (Array.isArray(BASE_KEYWORDS) ? BASE_KEYWORDS : [])) pushKw(k?.name, k?.state);
  for(const k of (Array.isArray(REP_KEYWORDS) ? REP_KEYWORDS : [])) pushKw(k?.name, k?.state);

  const unit = MATCH_STATE?.[unitKey];
  const raw = unit?.raw || {};
  for(const srcRaw of [MATCH_STATE?.my?.raw, MATCH_STATE?.enemy?.raw, raw]){
    for(const k of (Array.isArray(srcRaw?.dedicatedKeywords) ? srcRaw.dedicatedKeywords : [])) pushKw(k?.name, k?.state);
  }

  for(const s of (Array.isArray(unit?.statusChips) ? unit.statusChips : [])) pushKw(s?.name, s?.state);

  return out;
}

function applyStatusStackChange(unitKey, kwName, power, count, opts={}){
  if(!MATCH_STATE || !kwName) return;
  const unit = MATCH_STATE[unitKey];
  if(!unit) return;

  const info = (typeof findKeywordAny === "function") ? findKeywordAny(kwName) : null;
  const state = info?.state || opts.state || "debuff";

  if(!Array.isArray(unit.statusChips)) unit.statusChips = [];
  const same = (a,b)=> String(a||"").replace(/\s+/g,"") === String(b||"").replace(/\s+/g,"");
  let hit = unit.statusChips.find(x => same(x.name, kwName));

  if(opts.remove){
    if(hit){
      unit.statusChips = unit.statusChips.filter(x => x !== hit);
      renderChipWrap(unitKey==="my" ? EL_MATCH.myStatus : EL_MATCH.enemyStatus, unit.statusChips);
      appendMatchLog(`${unitKey==="my"?"ë‚´ íŒ€":"ì "} ì œê±°: ${kwName}`);
    }
    return;
  }

  const kwNorm = String(kwName||"").replace(/\s+/g,"");
  if(kwNorm === "ì§„ë™í­ë°œ"){
    const burstCount = Math.max(0, Number(count)||0);
    const act = opts.modeLabel || "ì ìš©";
    appendMatchLog(`${unitKey==="my"?"ë‚´ íŒ€":"ì "} ${act}: ${kwName} ${Math.max(0,Number(power)||0)}/${burstCount}`);
    applyTremorBurstPull(unitKey, burstCount || 1);
    renderChipWrap(unitKey==="my" ? EL_MATCH.myStatus : EL_MATCH.enemyStatus, unit.statusChips);
    return;
  }

  if(!hit){
    hit = { name: kwName, state, power: 0, count: 0 };
    unit.statusChips.push(hit);
  }

  hit.state = state;
  hit.power = Math.max(0, Number(hit.power||0) + Math.max(0, Number(power)||0));
  hit.count = Math.max(0, Number(hit.count||0) + Math.max(0, Number(count)||0));

  if(hit.power<=0 && hit.count<=0){
    unit.statusChips = unit.statusChips.filter(x => x !== hit);
  }

  renderChipWrap(unitKey==="my" ? EL_MATCH.myStatus : EL_MATCH.enemyStatus, unit.statusChips);
  const act = opts.modeLabel || "ì ìš©";
  appendMatchLog(`${unitKey==="my"?"ë‚´ íŒ€":"ì "} ${act}: ${kwName} ${Math.max(0,Number(power)||0)}/${Math.max(0,Number(count)||0)}`);
}

function openStatusStackModal(unitKey, mode){
  if(!MATCH_STATE) return;
  const unit = MATCH_STATE[unitKey];
  if(!unit) return;

  document.getElementById("statusStackModal")?.remove();

  const modeLabel = mode === "give" ? "ë¶€ì—¬" : (mode === "gain" ? "ì–»ê¸°" : "ì œê±°");
  const targetLabel = unitKey === "my" ? "ë‚´ íŒ€" : "ì ";
  const candidates = getStatusKeywordCandidates(unitKey);

  let selectedName = "";
  let selectedState = "debuff";

  const modal = document.createElement("div");
  modal.id = "statusStackModal";
  modal.style.cssText = "position:fixed;inset:0;z-index:100001;background:rgba(0,0,0,.68);display:flex;align-items:center;justify-content:center;padding:14px;";

  const box = document.createElement("div");
  box.style.cssText = "width:min(900px,96vw);max-height:88vh;overflow:auto;border:1px solid rgba(255,255,255,.14);border-radius:16px;background:rgba(8,10,14,.97);box-shadow:0 18px 60px rgba(0,0,0,.6);";

  box.innerHTML = `
    <div style="display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);">
      <div style="font-weight:900;color:rgba(243,211,154,.95);">${targetLabel} ${modeLabel}</div>
      <button type="button" class="ghost" id="statusStackCloseBtn">ë‹«ê¸°</button>
    </div>
    <div style="padding:12px;">
      <div style="margin-bottom:10px;color:rgba(238,241,255,.78);font-size:12px;">í‚¤ì›Œë“œë¥¼ ì„ íƒí•˜ê³  ìœ„ë ¥/íšŸìˆ˜ë¥¼ ì…ë ¥í•´.</div>
      <div style="margin-bottom:10px;">
        <input id="statusKwSearchInput" type="text" placeholder="í‚¤ì›Œë“œ ê²€ìƒ‰" style="width:100%;height:38px;padding:0 12px;border-radius:10px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.28);color:#eef1ff;outline:none;">
      </div>
      <div id="statusKwPickWrap" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:8px;max-height:260px;overflow:auto;padding-right:2px;"></div>

      <div style="margin-top:12px;padding:12px;border:1px solid rgba(255,255,255,.10);border-radius:12px;background:linear-gradient(180deg, rgba(255,140,40,.08), rgba(255,255,255,.01));">
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
          <div style="min-width:180px;flex:1 1 180px;">
            <div style="font-size:11px;opacity:.75;">ì„ íƒ í‚¤ì›Œë“œ</div>
            <div id="statusSelectedKw" style="font-weight:800;min-height:22px;display:flex;align-items:center;">-</div>
          </div>

          <div style="display:flex;gap:10px;flex-wrap:wrap;">
            <label style="display:flex;flex-direction:column;gap:4px;min-width:108px;">
              <span style="font-size:11px;opacity:.8;">ìœ„ë ¥</span>
              <input id="statusPowerInput" type="number" min="0" value="0" class="statusNumInput">
            </label>
            <label style="display:flex;flex-direction:column;gap:4px;min-width:108px;">
              <span style="font-size:11px;opacity:.8;">íšŸìˆ˜</span>
              <input id="statusCountInput" type="number" min="0" value="0" class="statusNumInput">
            </label>
          </div>
        </div>

        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;flex-wrap:wrap;">
          <button type="button" class="ghost" id="statusRemoveBtn">í‚¤ì›Œë“œ ì œê±°</button>
          <button type="button" class="primary" id="statusApplyBtn">${modeLabel} ì ìš©</button>
        </div>
      </div>
    </div>
  `;

  modal.appendChild(box);
  document.body.appendChild(modal);

  const kwWrap = box.querySelector("#statusKwPickWrap");
  const searchInput = box.querySelector("#statusKwSearchInput");
  const selectedEl = box.querySelector("#statusSelectedKw");
  const powerInput = box.querySelector("#statusPowerInput");
  const countInput = box.querySelector("#statusCountInput");
  const applyBtn = box.querySelector("#statusApplyBtn");
  const removeBtn = box.querySelector("#statusRemoveBtn");

  function setSelected(name, state){
    selectedName = String(name || "");
    selectedState = state || "debuff";
    selectedEl.textContent = selectedName || "-";
    kwWrap.querySelectorAll(".statusKwPickBtn").forEach(btn => {
      btn.classList.toggle("isSel", btn.dataset.kw === selectedName);
      btn.style.outline = btn.dataset.kw === selectedName ? "2px solid rgba(243,211,154,.65)" : "none";
    });
  }

  function renderStatusKwButtons(filterText=""){
    const q = String(filterText||"").trim().replace(/\s+/g,"").toLowerCase();
    const list = q ? candidates.filter(c => String(c.name||"").replace(/\s+/g,"").toLowerCase().includes(q)) : candidates.slice();

    if(!list.length){
      kwWrap.innerHTML = `<div style="opacity:.7;font-size:12px;grid-column:1/-1;">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŒ</div>`;
      return;
    }

    kwWrap.innerHTML = list.map(c => {
      const stateCls = c.state === "debuff" ? "debuff" : "buff";
      const iconHtml = `<span class="statusKwBtnIcon"><img alt="" style="display:none;"><span class="ph">í‚¤</span></span>`;
      return `<button type="button" class="chip statusKwPickBtn ${stateCls}" data-kw="${escHtml(c.name)}" data-state="${stateCls}" style="display:flex;align-items:center;gap:6px;justify-content:flex-start;padding:8px 10px;text-align:left;">${iconHtml}<span>${escHtml(c.name)}</span></button>`;
    }).join("");

    ensureKwTooltipBound(kwWrap);

    kwWrap.querySelectorAll(".statusKwPickBtn").forEach(btn => {
      const c = list.find(x => x.name === btn.dataset.kw);
      const img = btn.querySelector(".statusKwBtnIcon img");
      const ph = btn.querySelector(".statusKwBtnIcon .ph");
      if(c && img){
        if(c.iconSrc){
          img.src = c.iconSrc;
          img.style.display = "block";
          if(ph) ph.style.display = "none";
        }else if(c.isDedicated && c.iconKey && typeof applyIconKeyToImg === "function"){
          applyIconKeyToImg(img, c.iconKey).then(()=>{
            if(img.style.display === "block" && ph) ph.style.display = "none";
          }).catch(()=>{});
        }
      }

      btn.addEventListener("click", () => {
        setSelected(btn.dataset.kw, btn.dataset.state);
      });
    });

    if(selectedName){
      const still = list.find(x => x.name === selectedName);
      if(still) setSelected(still.name, still.state);
    }else if(list[0]){
      setSelected(list[0].name, list[0].state);
    }
  }

  if(!candidates.length){
    kwWrap.innerHTML = `<div style="opacity:.7;font-size:12px;">ì„ íƒ ê°€ëŠ¥í•œ í‚¤ì›Œë“œê°€ ì—†ìŒ</div>`;
  }else{
    renderStatusKwButtons("");
    searchInput?.addEventListener("input", ()=> renderStatusKwButtons(searchInput.value));
  }

  applyBtn?.addEventListener("click", () => {
    if(!selectedName){
      alert("í‚¤ì›Œë“œë¥¼ ë¨¼ì € ì„ íƒí•´ì¤˜.");
      return;
    }
    if(mode === "remove"){
      applyStatusStackChange(unitKey, selectedName, 0, 0, { remove:true });
      modal.remove();
      return;
    }
    const p = Math.max(0, Number(powerInput?.value) || 0);
    const c = Math.max(0, Number(countInput?.value) || 0);
    if(p===0 && c===0){
      alert("ìœ„ë ¥/íšŸìˆ˜ ì¤‘ í•˜ë‚˜ëŠ” 1 ì´ìƒì´ì–´ì•¼ í•´.");
      return;
    }
    applyStatusStackChange(unitKey, selectedName, p, c, {
      modeLabel: mode === "give" ? "ë¶€ì—¬" : "íšë“",
      state: selectedState
    });
    modal.remove();
  });

  removeBtn?.addEventListener("click", () => {
    if(!selectedName){
      alert("ì œê±°í•  í‚¤ì›Œë“œë¥¼ ì„ íƒí•´ì¤˜.");
      return;
    }
    applyStatusStackChange(unitKey, selectedName, 0, 0, { remove:true });
    modal.remove();
  });

  const close = () => modal.remove();
  modal.addEventListener("click", (e)=>{ if(e.target === modal) close(); });
  box.querySelector("#statusStackCloseBtn")?.addEventListener("click", close);
}

function ensureStatusActionButtons(){
  const configs = [
    { box: EL_MATCH.myStatus?.closest(".miniBlock"), key:"my" },
    { box: EL_MATCH.enemyStatus?.closest(".miniBlock"), key:"enemy" }
  ];

  for(const cfg of configs){
    const box = cfg.box;
    if(!box) continue;

    let row = box.querySelector(".statusActionRow");
    if(!row){
      row = document.createElement("div");
      row.className = "statusActionRow";
      row.style.cssText = "display:flex;gap:6px;margin-bottom:8px;flex-wrap:wrap;";
      row.innerHTML = `
        <button type="button" class="miniBtn" data-mode="give">ë¶€ì—¬</button>
        <button type="button" class="miniBtn" data-mode="gain">ì–»ê¸°</button>
      `;

      const targetWrap = box.querySelector(".chipWrap");
      box.insertBefore(row, targetWrap);

      row.querySelector('[data-mode="give"]')?.addEventListener("click", ()=> {
        const targetKey = (cfg.key === "my") ? "enemy" : "my";
        openStatusStackModal(targetKey, "give");
      });

      row.querySelector('[data-mode="gain"]')?.addEventListener("click", ()=> {
        openStatusStackModal(cfg.key, "gain");
      });
    }
  }
}



function ensureStaggerActionButtons(){
  const configs = [
    { box: document.getElementById("myStaggerMini")?.closest(".miniBlock"), key:"my" },
    { box: document.getElementById("enemyStaggerMini")?.closest(".miniBlock"), key:"enemy" }
  ];

  for(const cfg of configs){
    const box = cfg.box;
    if(!box) continue;

    let row = box.querySelector(".staggerActionRow");
    if(!row){
      row = document.createElement("div");
      row.className = "staggerActionRow";
      row.style.cssText = "display:flex;gap:6px;margin-bottom:8px;flex-wrap:wrap;justify-content:flex-end;";
      row.innerHTML = `
        <button type="button" class="miniBtn" data-mode="staggerOn">ííŠ¸</button>
        <button type="button" class="miniBtn" data-mode="staggerOff">í•´ì œ</button>
      `;
      const target = box.querySelector("#" + (cfg.key==="my" ? "myStaggerMini" : "enemyStaggerMini")) || box.querySelector(".staggerMiniLine") || box.querySelector(".staggerMiniWrap") || box.querySelector("div");
      box.insertBefore(row, target);

      row.querySelector('[data-mode="staggerOn"]')?.addEventListener("click", ()=> { setForcedStagger(cfg.key, true); });
      row.querySelector('[data-mode="staggerOff"]')?.addEventListener("click", ()=> { setForcedStagger(cfg.key, false); });
    }
  }
}


function refreshTurnSideInfo(
){
  if(!MATCH_STATE) return;
  EL_MATCH.mySlotInfo.textContent = `${(MATCH_STATE.my.slotCount||1)}ì¹¸ / ì„ íƒ ${((MATCH_STATE.my.selectedSlot??0)+1)}ë²ˆ`;
  EL_MATCH.enemySlotInfo.textContent = `${(MATCH_STATE.enemy.slotCount||1)}ì¹¸ / ì„ íƒ ${((MATCH_STATE.enemy.selectedSlot??0)+1)}ë²ˆ`;
}
async function tryRenderPortrait(imgEl, data){
  if(!imgEl) return;
  imgEl.style.display = "none";
  imgEl.src = "";

  // 1) ê¸°ì¡´ objectURL í‚¤ ê¸°ë°˜ (ê°€ì¥ ì•ˆì „)
  const key = data?.core?.portraitKey || data?.core?.portrait?.blobKey || data?.portraitKey || "";
  if(key && typeof applyIconKeyToImg === "function"){
    try{
      await applyIconKeyToImg(imgEl, key);
      return;
    }catch(e){}
  }

  // 2) data URL / src ì§ì ‘ ì €ì¥ëœ ê²½ìš°
  const src = data?.core?.portraitUrl || data?.core?.portraitSrc || data?.portrait || "";
  if(src){
    imgEl.src = src;
    imgEl.style.display = "block";
  }
}

/* ===== main match init/render ===== */
function createBattleUnitFromChar(data, side){
  // âœ… {char:{...}} ë˜í¼ë¡œ ë“¤ì–´ì˜¤ëŠ” ê²½ìš° ìë™ ì–¸ë©
  const src = (data && data.char) ? data.char : (data || {});
  const rawCore = src?.core || {};
const st = rawCore?.status || {};

// âœ… ë§¤ì¹˜ í™”ë©´ì—ì„œ ì“°ê¸° ì‰¬ìš´ í˜•íƒœë¡œ core ì •ê·œí™”
const core = {
  ...rawCore,
  status: {
    ...st,
    level: st.level ?? rawCore.level ?? 1,
    hp: st.hp ?? rawCore.hp ?? rawCore.HP ?? "-",
    defLv: st.defLv ?? rawCore.defLv ?? rawCore.defLevel ?? "-",
    spdMin: st.spdMin ?? rawCore.spdMin ?? rawCore.speedMin ?? 1,
    spdMax: st.spdMax ?? rawCore.spdMax ?? rawCore.speedMax ?? 6,
    skillSlots: st.skillSlots ?? rawCore.skillSlots ?? 1,
    sanity: 0,
    atkLv: st.atkLv ?? rawCore.atkLv ?? rawCore.attackLevel ?? 0
  },

  // ë Œë”ëŸ¬ í˜¸í™˜ìš© ë³„ì¹­ë“¤
  level: rawCore.level ?? st.level ?? 1,
  hp: rawCore.hp ?? st.hp ?? "-",
  defLevel: rawCore.defLevel ?? rawCore.defLv ?? st.defLv ?? "-",
  atkLevel: rawCore.atkLevel ?? rawCore.atkLv ?? st.atkLv ?? 0,
  sanity: 0,
  speedMin: rawCore.speedMin ?? rawCore.spdMin ?? st.spdMin ?? 1,
  speedMax: rawCore.speedMax ?? rawCore.spdMax ?? st.spdMax ?? 6,
  skillSlots: rawCore.skillSlots ?? st.skillSlots ?? 1,

  // ë‚´ì„±/ííŠ¸ëŸ¬ì§ í˜¸í™˜
  physRes: rawCore.physRes || rawCore.physicalRes || rawCore.phys || {},
  sinRes: rawCore.sinRes || rawCore.sins || {},
  staggers: rawCore.staggers || rawCore.staggerThresholds || rawCore.stagger || rawCore.staggerPoints || []
};

  const normalSkills = getNormalSkills(src);
  const specialSkills = getSpecialSkills(src);

  const maxHpNum = Number(core?.status?.hp ?? core?.hp ?? 0) || 0;
  core.maxHp = maxHpNum;
  core.status = core.status || {};
  core.status.maxHp = maxHpNum;
  core.status.hp = maxHpNum;

  return {
    side,
    raw: { ...src, core },
    core,
    maxHp: maxHpNum,
    currentHp: maxHpNum,
    slotCount: getSlotCount(core),
    selectedSlot: 0,
    speed: "-",
    normalSkills,
    specialSkills,
    pickedSkills: [],
    statusChips: [],
    activeDefense: null,
    staggerBasePercents: getStaggerPoints(core),
    staggerConsumed: [],
    staggerPull: 0,
    isStaggered: false,
    staggerTier: 0,
    staggerUntilTurn: 0,
    sanity: 0,
    panicLock: false,
    panicTurnsLeft: 0,
    shield: 0,
  };
}

async function initMatchScreenData({ myData, enemyData, enemyIsAi=false, enemyAiMeta=null }){
  MATCH_STATE = {
    turn: 1,
    enemyIsAi,
    enemyAiMeta,
    my: createBattleUnitFromChar(myData, "my"),
    enemy: createBattleUnitFromChar(enemyData, "enemy"),
  };

  await renderMatchScreen();
}

async function renderMatchScreen(){
  if(!MATCH_STATE) return;

  const myData = MATCH_STATE.my.raw;
  const enData = MATCH_STATE.enemy.raw;

  EL_MATCH.myName.textContent = getCoreName(myData);
  EL_MATCH.enemyName.textContent = getCoreName(enData);

  EL_MATCH.mySpd.textContent = `SPD ${MATCH_STATE.my.speed}`;
  EL_MATCH.enemySpd.textContent = `SPD ${MATCH_STATE.enemy.speed}`;
  EL_MATCH.turnNo.textContent = String(MATCH_STATE.turn);

  renderStatMini(EL_MATCH.myStats, MATCH_STATE.my.core || {});
  renderStatMini(EL_MATCH.enemyStats, MATCH_STATE.enemy.core || {});

  renderStaggerMini(EL_MATCH.myStagger, MATCH_STATE.my.core || {}, MATCH_STATE.my);
  renderStaggerMini(EL_MATCH.enemyStagger, MATCH_STATE.enemy.core || {}, MATCH_STATE.enemy);
  ensureStaggerActionButtons();

{
  const myPhysObj = normalizePhysRes((MATCH_STATE.my.core || {}).physRes || (MATCH_STATE.my.core || {}).physicalRes || (MATCH_STATE.my.core || {}).phys || {});
  const enPhysObj = normalizePhysRes((MATCH_STATE.enemy.core || {}).physRes || (MATCH_STATE.enemy.core || {}).physicalRes || (MATCH_STATE.enemy.core || {}).phys || {});
  if(MATCH_STATE.my.isStaggered){ myPhysObj["ì°¸ê²©"]="ì•½ì "; myPhysObj["ê´€í†µ"]="ì•½ì "; myPhysObj["íƒ€ê²©"]="ì•½ì "; }
  if(MATCH_STATE.enemy.isStaggered){ enPhysObj["ì°¸ê²©"]="ì•½ì "; enPhysObj["ê´€í†µ"]="ì•½ì "; enPhysObj["íƒ€ê²©"]="ì•½ì "; }
  renderResLine(EL_MATCH.myPhys, myPhysObj, ["ì°¸ê²©","ê´€í†µ","íƒ€ê²©"], { danger: MATCH_STATE.my.isStaggered, dangerTier: MATCH_STATE.my.isStaggered ? MATCH_STATE.my.staggerTier : null });
  renderResLine(EL_MATCH.enemyPhys, enPhysObj, ["ì°¸ê²©","ê´€í†µ","íƒ€ê²©"], { danger: MATCH_STATE.enemy.isStaggered, dangerTier: MATCH_STATE.enemy.isStaggered ? MATCH_STATE.enemy.staggerTier : null });
}

renderResLine(
  EL_MATCH.mySin,
  normalizeSinRes((MATCH_STATE.my.core || {}).sinRes || (MATCH_STATE.my.core || {}).sins || {}),
  ["ë¶„ë…¸","ìƒ‰ìš•","ë‚˜íƒœ","íƒì‹","ìš°ìš¸","ì˜¤ë§Œ","ì§ˆíˆ¬"]
);
renderResLine(
  EL_MATCH.enemySin,
  normalizeSinRes((MATCH_STATE.enemy.core || {}).sinRes || (MATCH_STATE.enemy.core || {}).sins || {}),
  ["ë¶„ë…¸","ìƒ‰ìš•","ë‚˜íƒœ","íƒì‹","ìš°ìš¸","ì˜¤ë§Œ","ì§ˆíˆ¬"]
);

renderKeywordWrap(EL_MATCH.myKeywords, collectKeywords(myData));
renderKeywordWrap(EL_MATCH.enemyKeywords, collectKeywords(enData));

ensureKwTooltipBound(EL_MATCH.myKeywords);
ensureKwTooltipBound(EL_MATCH.enemyKeywords);

  renderChipWrap(EL_MATCH.myStatus, MATCH_STATE.my.statusChips);
  renderChipWrap(EL_MATCH.enemyStatus, MATCH_STATE.enemy.statusChips);
  ensureKwTooltipBound(EL_MATCH.myStatus);
  ensureKwTooltipBound(EL_MATCH.enemyStatus);
  ensureStatusActionButtons();

EL_MATCH.myPassivePrev.textContent = "";
EL_MATCH.enemyPassivePrev.textContent = "";

  renderSlots(EL_MATCH.mySlots, "my");
  renderSlots(EL_MATCH.enemySlots, "enemy");

  renderSpecialSkillList(EL_MATCH.mySpecialSkills);
  renderPickedSkills(EL_MATCH.myPickedSkills, MATCH_STATE.my.pickedSkills);
  renderPickedSkills(EL_MATCH.enemyPickedSkills, MATCH_STATE.enemy.pickedSkills);

  refreshTurnSideInfo();

  await tryRenderPortrait(EL_MATCH.myPortraitImg, myData);
  await tryRenderPortrait(EL_MATCH.enemyPortraitImg, enData);
  updateStaggerVisuals();
}


function getStatusStack(unit, names){
  if(!unit || !Array.isArray(unit.statusChips)) return null;
  const arr = Array.isArray(names) ? names : [names];
  const normalized = arr.map(n => String(n||"").replace(/\s+/g,""));
  return unit.statusChips.find(s => normalized.includes(String(s?.name||"").replace(/\s+/g,""))) || null;
}
function tickStatusCount(unit, names, dec=1){
  const st = getStatusStack(unit, names);
  if(!st) return 0;
  st.count = Math.max(0, Number(st.count||0) - dec);
  // countê°€ 0ì´ ë˜ë©´ ìƒíƒœë³„ ê·œì¹™ì— ë”°ë¼ ì •ë¦¬í•œë‹¤(ì˜ˆ: í˜¸í¡ì€ count=0ì´ë©´ powerê°€ ë‚¨ì•„ë„ ì œê±°)
  cleanupStatusIfNeeded(unit, st);
  return 1;
}
function burnTurnTick(unit){
  const burn = getStatusStack(unit, ["í™”ìƒ"]);
  if(!burn) return 0;
  const dmg = Math.max(0, Number(burn.power||0));
  if(dmg>0){
    unit.currentHp = Math.max(0, Number(unit.currentHp||0) - dmg);
    unit.core.status.hp = unit.currentHp;
  }
  burn.count = Math.max(0, Number(burn.count||0) - 1);
  cleanupStatusIfNeeded(unit, burn);
  return dmg;
}
function triggerStaggerSfx(){
  try{
    const a = new Audio("assets/sfx_stagger_break.mp3");
    a.volume = 0.7;
    a.play().catch(()=>{});
  }catch(e){}
}

// ğŸ”¥ í™”ìƒ(í„´ ì¢…ë£Œ í”¼í•´) íš¨ê³¼ìŒ
// ê¸°ë³¸ íŒŒì¼ ê²½ë¡œ(ì›í•˜ë©´ ì´ íŒŒì¼ëª…ì„ ê·¸ëŒ€ë¡œ ë§Œë“¤ì–´ì„œ ê°™ì€ í´ë”ì— ë„£ìœ¼ë©´ ë¨)
const BURN_TICK_SFX_DEFAULT_PATH = "assets/sfx_burn_tick.mp3";
// í•„ìš”í•˜ë©´ ì½˜ì†”ì—ì„œ localStorage.setItem("burnTickSfxPath","...") ë¡œ ê²½ë¡œ ë³€ê²½ ê°€ëŠ¥
// localStorage.setItem("burnTickSfxVol","0.8") ë¡œ ë³¼ë¥¨(0~1) ì¡°ì ˆ ê°€ëŠ¥

let __burnAudioCtx = null;
function __burnFallbackBeep(){
  try{
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if(!AudioCtx) return;
    __burnAudioCtx = __burnAudioCtx || new AudioCtx();
    const ctx = __burnAudioCtx;
    if(ctx.state === "suspended") ctx.resume().catch(()=>{});
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "triangle";
    o.frequency.setValueAtTime(520, ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(220, ctx.currentTime + 0.14);
    g.gain.setValueAtTime(0.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.10, ctx.currentTime + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.16);
    o.connect(g); g.connect(ctx.destination);
    o.start(); o.stop(ctx.currentTime + 0.17);
  }catch(e){}
}
function triggerBurnTickSfx(){
  const p = (localStorage.getItem("burnTickSfxPath") || BURN_TICK_SFX_DEFAULT_PATH).trim();
  const vol = Math.max(0, Math.min(1, Number(localStorage.getItem("burnTickSfxVol") || 0.85)));
  try{
    const a = new Audio(p);
    a.volume = vol;
    a.addEventListener("error", ()=>{ /* íŒŒì¼ì´ ì—†ìœ¼ë©´ ë¬´ìŒ(í˜¹ì€ ì•„ë˜ ë¹„í”„ ëŒ€ì²´) */ /*__burnFallbackBeep();*/ }, {once:true});
    a.play().catch(()=>{ /*__burnFallbackBeep();*/ });
  }catch(e){
    /*__burnFallbackBeep();*/
  }
}
const BLEED_TICK_SFX_DEFAULT_PATH = "assets/sfx_bleed_tick.mp3";
// í•„ìš”í•˜ë©´ ì½˜ì†”ì—ì„œ localStorage.setItem("bleedTickSfxPath","...") ë¡œ ê²½ë¡œ ë³€ê²½ ê°€ëŠ¥
// localStorage.setItem("bleedTickSfxVol","0.8") ë¡œ ë³¼ë¥¨(0~1) ì¡°ì ˆ ê°€ëŠ¥
function triggerBleedTickSfx(){
  const p = (localStorage.getItem("bleedTickSfxPath") || BLEED_TICK_SFX_DEFAULT_PATH).trim();
  const vol = Math.max(0, Math.min(1, Number(localStorage.getItem("bleedTickSfxVol") || 0.85)));
  if(!p) return;
  try{
    const a = new Audio(p);
    a.volume = vol;
    a.addEventListener("error", ()=>{ /* íŒŒì¼ì´ ì—†ìœ¼ë©´ ë¬´ìŒ */ }, {once:true});
    a.play().catch(()=>{});
  }catch(_e){}
}

function getNextStaggerThresholdHp(unit){
  if(!unit) return null;
  const pcts = (Array.isArray(unit.staggerBasePercents)?unit.staggerBasePercents:[]).slice().sort((a,b)=>b-a);
  const maxHp = Number(unit.maxHp||0);
  for(const pct of pcts){
    if((unit.staggerConsumed||[]).includes(pct)) continue;
    return Math.ceil(maxHp * (pct/100)) + Math.max(0, Number(unit.staggerPull||0));
  }
  return null;
}
function checkAndApplyStagger(unit){
  if(!MATCH_STATE || !unit) return false;
  const th = getNextStaggerThresholdHp(unit);
  if(th === null) return false;
  if(Number(unit.currentHp||0) > th) return false;

  // ì–´ë–¤ í¼ì„¼íŠ¸ êµ¬ê°„ì´ ì†Œë¹„ë˜ëŠ”ì§€ ê²°ì •
  const pcts = (Array.isArray(unit.staggerBasePercents)?unit.staggerBasePercents:[]).slice().sort((a,b)=>b-a);
  let consumedPct = null;
  for(const pct of pcts){
    if((unit.staggerConsumed||[]).includes(pct)) continue;
    consumedPct = pct; break;
  }
  if(consumedPct !== null) unit.staggerConsumed.push(consumedPct);

  // âœ… ì´ë¯¸ ííŠ¸ëŸ¬ì§„ ìƒíƒœë©´ ë“±ê¸‰ë§Œ ìƒìŠ¹ (ì§€ì†ì‹œê°„ì€ ì—°ì¥í•˜ì§€ ì•ŠìŒ)
  if(unit.isStaggered){
    unit.staggerTier = Math.min(2, Number(unit.staggerTier||0) + 1);
    appendMatchLog(`${unit.side==="my"?"ë‚´ íŒ€":"ì "} ííŠ¸ëŸ¬ì§${unit.staggerTier===1?"+":unit.staggerTier>=2?"++":""}!`);
    triggerStaggerSfx();
    return true;
  }

  // âœ… ìµœì´ˆ ííŠ¸ëŸ¬ì§
  unit.isStaggered = true;
  unit.staggerTier = 0;
  unit.staggerUntilTurn = Number(MATCH_STATE.turn||1) + 1;

  appendMatchLog(`${unit.side==="my"?"ë‚´ íŒ€":"ì "} ííŠ¸ëŸ¬ì§!`);
  triggerStaggerSfx();
  return true;
}
function releaseExpiredStagger(){
  if(!MATCH_STATE) return;
  for(const unit of [MATCH_STATE.my, MATCH_STATE.enemy]){
    if(unit.isStaggered && Number(MATCH_STATE.turn||1) > Number(unit.staggerUntilTurn||0)){
      unit.isStaggered = false;
      unit.staggerTier = 0;
      appendMatchLog(`${unit.side==="my"?"ë‚´ íŒ€":"ì "} ííŠ¸ëŸ¬ì§ í•´ì œ`);
    }
  }
}
function applyTremorBurstPull(unitKey, burstCount=1){
  if(!MATCH_STATE) return;
  const unit = MATCH_STATE[unitKey];
  if(!unit) return;
  const tremor = getStatusStack(unit, ["ì§„ë™"]);
  const amt = Math.max(0, Number(tremor?.power || 0)) * Math.max(0, Number(burstCount || 0));
  if(amt <= 0) return;
  unit.staggerPull = Math.max(0, Number(unit.staggerPull||0) + amt);
  playMatchSfx(MATCH_SFX.tremorBurst, 0.66);
  appendMatchLogIcon("tremorBurst", `${unitKey==="my"?"ë‚´ íŒ€":"ì "} ííŠ¸ì„  ì••ë‹¹ê¹€ +${amt} (ì§„ë™ í­ë°œ)`, {cls:"tremor"});
  checkAndApplyStagger(unit);
  renderMatchScreen();
}
function updateStaggerVisuals(){
  const myP = document.getElementById("myPortraitMini");
  const enP = document.getElementById("enemyPortraitMini");

  const mySt = !!MATCH_STATE?.my?.isStaggered;
  const enSt = !!MATCH_STATE?.enemy?.isStaggered;

  const myTier = Math.max(0, Number(MATCH_STATE?.my?.staggerTier||0));
  const enTier = Math.max(0, Number(MATCH_STATE?.enemy?.staggerTier||0));

  if(myP){
    myP.classList.toggle("isStaggered", mySt);
    myP.dataset.sttier = String(mySt ? Math.min(3, Math.max(1, (myTier||0) + 1)) : 0);
  }
  if(enP){
    enP.classList.toggle("isStaggered", enSt);
    enP.dataset.sttier = String(enSt ? Math.min(3, Math.max(1, (enTier||0) + 1)) : 0);
  }
}
function setForcedStagger(unitKey, on){
  if(!MATCH_STATE) return;
  const unit = MATCH_STATE[unitKey];
  if(!unit) return;

  if(on){
    if(unit.isStaggered){
      unit.staggerTier = Math.min(2, Number(unit.staggerTier||0) + 1);
      appendMatchLog(`${unitKey==="my"?"ë‚´ íŒ€":"ì "} ê°•ì œ ííŠ¸ëŸ¬ì§${unit.staggerTier===1?"+":unit.staggerTier>=2?"++":""}`);
    }else{
      unit.isStaggered = true;
      unit.staggerTier = 0;
      unit.staggerUntilTurn = (Number(MATCH_STATE.turn||1)+1);
      appendMatchLog(`${unitKey==="my"?"ë‚´ íŒ€":"ì "} ê°•ì œ ííŠ¸ëŸ¬ì§`);
    }
    triggerStaggerSfx();
  }else{
    unit.isStaggered = false;
    unit.staggerTier = 0;
    unit.staggerUntilTurn = 0;
    appendMatchLog(`${unitKey==="my"?"ë‚´ íŒ€":"ì "} ííŠ¸ëŸ¬ì§ í•´ì œ`);
  }

  renderMatchScreen();
}
function isAttackSkillAction(skill){
  const atk = String(skill?.atkType || skill?.type || '').toLowerCase();
  return !['guard','clash_guard','clashguard','counter','evade'].includes(atk);
}
function consumeStatusOnce(unit, names, amountField=null){
  const st = getStatusStack(unit, names);
  if(!st) return {amount:0, stack:null};
  const amount = amountField ? Math.max(0, Number(st[amountField] || 0)) : 0;
  st.count = Math.max(0, Number(st.count||0) - 1);
  cleanupStatusIfNeeded(unit, st);
  return {amount, stack:st};
}
function applyBleedOnSkillUse(unit, skill, label){
  if(!unit || !isAttackSkillAction(skill)) return 0;
  const st = getStatusStack(unit, ['ì¶œí˜ˆ']);
  if(!st) return 0;
  const dmg = Math.max(0, Number(st.power||0));
  if(dmg > 0){
    unit.currentHp = Math.max(0, Number(unit.currentHp||0) - dmg);
    unit.core.status.hp = unit.currentHp;
    triggerBleedTickSfx();
    appendMatchLogIcon("bleed", `- ${label} ì¶œí˜ˆ í”¼í•´ ${dmg}`, {cls:"bleed"});
    checkAndApplyStagger(unit);
  }
  st.count = Math.max(0, Number(st.count||0) - 1);
  cleanupStatusIfNeeded(unit, st);
  return dmg;
}
function applyOnHitDefenderStatuses(defenderUnit, attackerLabel){
  let sinkingLoss = 0;
  let ruptureDmg = 0;
  const sinking = getStatusStack(defenderUnit, ['ì¹¨ì ']);
  if(sinking){
    sinkingLoss = Math.max(0, Number(sinking.power||0));
    if(sinkingLoss){
      addUnitSanity(defenderUnit, -sinkingLoss);
      appendMatchLogIcon("sinking", `- ${attackerLabel} í”¼ê²© íš¨ê³¼: ì¹¨ì ìœ¼ë¡œ ì •ì‹ ë ¥ ${sinkingLoss} ê°ì†Œ`, {cls:"sinking"});
    }
    sinking.count = Math.max(0, Number(sinking.count||0) - 1);
    cleanupStatusIfNeeded(defenderUnit, sinking);
  }
  const rupture = getStatusStack(defenderUnit, ['íŒŒì—´']);
  if(rupture){
    ruptureDmg = Math.max(0, Number(rupture.power||0));
    if(ruptureDmg){
      defenderUnit.currentHp = Math.max(0, Number(defenderUnit.currentHp||0) - ruptureDmg);
      defenderUnit.core.status.hp = defenderUnit.currentHp;
      appendMatchLogIcon("rupture", `- ${attackerLabel} í”¼ê²© íš¨ê³¼: íŒŒì—´ í”¼í•´ ${ruptureDmg}`, {cls:"rupture"});
      checkAndApplyStagger(defenderUnit);
    }
    rupture.count = Math.max(0, Number(rupture.count||0) - 1);
    cleanupStatusIfNeeded(defenderUnit, rupture);
  }
  return {sinkingLoss, ruptureDmg};
}
function getBreathCritResult(attackerUnit){
  const breath = getStatusStack(attackerUnit, ['í˜¸í¡']);
  if(!breath) return {crit:false, mult:1, chance:0};

  // í˜¸í¡(crit)ì€ ìœ„ë ¥(power)ì— ë”°ë¼ í™•ë¥ ì´ ê²°ì •ë˜ë©°,
  // **íšŸìˆ˜(count)ëŠ” "ì¹˜ëª…íƒ€ê°€ ì‹¤ì œë¡œ ë°œë™í–ˆì„ ë•Œ"ë§Œ ê°ì†Œ**í•œë‹¤.
  // (í„´ ì¢…ë£Œ ì‹œ 1 ê°ì†ŒëŠ” ë³„ë„ tickStatusCountì—ì„œ ì²˜ë¦¬ë¨)
  const chance = clamp((Number(breath.power||0) || 0) * 0.05, 0, 1);
  const crit = Math.random() < chance;

  if(crit){
    breath.count = Math.max(0, Number(breath.count||0) - 1);
    cleanupStatusIfNeeded(attackerUnit, breath);
    playMatchSfx(MATCH_SFX.crit, 0.62);
  }
  return {crit, mult:(crit?1.2:1), chance};
}
function adjustSanityAfterClashResult(winnerUnit, loserUnit){
  if(winnerUnit) addUnitSanity(winnerUnit, +10);
  if(loserUnit) addUnitSanity(loserUnit, -5);
  renderMatchScreen();
}

function processTurnStartEffects(){
  if(!MATCH_STATE) return;
  releaseExpiredStagger();
  for(const unit of [MATCH_STATE.my, MATCH_STATE.enemy]){
    processPanicTurnStart(unit);
    // ë³´í˜¸ë§‰(ì„ì‹œì²´ë ¥): í„´ ì‹œì‘ ì‹œ ì´ˆê¸°í™”
    unit.shield = 0;
    unit.core.status = unit.core.status || {};
    unit.core.status.shield = 0;
    unit.slotCount = Math.min(5, Math.max(1, Number(unit.slotCount||1) + 1));
    unit.core.status.skillSlots = unit.slotCount;
    const burnDmg = burnTurnTick(unit);
    if(burnDmg > 0){ triggerBurnTickSfx(); appendMatchLogIcon("burn", `${unit.side==="my"?"ë‚´ íŒ€":"ì "} í™”ìƒ í”¼í•´ ${burnDmg}`, {cls:"burn"}); }
    tickStatusCount(unit, ["í˜¸í¡"]);
    tickStatusCount(unit, ["ì¶©ì „"]);
    unit.core.status.hp = Math.max(0, Number(unit.currentHp||0));
    checkAndApplyStagger(unit);
  }
  renderMatchScreen();
}

/* ===== actions ===== */
function rollTurnForBoth(){
  if(!MATCH_STATE) return;

  MATCH_STATE.my.speed = Math.max(1, randomSpeed(MATCH_STATE.my.core) + getStatusPower(MATCH_STATE.my, ["ì‹ ì†"]) - getStatusPower(MATCH_STATE.my, ["ì†ë°•"]));
  MATCH_STATE.enemy.speed = Math.max(1, randomSpeed(MATCH_STATE.enemy.core) + getStatusPower(MATCH_STATE.enemy, ["ì‹ ì†"]) - getStatusPower(MATCH_STATE.enemy, ["ì†ë°•"]));

  if(isUnitStaggerLocked(MATCH_STATE.my)){
    MATCH_STATE.my.pickedSkills = [];
    MATCH_STATE.my.selectedSlot = 0;
  }else{
    MATCH_STATE.my.pickedSkills = pickWeightedSkills(MATCH_STATE.my.normalSkills, MATCH_STATE.my.slotCount);
  }

  if(isUnitStaggerLocked(MATCH_STATE.enemy)){
    MATCH_STATE.enemy.pickedSkills = [];
    MATCH_STATE.enemy.selectedSlot = 0;
  }else{
    MATCH_STATE.enemy.pickedSkills = pickWeightedSkills(MATCH_STATE.enemy.normalSkills, MATCH_STATE.enemy.slotCount);
  }

  // AI: ì ì€ ì†ë„ ë†’ì€ ìŠ¬ë¡¯ë¶€í„° ì„ì˜ ì§€ì •(ì¼ë‹¨ ë”ë¯¸)
  MATCH_STATE.enemy.selectedSlot = 0;
  if(!isUnitStaggerLocked(MATCH_STATE.enemy) && MATCH_STATE.enemy.slotCount > 1 && MATCH_STATE.enemy.pickedSkills.length){
    MATCH_STATE.enemy.selectedSlot = Math.floor(Math.random() * MATCH_STATE.enemy.pickedSkills.length);
  }

  renderMatchScreen();

  try{ MATCH_STATE.my.activeDefense=null; MATCH_STATE.enemy.activeDefense=null; }catch(_e){}
appendMatchLog(`[í„´ ${MATCH_STATE.turn}] ì†ë„ êµ´ë¦¼`);
  appendMatchLog(`- ë‚´ ì†ë„: ${MATCH_STATE.my.speed}`);
  appendMatchLog(`- ì  ì†ë„: ${MATCH_STATE.enemy.speed}`);
  if(isUnitStaggerLocked(MATCH_STATE.my)) appendMatchLog(`- ë‚´ íŒ€ì€ ííŠ¸ëŸ¬ì§ ìƒíƒœë¼ ìŠ¤í‚¬ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ`);
  if(isUnitStaggerLocked(MATCH_STATE.enemy)) appendMatchLog(`- ì ì€ ííŠ¸ëŸ¬ì§ ìƒíƒœë¼ ìŠ¤í‚¬ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ`);

  if(MATCH_STATE.enemy.pickedSkills.length){
    const aiNames = MATCH_STATE.enemy.pickedSkills.map(s => getSkillName(s)).join(", ");
    appendMatchLog(`- ì ì´ ë½‘ì€ ìŠ¤í‚¬: ${aiNames} (ì„ íƒ ìŠ¬ë¡¯ ${MATCH_STATE.enemy.selectedSlot+1})`);
  }
}

function injectPassiveKeywordTokens(textRaw, unitRaw){
  let text = String(textRaw || "");
  if(!text) return text;

  // âœ… ì´ë¯¸ kw í† í°ì´ ë“¤ì–´ìˆëŠ” JSON í…ìŠ¤íŠ¸ëŠ” ì¬ì£¼ì…í•˜ì§€ ì•ŠìŒ (ì¤‘ì²© ë°©ì§€)
  if(/\[\[kw:(buff|debuff):/.test(text)){
    return text;
  }

  const allKw = [];

  // ê¸°ë³¸/ëŒ€í‘œ
  for(const k of (Array.isArray(BASE_KEYWORDS) ? BASE_KEYWORDS : [])){
    if(k?.name) allKw.push({
      name: String(k.name),
      state: (k.state === "debuff") ? "debuff" : "buff"
    });
  }
  for(const k of (Array.isArray(REP_KEYWORDS) ? REP_KEYWORDS : [])){
    if(k?.name) allKw.push({
      name: String(k.name),
      state: (k.state === "debuff") ? "debuff" : "buff"
    });
  }

  // í˜„ì¬ ìœ ë‹› ì „ìš©
  for(const k of (Array.isArray(unitRaw?.dedicatedKeywords) ? unitRaw.dedicatedKeywords : [])){
    if(k?.name) allKw.push({
      name: String(k.name),
      state: (k.state === "debuff") ? "debuff" : "buff"
    });
  }

  // ì¤‘ë³µ ì œê±° + ê¸´ ì´ë¦„ ìš°ì„ 
  const seen = new Set();
  const uniq = [];
  for(const kw of allKw){
    const key = `${kw.state}::${kw.name}`;
    if(seen.has(key)) continue;
    seen.add(key);
    uniq.push(kw);
  }
  uniq.sort((a,b) => b.name.length - a.name.length);

  if(!uniq.length) return text;

  // âœ… ì´ë¯¸ ë“¤ì–´ìˆëŠ” [[kw:...]] í† í°ì€ ë³´í˜¸
  const tokenStore = [];
  text = text.replace(/\[\[kw:(buff|debuff):([^\]]+)\]\]/g, (m) => {
    const idx = tokenStore.push(m) - 1;
    return `__KW_TOKEN_${idx}__`;
  });

  // âœ… "í•œ ë²ˆì—" ì¹˜í™˜ (í† í° ë‚´ë¶€ ì¬ì¹˜í™˜ ë°©ì§€)
  const escapedNames = uniq.map(kw => kw.name.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
  const rx = new RegExp(escapedNames.join("|"), "g");

  text = text.replace(rx, (matched) => {
    const hit = uniq.find(kw => kw.name === matched);
    if(!hit) return matched;
    return `[[kw:${hit.state}:${hit.name}]]`;
  });

  // ë³´í˜¸ í† í° ë³µì›
  text = text.replace(/__KW_TOKEN_(\d+)__/g, (m, n) => tokenStore[Number(n)] || m);

  return text;
}
function openMatchPassiveModal(unitRaw){
  const src = (unitRaw && unitRaw.char) ? unitRaw.char : (unitRaw || {});
  const list = Array.isArray(src?.passives) ? src.passives : [];

  document.getElementById("matchPassiveModal")?.remove();

  const modal = document.createElement("div");
  modal.id = "matchPassiveModal";
  modal.style.cssText = `
    position:fixed; inset:0; z-index:99999;
    background:rgba(0,0,0,.6);
    display:flex; align-items:center; justify-content:center;
    padding:18px;
  `;

  const box = document.createElement("div");
  box.style.cssText = `
    width:min(920px, 100%);
    max-height:82vh; overflow:auto;
    border:1px solid rgba(255,255,255,.14);
    border-radius:16px;
    background:rgba(8,10,14,.96);
    box-shadow:0 18px 60px rgba(0,0,0,.6);
  `;

  box.innerHTML = `
    <div style="display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);">
      <div style="font-weight:900;color:rgba(243,211,154,.95);">íŒ¨ì‹œë¸Œ</div>
      <button type="button" id="matchPassiveClose" class="ghost">ë‹«ê¸°</button>
    </div>
    <div id="matchPassiveBody" style="padding:12px;"></div>
  `;

  modal.appendChild(box);
  document.body.appendChild(modal);

  const body = box.querySelector("#matchPassiveBody");

  if(!list.length){
    body.innerHTML = `<div style="color:rgba(238,241,255,.65);">íŒ¨ì‹œë¸Œ ì—†ìŒ</div>`;
  }else{
    body.innerHTML = list.map((p, i) => {
      const title = escHtml(p?.name || p?.title || `íŒ¨ì‹œë¸Œ ${i+1}`);
      const styleCls = (p?.style === "red") ? "red" : "brown";
      const importance = escHtml(String(p?.importance || p?.rank || p?.tier || "").trim());

      const textRaw = injectPassiveKeywordTokens(
        String(p?.text || p?.content || p?.desc || "").trim(),
        src
      );

      const textHtml = textRaw
        ? (typeof applyInlineTokensEscaped === "function"
            ? applyInlineTokensEscaped(escHtml(textRaw)).replace(/\n/g, "<br>")
            : escHtml(textRaw).replace(/\n/g, "<br>"))
        : `<span style="opacity:.65;">ì„¤ëª… ì—†ìŒ</span>`;

      return `
        <div class="pvCard" style="margin-bottom:10px;">
          <div class="pvHdr ${styleCls}">
            <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
              <span>${title}</span>
              ${importance ? `<span style="font-size:11px;padding:2px 6px;border:1px solid rgba(255,255,255,.18);border-radius:999px;opacity:.9;">${importance}</span>` : ""}
            </div>
            <div class="slashes"><i></i><i></i><i></i></div>
          </div>
          <div class="pvBody">${textHtml}</div>
        </div>
      `;
    }).join("");
  }

  // âœ… íŒ¨ì‹œë¸Œ ëª¨ë‹¬ ë‚´ë¶€ í‚¤ì›Œë“œ íˆ´íŒ í™œì„±í™”
  if(typeof bindKwTooltipHover === "function"){
    bindKwTooltipHover(body);
  }

  const close = () => modal.remove();
  modal.addEventListener("click", (e) => { if(e.target === modal) close(); });
  box.querySelector("#matchPassiveClose")?.addEventListener("click", close);
}

/* ë²„íŠ¼ ì—°ê²° */
EL_MATCH.btnRoll?.addEventListener("click", () => {
  rollTurnForBoth();
});

EL_MATCH.btnMyPassive?.addEventListener("click", () => {
  if(!MATCH_STATE) return;
  openMatchPassiveModal(MATCH_STATE.my.raw);
});

EL_MATCH.btnEnemyPassive?.addEventListener("click", () => {
  if(!MATCH_STATE) return;
  openMatchPassiveModal(MATCH_STATE.enemy.raw);
});

document.getElementById("btn-match-next")?.addEventListener("click", async () => {
  if(!MATCH_STATE){
    toast(matchToast, "ë§¤ì¹˜ ìƒíƒœê°€ ì—†ì–´.");
    return;
  }
  if(MATCH_BATTLE_BUSY) return;
  MATCH_BATTLE_BUSY = true;
  try{
    const ok = await resolveSelectedSlotBattleAsync();
    if(!ok) return;

    MATCH_STATE.turn += 1;
    EL_MATCH.turnNo.textContent = String(MATCH_STATE.turn);
    appendMatchLog(`--- í„´ ${MATCH_STATE.turn} ì‹œì‘ ---`);
    processTurnStartEffects();

    MATCH_STATE.my.speed = "-";
    MATCH_STATE.enemy.speed = "-";
    MATCH_STATE.my.pickedSkills = [];
    MATCH_STATE.enemy.pickedSkills = [];
    renderMatchScreen();
    toast(matchToast, "ì „íˆ¬ ì§„í–‰ ì™„ë£Œ");
  } finally {
    MATCH_BATTLE_BUSY = false;
  }
});


// ===== AI battle mode =====
let playBattleMode = "char"; // "char" | "ai"

const playArena = document.getElementById("playArena");
const playLobbyHome = document.querySelector("#view-play .home");
const playLobbyTitle = document.querySelector("#view-play .playTitle");
const btnPlayRandom = document.getElementById("btn-play-random");

const CHAR_BATTLE_BACKGROUNDS = [
  {
    id: "spiderweb_thumb_father",
    name: "ê±°ë¯¸ì§‘ - ì—„ì§€ ì•„ë¹„",
    image: "assets/bg_spiderweb_thumb_father.png",
    desc: "ìºë¦­í„° ëŒ€ì „ í…ŒìŠ¤íŠ¸ìš© ë°°ê²½"
  }
];
const CHAR_BATTLE_BGMS = [
  {
    id: "thumb_father_theme",
    name: "ì—„ì§€ ì•„ë¹„",
    audio: "assets/bgm_thumb_father_theme.mp3",
    desc: "ìºë¦­í„° ëŒ€ì „ í…ŒìŠ¤íŠ¸ìš© ìŒì•…"
  }
];
const KEY_PLAY_BATTLE_BG = "limbus_play_battle_bg_v1";
const KEY_PLAY_BATTLE_BGM = "limbus_play_battle_bgm_v1";

// ìƒíƒœ(ë²„í”„/ë””ë²„í”„) í‘œì‹œ ì‹œì : ì‹¤ì‹œê°„/ê³µê²© ì¢…ë£Œ í›„
const KEY_STATUS_RENDER_REALTIME = "limbus_status_render_realtime_v1";
let STATUS_RENDER_REALTIME = (localStorage.getItem(KEY_STATUS_RENDER_REALTIME) === "1");
function setStatusRenderRealtime(v){
  STATUS_RENDER_REALTIME = !!v;
  localStorage.setItem(KEY_STATUS_RENDER_REALTIME, STATUS_RENDER_REALTIME ? "1" : "0");
  const btn = document.getElementById("btn-statusRealtime");
  if(btn) btn.textContent = STATUS_RENDER_REALTIME ? "ìƒíƒœí‘œì‹œ: ì‹¤ì‹œê°„" : "ìƒíƒœí‘œì‹œ: ì¢…ë£Œ í›„";
}

// ìƒíƒœ í‘œì‹œ í† ê¸€
setStatusRenderRealtime(STATUS_RENDER_REALTIME);
document.getElementById("btn-statusRealtime")?.addEventListener("click", () => {
  setStatusRenderRealtime(!STATUS_RENDER_REALTIME);
});


const AI_OPPONENTS = [
  {
    id: "ai_lei_heng",
    name: "ë‡Œíš¡ | é›·æ©«",
    subtitle: "Lei Heng | é›·æ¨ª",
    desc: "ì—„ì§€ ì¹´í¬ IIII / ì†Œì§€ ì²œí‡´ì„±",
    theme: {
      bg: "assets/bg_ai_leiheng_train.png",
      panel: "rgba(30,18,8,0.72)",
      line: "rgba(255,190,90,0.28)",
      glow: "rgba(255,160,60,0.24)",
      name: "rgba(255,226,150,0.98)",
      sub: "rgba(255,212,110,0.92)"
    },
    coreText: "ë‚œì´ë„/í•µì‹¬ì •ë³´ëŠ” ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ë¶™ì¼ ì˜ˆì •"
  }
];

// ===== AI ë³´ìŠ¤ ì›¨ì´ë¸Œ ì •ì˜ =====
const AI_BOSSES = {
  ai_lei_heng: {
    id: "ai_lei_heng",
    name: "ë‡Œíš¡",
    sub: "Lei Heng | é›·æ¨ª",
    waves: [
      { wave: 1, type: "enemy", charId: "thumb_soldato_2", visibleInInfo: true },
      { wave: 2, type: "enemy", charId: "thumb_soldato_3", visibleInInfo: true },
      { wave: 3, type: "boss",  charId: "ai_lei_heng",     visibleInInfo: false }
    ]
  }
};

// ===== ì „íˆ¬ ì „ ìƒì„¸ì •ë³´(ë¯¸ë¦¬ë³´ê¸°) ë°ì´í„° =====
// ì—¬ê¸° summaryëŠ” ë‚˜ì¤‘ì— ë„¤ê°€ ì§ì ‘ êµì²´í•˜ë©´ ë¼.
const PREVIEW_CHAR_INFO = {
thumb_soldato_2: {
  title: "ê° ì¡íŒ ì—„ì§€ ì†”ë‹¤í†  II",
  summary:
`[í•µì‹¬ ìƒíƒœ]
HP 1338 / ì†ë„ 2~5 / ë°©ì–´ ë ˆë²¨ 74
ì°¸ê²©: ì•½ì  / ê´€í†µ: ê²¬ë”¤ / íƒ€ê²©: ë³´í†µ

[íŒ¨ì‹œë¸Œ]
â€¢ ê·œìœ¨ ì§‘í–‰ - ì¤€ë¹„ ë‹¨ê³„
â€¢ ê·œìœ¨ ì§‘í–‰ - ì•„ë˜í„± ë¶€ìˆ˜ê¸°
â€¢ ì–´ê¸‹ë‚œ ê·œìœ¨
â€¢ ì¶”ë ¥ ìƒì‹¤
â€¢ ê·œìœ¨ ì§‘í–‰ - ì—°ì¥ ë‹¨ê³„

[ì£¼ìš” ìŠ¤í‚¬]
â€¢ ì§„íƒ• ê¿°ëš«ê¸° (ë‚˜íƒœ / íƒ€ê²©) ìœ„ë ¥ 8, ì½”ì¸ +5 x2, ë“±ì¥í™•ë¥  40%
  - ì§„ë™/í™”ìƒ í•© ìˆ˜ì¹˜ì— ë”°ë¼ ì½”ì¸ ìœ„ë ¥ ì¦ê°€
  - ì§„ë™ ë¶€ì—¬ + ì§„ë™ íšŸìˆ˜ ì¦ê°€

â€¢ ì‘ì—´ ê¿°ëš«ê¸° (ë¶„ë…¸ / ê´€í†µ) ìœ„ë ¥ 8, ì½”ì¸ +6 x2, ë“±ì¥í™•ë¥  40%
  - ì§„ë™/í™”ìƒ í•© ìˆ˜ì¹˜ì— ë”°ë¼ ì½”ì¸ ìœ„ë ¥ ì¦ê°€
  - í™”ìƒ ë¶€ì—¬ + í™”ìƒ íšŸìˆ˜ ì¦ê°€

â€¢ ì¶”ì§„ ê°€ë¥´ê¸° (ë¶„ë…¸ / ê´€í†µ) ìœ„ë ¥ 9, ì½”ì¸ +6 x2, ë“±ì¥í™•ë¥  20%
  - íŒŒê´´ ë¶ˆê°€ ì½”ì¸
  - ì¶”ì§„íƒ„ ì†Œëª¨
  - ì§„ë™/í™”ìƒ ë™ì‹œ ë¶€ì—¬
  - ì§„ë™ í­ë°œ / ì§„í­ ë³€í™˜ ì—°ê³„

â€¢ ì¶”ì§„íƒ„ ì¬ì¥ì „ (íŠ¹ìˆ˜ / í•©ê°€ëŠ¥ ìˆ˜ë¹„)
  - í•© ìŠ¹ë¦¬ ì‹œ ì¬ì¥ì „
  - í•© íŒ¨ë°° ì‹œ ì¶”ì§„íƒ„ ê°ì†Œ
  - ì¡°ê±´ ì¶©ì¡± ì‹œ ì½”ì¸ ìœ„ë ¥ +5

[ì „ìš© í‚¤ì›Œë“œ]
ì¶”ë ¥ ìƒì‹¤ / ì¬ì¥ì „ / ì¶”ì§„íƒ„ / ì§„ë™ - ì‘ì—´`
},
  thumb_soldato_3: {
    name: "ê° ì¡íŒ ì—„ì§€ ì†”ë‹¤í†  III",
    summary:
`[í•µì‹¬ ìƒíƒœ]
HP 2007 / ì†ë„ 4~7 / ë°©ì–´ ë ˆë²¨ 84
ì°¸ê²©: ë³´í†µ / ê´€í†µ: ê²¬ë”¤ / íƒ€ê²©: ë³´í†µ

[íŒ¨ì‹œë¸Œ]
â€¢ ê·œìœ¨ ì§‘í–‰ - ì¤€ë¹„ ë‹¨ê³„
â€¢ ê·œìœ¨ ì§‘í–‰ - ì•„ë˜í„± ë¶€ìˆ˜ê¸°
â€¢ ì–´ê¸‹ë‚œ ê·œìœ¨
â€¢ ì¶”ë ¥ ìƒì‹¤
â€¢ ê·œìœ¨ ì§‘í–‰ - ì—°ì¥ ë‹¨ê³„

[ì£¼ìš” ìŠ¤í‚¬]
â€¢ ì§„íƒ• ê¿°ëš«ê¸° - ì¶”[æ¨] (ë‚˜íƒœ / íƒ€ê²©) ìœ„ë ¥ 10, ì½”ì¸ +5 x2, ë“±ì¥í™•ë¥  40%
  - ì¶”ì§„íƒ„ì„ ì†Œëª¨í•˜ì—¬ ì½”ì¸ ìœ„ë ¥ ì¦ê°€
  - ì§„ë™/í™”ìƒ í•© ìˆ˜ì¹˜ì— ë”°ë¼ ì½”ì¸ ìœ„ë ¥ ì¦ê°€
  - ì§„ë™ ë¶€ì—¬ + ì§„ë™ íšŸìˆ˜ ì¦ê°€

â€¢ ì‘ì—´ ê¿°ëš«ê¸° - ì¶”[æ¨] (ë¶„ë…¸ / ê´€í†µ) ìœ„ë ¥ 10, ì½”ì¸ +6 x2, ë“±ì¥í™•ë¥  40%
  - ì¶”ì§„íƒ„ì„ ì†Œëª¨í•˜ì—¬ ì½”ì¸ ìœ„ë ¥ ì¦ê°€
  - ì§„ë™/í™”ìƒ í•© ìˆ˜ì¹˜ì— ë”°ë¼ ì½”ì¸ ìœ„ë ¥ ì¦ê°€
  - í™”ìƒ ë¶€ì—¬ + í™”ìƒ íšŸìˆ˜ ì¦ê°€

â€¢ ì¶”ì§„ ê°€ë¥´ê¸° - ì¶”[æ¨] (ë¶„ë…¸ / ê´€í†µ) ìœ„ë ¥ 11, ì½”ì¸ +6 x2, ë“±ì¥í™•ë¥  20%
  - íŒŒê´´ ë¶ˆê°€ ì½”ì¸
  - ì¶”ì§„íƒ„ ì†Œëª¨
  - ì§„ë™/í™”ìƒ ë™ì‹œ ë¶€ì—¬
  - ì§„ë™ í­ë°œ / ì§„í­ ë³€í™˜ ì—°ê³„

â€¢ ì¶”ì§„íƒ„ ì¬ì¥ì „ (íŠ¹ìˆ˜ / í•©ê°€ëŠ¥ ìˆ˜ë¹„)
  - íŒŒê´´ ë¶ˆê°€ ì½”ì¸
  - í•© ìŠ¹ë¦¬ ì‹œ ì¬ì¥ì „
  - í•© íŒ¨ë°° ì‹œ ì¶”ì§„íƒ„ ê°ì†Œ
  - ì¡°ê±´ ì¶©ì¡± ì‹œ ì½”ì¸ ìœ„ë ¥ +5

[ì „ìš© í‚¤ì›Œë“œ]
ì¶”ë ¥ ìƒì‹¤ / ì¬ì¥ì „ / ì¶”ì§„íƒ„ / ì§„ë™ - ì‘ì—´`
  }
};

// ===== ë‡Œíš¡ ì „ìš© í…ìŠ¤íŠ¸/ìŒì„± í—¬í¼ =====
const LEIHENG_VOICE_SRC = "assets/voice_ai_leiheng_select.mp3"; // íŒŒì¼ëª…ì€ ë„¤ê°€ ë°”ê¿”ë„ ë¨
let lastPlayedAiVoiceId = "";
let _lhVoiceAudio = null;
let _aiBattleBgm = null;
let _aiBattleBgmKey = "";

function isLeiHengId(id){
  return String(id || "").replace(/^ai:/, "") === "ai_lei_heng";
}

function getThemedCharLabelHtml(c){
  if(!c) return "";
  const isLH = isLeiHengId(c.id);
  const n = String(c.name || "");
  const s = String(c.subtitle || "");

  if(!isLH){
    return `${escHtml(n)}<br>${escHtml(s)}`;
  }

  return `
    <span class="lhThemeName">${escHtml(n)}</span>
    <span class="lhThemeSub">${escHtml(s)}</span>
  `.trim();
}

function playLeiHengSelectVoice(){
  try{
    if(!_lhVoiceAudio){
      _lhVoiceAudio = new Audio(LEIHENG_VOICE_SRC);
      _lhVoiceAudio.preload = "auto";
    }
    _lhVoiceAudio.currentTime = 0;
    _lhVoiceAudio.play().catch(()=>{ /* ìë™ì¬ìƒ ì œí•œ ë¬´ì‹œ */ });
  }catch(e){
    console.warn("ë‡Œíš¡ ìŒì„± ì¬ìƒ ì‹¤íŒ¨:", e);
  }
}

const AI_BATTLE_BGM_BY_KEY = {
  ai_lei_heng: "assets/bgm_ai_lei_heng_wave12.mp3"
};

// ===== AI ì„ íƒ ìŒì„± =====
function playAiBattleBgm(aiKey){
  const key = String(aiKey || "").trim();
  const srcMap = {
    ai_lei_heng: "assets/bgm_ai_lei_heng_wave12.mp3"
  };

  const src = srcMap[key] || "";

  // ê°™ì€ ë¸Œê¸ˆì´ë©´ ë‹¤ì‹œ ì¬ìƒ ì•ˆ í•¨
  if(src && _aiBattleBgm && _aiBattleBgm.src && _aiBattleBgm.src.includes(src)){
    return;
  }

  // ê¸°ì¡´ ë¸Œê¸ˆ ì •ë¦¬
  if(_aiBattleBgm){
    try{
      _aiBattleBgm.pause();
      _aiBattleBgm.currentTime = 0;
    }catch(e){}
    _aiBattleBgm = null;
  }

  // ì¬ìƒí•  ê²Œ ì—†ìœ¼ë©´ ì—¬ê¸°ì„œ ë (= ë‹¤ë¥¸ ìºë¦­í„° ê³ ë¥¸ ê²½ìš° ìë™ ì •ì§€)
  if(!src) return;

  const a = new Audio(src);
  a.preload = "auto";
  a.loop = true;
  a.volume = 0.45;

  a.play().then(() => {
    _aiBattleBgm = a;
    _aiBattleBgmKey = key;
  }).catch(err => {
    console.warn("AI battle BGM play blocked:", err);
    _aiBattleBgm = null;
    _aiBattleBgmKey = null;
  });
}

function getAiById(id){
  return AI_OPPONENTS.find(x => x.id === id) || null;
}

function applyPlayArenaThemeByAI(ai){
  // âœ… ì „ì²´ í˜ì´ì§€ ë°°ê²½(ë„¤ê°€ ì›í•˜ëŠ” ë¶€ë¶„)
  const body = document.body;

  // âœ… ê¸°ì¡´ ì¹´ë“œ/ì»¨í…Œì´ë„ˆ í†¤ë„ ê°™ì´ ìœ ì§€
  const arena = playArena || document.getElementById("playArena");

  // --- ì´ˆê¸°í™”(ì„ íƒ í•´ì œ / ì¼ë°˜ ìºë¦­í„° ëŒ€ì „ì¼ ë•Œ) ---
  // body ë°°ê²½ ì´ˆê¸°í™”
  if(body){
    body.style.backgroundImage = "";
    body.style.backgroundSize = "";
    body.style.backgroundPosition = "";
    body.style.backgroundRepeat = "";
    body.style.backgroundAttachment = "";
  }

  // playArena ë°°ê²½ ì´ˆê¸°í™”
  if(arena){
    arena.style.background = "";
    arena.style.backgroundImage = "";
    arena.style.backgroundSize = "";
    arena.style.backgroundPosition = "";
    arena.style.backgroundRepeat = "";
    arena.style.borderColor = "";
    arena.style.backgroundColor = "";
  }

  if(!ai){
    return;
  }

  const overlay = String(ai.theme?.arenaBg || "").trim();
  const img = String(ai.theme?.arenaImage || "").trim();

  // âœ… 1) ì „ì²´ ë°°ê²½ ì ìš© (body)
  if(body && img){
    if(overlay){
      body.style.backgroundImage = `${overlay}, url("${img}")`;
      body.style.backgroundSize = "cover, cover";
      body.style.backgroundPosition = "center, center";
      body.style.backgroundRepeat = "no-repeat, no-repeat";
    }else{
      body.style.backgroundImage = `url("${img}")`;
      body.style.backgroundSize = "cover";
      body.style.backgroundPosition = "center";
      body.style.backgroundRepeat = "no-repeat";
    }
    body.style.backgroundAttachment = "fixed";
  }

  // âœ… 2) ë¡œë¹„ ì¹´ë“œ(playArena)ëŠ” ì‚´ì§ë§Œ í†¤ ì…íˆê¸° (ê°€ë…ì„±ìš©)
  if(arena){
    if(overlay){
      arena.style.background = overlay;
    }else{
      arena.style.background = "rgba(6,8,13,.55)";
    }
    arena.style.borderColor = ai.theme?.border || "rgba(255,255,255,0.14)";
  }
}

// ê°„ë‹¨ ë¼ìš°í„°
function goHome(){
  show(viewHome);
  hide(viewEditor);
  hide(viewLibrary);
  hide(viewPlayMode);
  hide(viewPlay);
  hide(viewMatch);
  if(playBgFrame) playBgFrame.style.display = "none";
  if(playBgmFrame) playBgmFrame.style.display = "none";
  stopCharBattleBgm();
}
function goPlayMode(){
  hide(viewHome);
  hide(viewEditor);
  hide(viewLibrary);
  show(viewPlayMode);
  hide(viewPlay);
  hide(viewMatch);
  if(playBgFrame) playBgFrame.style.display = "none";
  if(playBgmFrame) playBgmFrame.style.display = "none";
  stopCharBattleBgm();
  clearToast(document.getElementById("playModeToast"));
}
function goPlayLobby(){
  hide(viewHome);
  hide(viewEditor);
  hide(viewLibrary);
  hide(viewPlayMode);
  show(viewPlay);
  hide(viewMatch);
  refreshPlayLobbySelectors();
}
function goMatch(){
  hide(viewHome);
  hide(viewEditor);
  hide(viewLibrary);
  hide(viewPlayMode);
  hide(viewPlay);
  show(viewMatch);
}

// ë¡œë¹„ ì…€ë ‰í„° ì±„ìš°ê¸°
function refreshPlayLobbySelectors(){
  if(!playMyChar || !playEnemyChar) return;

  if(playBgFrame) playBgFrame.style.display = (playBattleMode === "char") ? "block" : "none";
  if(playBgmFrame) playBgmFrame.style.display = (playBattleMode === "char") ? "block" : "none";
  refreshPlayBattleBgSelector();
  refreshPlayBattleBgmSelector();
  const list = loadCharList();

  // ë‚´ ìºë¦­í„° ì…€ë ‰íŠ¸
  playMyChar.innerHTML = `<option value="">ë‚´ ìºë¦­í„° ì„ íƒ</option>`;
  for(const c of list){
    const opt = document.createElement("option");
    opt.value = c.id;
    opt.textContent = c.name || "(ì´ë¦„ ì—†ìŒ)";
    playMyChar.appendChild(opt);
  }

  // ìƒëŒ€ ìºë¦­í„° ì…€ë ‰íŠ¸
  playEnemyChar.innerHTML = `<option value="">ìƒëŒ€ ìºë¦­í„° ì„ íƒ</option>`;

  if(playBattleMode === "ai"){
    // AI ëª©ë¡
    const head = document.createElement("option");
    head.value = "";
    head.textContent = "AI ìºë¦­í„° ì„ íƒ";
    playEnemyChar.appendChild(head);

    for(const ai of AI_OPPONENTS){
      const opt = document.createElement("option");
      opt.value = `ai:${ai.id}`;
      opt.textContent = ai.name;
      playEnemyChar.appendChild(opt);
    }
  }else{
    // ì¼ë°˜ ìºë¦­í„° ëª©ë¡
    for(const c of list){
      const opt = document.createElement("option");
      opt.value = c.id;
      opt.textContent = c.name || "(ì´ë¦„ ì—†ìŒ)";
      playEnemyChar.appendChild(opt);
    }
  }

  updatePlayMeta();
}

function summarizeCharForLobby(charId){
  const data = loadCharData(charId);
  if(!data?.core) return "ë°ì´í„° ì—†ìŒ";

  const nm = data.name || data.core?.name || "(ì´ë¦„ ì—†ìŒ)";
  const lv = data.core?.status?.level ?? "?";
  const hp = data.core?.status?.hp ?? "?";
  const spdMin = data.core?.status?.spdMin ?? "?";
  const spdMax = data.core?.status?.spdMax ?? "?";
  const defLv = data.core?.status?.defLv ?? "?";

  const pvN = Array.isArray(data.passives) ? data.passives.length : 0;
  const skN = Array.isArray(data.skills) ? data.skills.length : 0;

  return `${nm}\nì²´ë ¥ ${hp} / ì†ë„ ${spdMin}~${spdMax} / ë°©ì–´ë ˆë²¨ ${defLv}\níŒ¨ì‹œë¸Œ ${pvN}ê°œ / ìŠ¤í‚¬ ${skN}ê°œ`;
}

/* âœ… AI ì„ íƒ ì‹œ ì „ì²´ ë°°ê²½ ì ìš© */
function applyPlayBodyBackground(url){
  if(!url){
    document.body.style.backgroundImage = "";
    document.body.style.backgroundSize = "";
    document.body.style.backgroundPosition = "";
    document.body.style.backgroundRepeat = "";
    document.body.style.backgroundAttachment = "";
    return;
  }

document.body.style.backgroundImage =
  `linear-gradient(rgba(5,6,8,.72), rgba(5,6,8,.78)), url('${url}')`;
  document.body.style.backgroundSize = "cover";
  document.body.style.backgroundPosition = "center";
  document.body.style.backgroundRepeat = "no-repeat";
  document.body.style.backgroundAttachment = "fixed";
}

function getSavedPlayBattleBgId(){
  try{ return localStorage.getItem(KEY_PLAY_BATTLE_BG) || "none"; }catch(_){ return "none"; }
}
function setSavedPlayBattleBgId(id){
  try{ localStorage.setItem(KEY_PLAY_BATTLE_BG, String(id || "none")); }catch(_){ }
}
function getCharBattleBgById(id){
  if(!id || id === "none") return null;
  return CHAR_BATTLE_BACKGROUNDS.find(x => x.id === id) || null;
}
function refreshPlayBattleBgSelector(){
  if(!playBattleBg) return;
  playBattleBg.innerHTML = "";
  const noneOpt = document.createElement("option");
  noneOpt.value = "none";
  noneOpt.textContent = "ë°°ê²½ ì—†ìŒ";
  playBattleBg.appendChild(noneOpt);
  for(const bg of CHAR_BATTLE_BACKGROUNDS){
    const opt = document.createElement("option");
    opt.value = bg.id;
    opt.textContent = bg.name;
    playBattleBg.appendChild(opt);
  }
  playBattleBg.value = getSavedPlayBattleBgId() || "none";
}
function applySelectedCharBattleBg(){
  const bg = getCharBattleBgById(playBattleBg?.value || getSavedPlayBattleBgId());
  if(playBattleBgMeta){
    playBattleBgMeta.textContent = bg ? `${bg.name}
${bg.desc || ""}` : "ìºë¦­í„° ëŒ€ì „ ë°°ê²½ ì—†ìŒ";
  }
  applyPlayBodyBackground(bg?.image || "");
}

function getSavedPlayBattleBgmId(){
  try{ return localStorage.getItem(KEY_PLAY_BATTLE_BGM) || "none"; }catch(_){ return "none"; }
}
function setSavedPlayBattleBgmId(id){
  try{ localStorage.setItem(KEY_PLAY_BATTLE_BGM, String(id || "none")); }catch(_){ }
}
function getCharBattleBgmById(id){
  if(!id || id === "none") return null;
  return CHAR_BATTLE_BGMS.find(x => x.id === id) || null;
}
function refreshPlayBattleBgmSelector(){
  if(!playBattleBgm) return;
  playBattleBgm.innerHTML = "";
  const noneOpt = document.createElement("option");
  noneOpt.value = "none";
  noneOpt.textContent = "ìŒì•… ì—†ìŒ";
  playBattleBgm.appendChild(noneOpt);
  for(const bgm of CHAR_BATTLE_BGMS){
    const opt = document.createElement("option");
    opt.value = bgm.id;
    opt.textContent = bgm.name;
    playBattleBgm.appendChild(opt);
  }
  playBattleBgm.value = getSavedPlayBattleBgmId() || "none";
}
function applySelectedCharBattleBgmMeta(){
  const bgm = getCharBattleBgmById(playBattleBgm?.value || getSavedPlayBattleBgmId());
  if(playBattleBgmMeta){
    playBattleBgmMeta.textContent = bgm ? `${bgm.name}
${bgm.desc || ""}` : "ìºë¦­í„° ëŒ€ì „ ìŒì•… ì—†ìŒ";
  }
}
function stopCharBattleBgm(){
  if(_charBattleBgm){
    try{ _charBattleBgm.pause(); _charBattleBgm.currentTime = 0; }catch(_){ }
  }
  _charBattleBgm = null;
  _charBattleBgmKey = "";
}
function playCharBattleBgmById(id){
  const bgm = getCharBattleBgmById(id || getSavedPlayBattleBgmId());
  if(!bgm){
    stopCharBattleBgm();
    return;
  }
  if(_charBattleBgm && _charBattleBgmKey === bgm.id) return;
  stopCharBattleBgm();
  try{
    const a = new Audio(bgm.audio || "");
    a.preload = "auto";
    a.loop = true;
    a.volume = 0.45;
    a.play().then(()=>{
      _charBattleBgm = a;
      _charBattleBgmKey = bgm.id;
    }).catch(err=>{
      console.warn("Char battle BGM play blocked:", err);
      _charBattleBgm = null;
      _charBattleBgmKey = "";
    });
  }catch(err){
    console.warn("Char battle BGM init failed:", err);
    _charBattleBgm = null;
    _charBattleBgmKey = "";
  }
}

function getAiWaveInfoByEnemyValue(enemyValue){
  if(!enemyValue || !String(enemyValue).startsWith("ai:")) return null;

  const aiId = String(enemyValue).slice(3);
  const boss = AI_BOSSES[aiId];
  if(!boss || !Array.isArray(boss.waves)) return null;

  return boss.waves.map(w => {
    const meta = PREVIEW_CHAR_INFO[w.charId] || null;
    return {
      wave: Number(w.wave || 0),
      type: w.type || "enemy",
      visibleInInfo: !!w.visibleInInfo,
      name: (w.visibleInInfo ? (meta?.name || w.charId) : (boss.name || "???")),
      desc: (w.visibleInInfo
        ? (meta?.summary || "ìƒì„¸ì •ë³´ëŠ” ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ì–´.")
        : "ë³´ìŠ¤ë¼ì„œ ìƒì„¸ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ì–´.")
    };
  });
}

function renderAiWaveInfoPanel(){
  if(!aiWaveInfoList || !playEnemyChar) return;

  const enId = playEnemyChar.value || "";
  const waves = getAiWaveInfoByEnemyValue(enId);

  if(!waves){
    aiWaveInfoList.innerHTML = `<div style="color:rgba(238,241,255,.7);">AI ìƒëŒ€ë¥¼ ë¨¼ì € ì„ íƒí•´ì¤˜.</div>`;
    return;
  }

  const rows = waves.map((w) => {
    const isBoss = (w.visibleInInfo === false) || (w.type === "boss");

    return `
      <div style="border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:10px; margin-bottom:8px; background:rgba(0,0,0,.14);">
        <div style="font-weight:900; color:${isBoss ? 'rgba(255,120,120,.95)' : 'rgba(243,211,154,.95)'};">
          ${w.wave}ì›¨ì´ë¸Œ - ${w.visibleInInfo ? w.name : "???"}
        </div>
        <div style="margin-top:6px; white-space:pre-line; color:rgba(238,241,255,.9);">
          ${isBoss ? "ë³´ìŠ¤ë¼ì„œ ìƒì„¸ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ì–´." : (w.desc || "ìƒì„¸ì •ë³´ ì—†ìŒ")}
        </div>
      </div>
    `;
  }).join("");

  aiWaveInfoList.innerHTML = rows;
}

function updatePlayMeta(){
  const myMeta = playMyCharMeta;
  const enemyMeta = playEnemyCharMeta;
  if(!myMeta || !enemyMeta || !playMyChar || !playEnemyChar) return;

  // ë‚´ ìºë¦­í„° ë©”íƒ€
  const myId = playMyChar.value || "";
  if(myId){
    myMeta.textContent = summarizeCharForLobby(myId);
  }else{
    myMeta.textContent = "ë‚´ ìºë¦­í„°ë¥¼ ì„ íƒí•´ì¤˜.";
  }

  // ìƒëŒ€ ìºë¦­í„° ë©”íƒ€ + AI ë°°ê²½
  const enId = playEnemyChar.value || "";

  if(!enId){
    enemyMeta.textContent = (playBattleMode === "ai")
      ? "AI ìºë¦­í„°ë¥¼ ì„ íƒí•´ì¤˜."
      : "ìƒëŒ€ ìºë¦­í„°ë¥¼ ì„ íƒí•´ì¤˜.";
    lastPlayedAiVoiceId = "";
    playAiBattleBgm("");
    applyPlayBodyBackground("");
    if(aiWaveInfoPanel && !aiWaveInfoPanel.classList.contains("hidden")){
      renderAiWaveInfoPanel();
    }
    if(playBattleMode !== "ai"){
      if(playBgFrame) playBgFrame.style.display = "block";
      if(playBgmFrame) playBgmFrame.style.display = "block";
      applySelectedCharBattleBg();
      applySelectedCharBattleBgmMeta();
    }
    return;
  }

  // AI ìƒëŒ€
  if(enId.startsWith("ai:")){
    if(playBgFrame) playBgFrame.style.display = "none";
    if(playBgmFrame) playBgmFrame.style.display = "none";
    stopCharBattleBgm();
    const aiId = enId.slice(3);
    const ai = AI_OPPONENTS.find(x => x.id === aiId);

    if(ai){
if(lastPlayedAiVoiceId !== ai.id){
  if(ai.id === "ai_lei_heng"){
    playLeiHengSelectVoice();   // âœ… ì„ íƒ ìŒì„±
  }
  playAiBattleBgm(ai.id);       // âœ… ì „íˆ¬ ë¸Œê¸ˆ
  lastPlayedAiVoiceId = ai.id;
}

      if(ai.id === "ai_lei_heng"){
        enemyMeta.innerHTML = `
          <span class="aiNameLei">${ai.name}</span>
          <span class="aiSubLei">${ai.sub || ""}</span>

          ë‚œì´ë„/í•µì‹¬ì •ë³´ëŠ” ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ë¶™ì¼ ì˜ˆì •
        `;
      }else{
        enemyMeta.textContent =
          `${ai.name}\n${ai.sub || ""}\n\në‚œì´ë„/í•µì‹¬ì •ë³´ëŠ” ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ë¶™ì¼ ì˜ˆì •`;
      }

      if(ai.id === "ai_lei_heng"){
        applyPlayBodyBackground("assets/bg_ai_leiheng_train.png");
      }else{
        applyPlayBodyBackground("");
      }
    }else{
      enemyMeta.textContent = "AI ë°ì´í„°ë¥¼ ì°¾ì§€ ëª»í–ˆì–´.";
      applyPlayBodyBackground("");
    }

    // âœ… ì´ë¯¸ì§€ 4ë²ˆì—ì„œ ë§í•œ "íŒ¨ë„ ìë™ ê°±ì‹ " ìœ„ì¹˜
    if(aiWaveInfoPanel && !aiWaveInfoPanel.classList.contains("hidden")){
      renderAiWaveInfoPanel();
    }
    return;
  }

  // ì¼ë°˜ ìƒëŒ€ ìºë¦­í„°
  enemyMeta.textContent = summarizeCharForLobby(enId);
  if(playBgFrame) playBgFrame.style.display = "block";
  if(playBgmFrame) playBgmFrame.style.display = "block";
  applySelectedCharBattleBg();
  applySelectedCharBattleBgmMeta();
  playAiBattleBgm("");

  // âœ… ì¼ë°˜ ìºë¦­í„°ë¡œ ë°”ë€Œì–´ë„ íŒ¨ë„ ë‚´ìš© ê°±ì‹ 
  if(aiWaveInfoPanel && !aiWaveInfoPanel.classList.contains("hidden")){
    renderAiWaveInfoPanel();
  }
}

playMyChar?.addEventListener("change", updatePlayMeta);
playEnemyChar?.addEventListener("change", updatePlayMeta);
playBattleBg?.addEventListener("change", ()=>{
  setSavedPlayBattleBgId(playBattleBg.value || "none");
  if(playBattleMode !== "ai") applySelectedCharBattleBg();
});
playBattleBgm?.addEventListener("change", ()=>{
  setSavedPlayBattleBgmId(playBattleBgm.value || "none");
  if(playBattleMode !== "ai"){
    applySelectedCharBattleBgmMeta();
    playCharBattleBgmById(playBattleBgm.value || getSavedPlayBattleBgmId());
  }
});
btnAiWaveInfo?.addEventListener("click", () => {
  if(!aiWaveInfoPanel) return;
  aiWaveInfoPanel.classList.remove("hidden");
  renderAiWaveInfoPanel();
});

btnAiWaveInfoClose?.addEventListener("click", () => {
  aiWaveInfoPanel?.classList.add("hidden");
});

// HOME: í”Œë ˆì´ ë²„íŠ¼ -> ë¡œë¹„
document.getElementById("btn-play").addEventListener("click", () => {
  goPlayMode();
});

// í”Œë ˆì´ ì„ íƒ í™”ë©´ ë²„íŠ¼ë“¤
document.getElementById("btn-play-mode-back")?.addEventListener("click", goHome);

document.getElementById("btn-play-char")?.addEventListener("click", () => {
  playBattleMode = "char";
  goPlayLobby();
});

document.getElementById("btn-play-ai")?.addEventListener("click", () => {
  playBattleMode = "ai";
  if(playBgFrame) playBgFrame.style.display = "none";
  if(playBgmFrame) playBgmFrame.style.display = "none";
  stopCharBattleBgm();
  goPlayLobby();
});

// ë¡œë¹„ ë²„íŠ¼ë“¤
document.getElementById("btn-play-back")?.addEventListener("click", goHome);

document.getElementById("btn-play-random")?.addEventListener("click", () => {
if(playBattleMode === "ai"){
  if(AI_OPPONENTS.length === 0) return;

  const pick = AI_OPPONENTS[Math.floor(Math.random() * AI_OPPONENTS.length)];
  playEnemyChar.value = `ai:${pick.id}`;
  updatePlayMeta();
  toast(playToast, `AI ëœë¤ ì„ íƒ: ${pick.name}`);
  return;
}

  const list = loadCharList();
  if(list.length === 0) return;
  const pick = list[Math.floor(Math.random() * list.length)];
  playEnemyChar.value = pick.id;
  updatePlayMeta();
  toast(playToast, `ìƒëŒ€ ëœë¤ ì„ íƒ: ${pick.name || "(ì´ë¦„ ì—†ìŒ)"}`);
});



document.getElementById("btn-start-match")?.addEventListener("click", async () => {
  const myId = playMyChar?.value || "";
  const enId = playEnemyChar?.value || "";

  if(!myId || !enId){
    toast(playToast, "ë‚´ ìºë¦­í„°/ìƒëŒ€ë¥¼ ì„ íƒí•´ì•¼ í•´.");
    return;
  }

  const my = loadCharData(myId);
  const myName = my?.name || my?.core?.name || "ë‚˜";

  // ===== AI ëŒ€ì „ =====
  if(playBattleMode === "ai"){
    const aiId = enId.startsWith("ai:") ? enId.slice(3) : enId;
    const ai = getAiById(aiId);
    if(!ai){
      toast(playToast, "AI ìƒëŒ€ë¥¼ ì„ íƒí•´ì¤˜.");
      return;
    }

matchTitle.textContent = `${myName}  VS  ${ai.name}`;
matchLog.textContent = "";

// enemyDataë¥¼ ì‹¤ì œ í‘œì‹œìš©ìœ¼ë¡œ ì¤€ë¹„
const bossDef2 = AI_BOSSES?.[ai.id];
let enemyDisplayData = null;

// 1) ì›¨ì´ë¸Œ ì²« í‘œì‹œ ëŒ€ìƒì˜ "ì‹¤ì œ ìºë¦­í„° ì €ì¥ ë°ì´í„°" ìš°ì„  ì‚¬ìš©
if (bossDef2 && Array.isArray(bossDef2.waves) && bossDef2.waves.length) {
  const firstVisible = bossDef2.waves.find(w => w.visibleInInfo !== false) || bossDef2.waves[0];
  const waveCharId = firstVisible?.charId;

// âœ… 1ìˆœìœ„: ì €ì¥ëœ ìºë¦­í„° ë°ì´í„°
const savedEnemyChar = waveCharId ? loadCharData(waveCharId) : null;
if (savedEnemyChar) {
  enemyDisplayData = savedEnemyChar;
} else {
  // âœ… 2ìˆœìœ„: Ai í´ë” JSON ì§ì ‘ ë¡œë“œ (ë¡œì»¬ ì„œë²„ì—ì„œ ì‹¤í–‰ ì‹œ)
  try {
    // waveCharId ê¸°ì¤€ìœ¼ë¡œ íŒŒì¼ëª… ë§¤í•‘
    const AI_JSON_PATHS = {
      "thumb_soldato_2": "Ai/ê° ì¡íŒ ì—„ì§€ ì†”ë‹¤í†  II.limbuschar.json",
      "thumb_soldato_3": "Ai/ê° ì¡íŒ ì—„ì§€ ì†”ë‹¤í†  III.limbuschar.json", // IIIë„ ë§Œë“¤ë©´ ì´ ê²½ë¡œ ì‚¬ìš©
    };

    const jsonPath = AI_JSON_PATHS[waveCharId];
    if (jsonPath) {
      const res = await fetch(jsonPath);
      if (res.ok) {
        const json = await res.json();
        if (json?.char) {
          enemyDisplayData = json.char;

          // ì´ˆìƒ ê²½ë¡œ ê°•ì œ ì§€ì • (II/III ê³µìš©)
          enemyDisplayData.core = enemyDisplayData.core || {};
          enemyDisplayData.core.portraitUrl = "assets/char_thumb_soldato_23.png";
        }
      }
    }
  } catch (e) {
    console.warn("AI JSON ë¡œë“œ ì‹¤íŒ¨:", e);
  }

  // âœ… 3ìˆœìœ„: PREVIEW summary íŒŒì‹± fallback
  if (!enemyDisplayData) {
    const preview = PREVIEW_CHAR_INFO?.[waveCharId];
    if (preview) {
      enemyDisplayData = parsePreviewSummaryToBattleData(preview, ai.name);
      enemyDisplayData.core = enemyDisplayData.core || {};
      enemyDisplayData.core.portraitUrl = "assets/char_thumb_soldato_23.png";
    }
  }
}
}

// 2) ê·¸ë˜ë„ ì—†ìœ¼ë©´ ìµœì†Œ ë”ë¯¸ ë°ì´í„°
if (!enemyDisplayData) {
  enemyDisplayData = {
    name: ai.name || "ì ",
    core: {
      name: ai.name || "ì ",
      hp: "-",
      atkLevel: "-",
      defLevel: "-",
      sanity: "-",
      speedMin: 1,
      speedMax: 6,
      skillSlots: 1,
      physRes: {},
      sinRes: {},
      staggerThresholds: []
    },
    passives: [],
    skills: [],
    dedicatedKeywords: []
  };
}
await initMatchScreenData({
  myData: my,
  enemyData: enemyDisplayData,
  enemyIsAi: true,
  enemyAiMeta: ai
});



goMatch();
return;
  }

  // ===== ìºë¦­í„° ëŒ€ì „ =====
  if(myId === enId){
    toast(playToast, "ë‚´ ìºë¦­í„°ì™€ ìƒëŒ€ê°€ ê°™ì•„. ë‹¤ë¥¸ ìºë¦­í„°ë¥¼ ê³¨ë¼ì¤˜.");
    return;
  }

  const en = loadCharData(enId);
  const enName = en?.name || en?.core?.name || "ìƒëŒ€";

matchTitle.textContent = `${myName}  VS  ${enName}`;
matchLog.textContent = "";
matchLog.textContent += `ë§¤ì¹˜ ì‹œì‘!\n- ë‚´ ìºë¦­í„°: ${myName}\n- ìƒëŒ€: ${enName}\n`;

await initMatchScreenData({
  myData: my,
  enemyData: en,
  enemyIsAi: false,
  enemyAiMeta: null
});

applySelectedCharBattleBg();
playCharBattleBgmById(playBattleBgm?.value || getSavedPlayBattleBgmId());
goMatch();
});

document.getElementById("btn-go-editor").addEventListener("click", () => {
  setAppMode("edit");               // âœ… ì¶”ê°€
  hide(viewHome); show(viewEditor);
  clearToast(homeToast);
  selectTab("core");
  document.getElementById("charName").focus();
});

    document.getElementById("btn-back").addEventListener("click", () => {
      hide(viewEditor); show(viewHome);
      clearToast(homeToast);
    });

    // ===== tabs =====
    const tabs = {
      core: document.getElementById("tab-core"),
      passive: document.getElementById("tab-passive"),
      skill: document.getElementById("tab-skill"),
      dk: document.getElementById("tab-dk"),
    };
    const panels = {
      core: document.getElementById("panel-core"),
      passive: document.getElementById("panel-passive"),
      skill: document.getElementById("panel-skill"),
      dk: document.getElementById("panel-dk"),
    };
    function selectTab(key){
      Object.entries(tabs).forEach(([k,btn]) => btn.classList.toggle("active", k === key));
      Object.entries(panels).forEach(([k,p]) => p.classList.toggle("hidden", k !== key));
    }
    tabs.core.addEventListener("click", () => selectTab("core"));
    tabs.passive.addEventListener("click", () => selectTab("passive"));
    tabs.skill.addEventListener("click", () => selectTab("skill"));
    tabs.dk.addEventListener("click", () => selectTab("dk"));

// âœ… ë¶€íŒ… ì‹œ 1íšŒ: ì—ë””í„° ìë™ ì˜¤í”ˆ
(() => {
  const flag = localStorage.getItem("limbus_open_editor_boot");
  if(!flag) return;
  localStorage.removeItem("limbus_open_editor_boot");

  // ì—ë””í„° í™”ë©´ìœ¼ë¡œ ê°•ì œ ì§„ì…
  hide(viewHome);
  if(typeof viewLibrary !== "undefined") hide(viewLibrary); // í˜¹ì‹œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—´ë ¤ìˆì„ ìˆ˜ë„ ìˆì–´ì„œ
  show(viewEditor);

  // ê¸°ë³¸ íƒ­(ì›í•˜ë©´ passiveë¡œ ë°”ê¿”ë„ ë¨)
  selectTab("core");
})();

// âœ… ë¶€íŒ… ì‹œ: ë³´ê¸° ëª¨ë“œë©´ ì—ë””í„° í™”ë©´ + ì½”ì–´ íƒ­ ê°•ì œ
(() => {
  if (APP_MODE !== "view") return;

  // í™ˆ/ë¼ì´ë¸ŒëŸ¬ë¦¬ ìˆ¨ê¸°ê³  ì—ë””í„° í‘œì‹œ
  hide(viewHome);
  if (typeof viewLibrary !== "undefined") hide(viewLibrary);
  show(viewEditor);

  // ë³´ê¸° ëª¨ë“œëŠ” í•­ìƒ ì½”ì–´ íƒ­ë¶€í„°
  selectTab("core");
})();



    // ===== portrait upload preview =====
    const fileInput = document.getElementById("fileInput");
    const portraitImg = document.getElementById("portraitImg");
    const portraitPh = document.getElementById("portraitPh");
    const btnClearImg = document.getElementById("btnClearImg");

    function setPortrait(src){
      if(!src){
        portraitImg.style.display = "none";
        portraitImg.src = "";
        portraitPh.style.display = "block";
        return;
      }
      portraitImg.src = src;
      portraitImg.style.display = "block";
      portraitPh.style.display = "none";
    }

    // âœ… CORE portrait: IndexedDB í‚¤
    let corePortraitKey = "";

    // âœ… ì´ˆìƒí™” ì—…ë¡œë“œ: IndexedDBì— Blobìœ¼ë¡œ ì˜êµ¬ ì €ì¥
    fileInput.addEventListener("change", async (e) => {
      const f = e.target.files && e.target.files[0];
      if(!f) return;

      try{
        const dataURL = await compressImageToDataURL(f, {
          maxSize: 1024,
          mime: "image/webp",
          quality: 0.90
        });
        const blob = dataURLToBlob(dataURL);

        corePortraitKey = "core_portrait_v1";
        await idbPutBlob(corePortraitKey, blob);

        setPortraitFromObjectURL(makeObjectURLFromBlob(blob));
        toast(coreToast, "ì´ˆìƒí™” ì €ì¥ë¨(ì˜êµ¬).");
      }catch(err){
        console.error(err);
        toast(coreToast, "ì´ˆìƒí™” ì €ì¥ ì‹¤íŒ¨(ë¸Œë¼ìš°ì € ì œí•œ/íŒŒì¼ ë¬¸ì œì¼ ìˆ˜ ìˆì–´).");
      }
    });

    btnClearImg.addEventListener("click", async () => {
      fileInput.value = "";
      setPortrait("");
      if(corePortraitKey){
        try{ await idbDel(corePortraitKey); }catch(e){}
      }
      corePortraitKey = "";
      toast(coreToast, "ì´ˆìƒí™” ì œê±° ì™„ë£Œ!");
    });

    // ===== resistance options / coeff / tones =====
    const OPTIONS = ["ë‚´ì„±", "ê²¬ë”¤", "ë³´í†µ", "ì•½ì ", "ì·¨ì•½"];
    const MULT = { "ë‚´ì„±":0.5, "ê²¬ë”¤":0.75, "ë³´í†µ":1.0, "ì•½ì ":1.5, "ì·¨ì•½":2.0 };

    function toneOf(v){
      if(v === "ì•½ì " || v === "ì·¨ì•½") return "tone-red";
      if(v === "ë‚´ì„±" || v === "ê²¬ë”¤") return "tone-gray";
      return "tone-normal";
    }
    function setTone(el, tone){
      el.classList.remove("tone-red","tone-gray","tone-normal");
      el.classList.add(tone);
    }
    function fmtCoef(v){
      const n = MULT[v] ?? 1.0;
      return `[x${n.toFixed(n % 1 === 0 ? 1 : 2)}]`;
    }
    function fillSelect(selectEl, defaultValue, onChange){
      selectEl.innerHTML = "";
      for(const opt of OPTIONS){
        const o = document.createElement("option");
        o.value = opt;
        o.textContent = opt;
        selectEl.appendChild(o);
      }
      selectEl.value = defaultValue || "ë³´í†µ";
      selectEl.addEventListener("change", onChange);
      onChange();
    }

    // physical
    const physSlash = document.getElementById("physSlash");
    const physPierce = document.getElementById("physPierce");
    const physBlunt = document.getElementById("physBlunt");
    const coef_physSlash = document.getElementById("coef_physSlash");
    const coef_physPierce = document.getElementById("coef_physPierce");
    const coef_physBlunt = document.getElementById("coef_physBlunt");

    function physUpdate(selectEl, coefEl){
      const box = selectEl.closest(".physBox");
      setTone(box, toneOf(selectEl.value));
      coefEl.textContent = fmtCoef(selectEl.value);
    }
    fillSelect(physSlash, "ë³´í†µ", () => physUpdate(physSlash, coef_physSlash));
    fillSelect(physPierce, "ë³´í†µ", () => physUpdate(physPierce, coef_physPierce));
    fillSelect(physBlunt, "ë³´í†µ", () => physUpdate(physBlunt, coef_physBlunt));

    // sins
    const sinIds = [
      ["sinWrath","coef_sinWrath"],
      ["sinLust","coef_sinLust"],
      ["sinSloth","coef_sinSloth"],
      ["sinGluttony","coef_sinGluttony"],
      ["sinGloom","coef_sinGloom"],
      ["sinPride","coef_sinPride"],
      ["sinEnvy","coef_sinEnvy"],
    ];
    for(const [selId, coefId] of sinIds){
      const sel = document.getElementById(selId);
      const coef = document.getElementById(coefId);
      fillSelect(sel, "ë³´í†µ", () => {
        setTone(sel.closest(".sinBox"), toneOf(sel.value));
        coef.textContent = fmtCoef(sel.value);
      });
    }

    // ===== stagger =====
    const markerLayer = document.getElementById("markerLayer");
    const tickLayer = document.getElementById("tickLayer");
    const btnAddStagger = document.getElementById("btnAddStagger");
    const btnDelStagger = document.getElementById("btnDelStagger");
    let staggers = [];

    function normalizePercent(input){
      const n = Number(String(input).trim());
      if(!Number.isFinite(n)) return null;
      if(n <= 0 || n >= 100) return null;
      return Math.round(n);
    }
    function renderStaggers(){
      markerLayer.innerHTML = "";
      tickLayer.innerHTML = "";
      const sorted = [...staggers].sort((a,b)=>a-b);
      for(const p of sorted){
        const m = document.createElement("div");
        m.className = "marker";
        m.style.left = `${p}%`;
        markerLayer.appendChild(m);

        const t = document.createElement("div");
        t.className = "tick";
        t.style.left = `${p}%`;
        t.textContent = `${p}%`;
        tickLayer.appendChild(t);
      }
    }
    btnDelStagger.addEventListener("click", () => { staggers = []; renderStaggers(); });
    btnAddStagger.addEventListener("click", () => {
      const ans = prompt("ëª‡ %ì— ííŠ¸ëŸ¬ì§ êµ¬ê°„ì„ ì¶”ê°€í• ê¹Œ? (1~99)");
      if(ans === null) return;
      const p = normalizePercent(ans);
      if(p === null){ alert("1~99 ì‚¬ì´ ìˆ«ìë¡œ ì…ë ¥í•´ì¤˜."); return; }
      if(staggers.includes(p)){ alert("ì´ë¯¸ ìˆëŠ” êµ¬ê°„ì´ì•¼."); return; }
      staggers.push(p);
      renderStaggers();
    });
    renderStaggers();

    // ===== íŠ¹ì„± í‚¤ì›Œë“œ =====
    const traitKwList = document.getElementById("traitKwList");
    const btnTraitKwAdd = document.getElementById("btnTraitKwAdd");

    function makeTraitRow(data = { text:"", deleted:false }){
      const row = document.createElement("div");
      row.className = "kwRow" + (data.deleted ? " deleted" : "");

      const input = document.createElement("input");
      input.className = "kwInput";
      input.type = "text";
      input.value = data.text || "";

      const btnToggle = document.createElement("button");
      btnToggle.type = "button";
      btnToggle.className = "btnSmall";
      btnToggle.textContent = data.deleted ? "í‚¤ì›Œë“œ ë³µêµ¬" : "í‚¤ì›Œë“œ ì§€ìš°ê¸°";

      const btnDel = document.createElement("button");
      btnDel.type = "button";
      btnDel.className = "btnSmall";
      btnDel.textContent = "ì‚­ì œ";

      btnToggle.addEventListener("click", () => {
        const isDeleted = row.classList.toggle("deleted");
        btnToggle.textContent = isDeleted ? "í‚¤ì›Œë“œ ë³µêµ¬" : "í‚¤ì›Œë“œ ì§€ìš°ê¸°";
      });

      btnDel.addEventListener("click", () => row.remove());

      row.appendChild(input);
      row.appendChild(btnToggle);
      row.appendChild(btnDel);
      return row;
    }

    btnTraitKwAdd.addEventListener("click", () => {
      traitKwList.appendChild(makeTraitRow());
    });
    traitKwList.appendChild(makeTraitRow());

    // ===== core save/reset =====
    const coreToast = document.getElementById("coreToast");
// ===== sanity effect (ì •ì‹ ë ¥ íš¨ê³¼) =====
const sanityFxFile = document.getElementById("sanityFxFile");
const sanityFxImg = document.getElementById("sanityFxImg");
const sanityFxPh = document.getElementById("sanityFxPh");
const btnClearSanityFxImg = document.getElementById("btnClearSanityFxImg");

const sanityPanicText = document.getElementById("sanityPanicText");
const sanityGainText = document.getElementById("sanityGainText");
const sanityLossText = document.getElementById("sanityLossText");

let sanityFxKey = "";              // IndexedDBì— ì €ì¥ëœ ì´ë¯¸ì§€ í‚¤
let sanityFxPendingDataURL = "";   // ì•„ì§ ì €ì¥ ì•ˆ í•œ ì„ì‹œ ì´ë¯¸ì§€(dataURL)

function setSanityFxPreview(src){
  if(!src){
    sanityFxImg.style.display = "none";
    sanityFxImg.src = "";
    sanityFxPh.style.display = "block";
    return;
  }
  sanityFxImg.src = src;
  sanityFxImg.style.display = "block";
  sanityFxPh.style.display = "none";
}

sanityFxFile?.addEventListener("change", async (e) => {
  const f = e.target.files && e.target.files[0];
  if(!f) return;

  try{
    sanityFxPendingDataURL = await compressImageToDataURL(f, {
      maxSize: 900,
      mime: "image/webp",
      quality: 0.88
    });
    setSanityFxPreview(sanityFxPendingDataURL);
    toast(coreToast, "ì •ì‹ ë ¥ íš¨ê³¼ ì´ë¯¸ì§€ ì„ íƒë¨. 'ì €ì¥'ì„ ëˆ„ë¥´ë©´ ë°˜ì˜ë¼.");
  }catch(err){
    console.error(err);
    toast(coreToast, "ì •ì‹ ë ¥ íš¨ê³¼ ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹¤íŒ¨.");
  }
});

btnClearSanityFxImg?.addEventListener("click", async () => {
  sanityFxFile.value = "";
  sanityFxPendingDataURL = "";
  setSanityFxPreview("");

  if(sanityFxKey){
    try{ await idbDel(sanityFxKey); }catch(e){}
    sanityFxKey = "";
  }
});

    function readTraitKeywords(){
      const rows = [...traitKwList.querySelectorAll(".kwRow")];
      return rows.map(r => ({
        text: r.querySelector(".kwInput")?.value ?? "",
        deleted: r.classList.contains("deleted")
      }));
    }
    function loadTraitKeywords(list){
      traitKwList.innerHTML = "";
      if(!Array.isArray(list) || list.length === 0){
        traitKwList.appendChild(makeTraitRow());
        return;
      }
      for(const it of list) traitKwList.appendChild(makeTraitRow(it));
    }

    document.getElementById("btnSaveCore").addEventListener("click", async () => {
      // ì •ì‹ ë ¥ íš¨ê³¼ ì´ë¯¸ì§€ê°€ ìƒˆë¡œ ì„ íƒëœ ìƒíƒœë©´ ì €ì¥ ì „ì— IndexedDBì— ë¨¼ì € ë„£ê¸°
      if(sanityFxPendingDataURL && String(sanityFxPendingDataURL).startsWith("data:image/")){
        try{
          const blob = dataURLToBlob(sanityFxPendingDataURL);
          sanityFxKey = "core_sanity_fx_v1";
          await idbPutBlob(sanityFxKey, blob);
          sanityFxPendingDataURL = "";
        }catch(e){
          console.error("sanity fx save fail:", e);
          toast(coreToast, "ì •ì‹ ë ¥ íš¨ê³¼ ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨.");
          return;
        }
      }
      const prev = activeSkId ? skills.find(x => x.id === activeSkId) : null;

    const payload = {
        name: document.getElementById("charName").value,
        portraitKey: corePortraitKey || "", // âœ… ì´ë¯¸ì§€ ë¬¸ìì—´ ëŒ€ì‹  í‚¤ë§Œ ì €ì¥
        staggers: [...staggers],
        status: {
          level: document.getElementById("statLevel").value,
          hp: document.getElementById("statHp").value,
          spdMin: document.getElementById("statSpdMin").value,
          spdMax: document.getElementById("statSpdMax").value,
          defLv: document.getElementById("statDefLv").value,
        },
        phys: { slash: physSlash.value, pierce: physPierce.value, blunt: physBlunt.value },
        sins: Object.fromEntries(sinIds.map(([sid]) => [sid, document.getElementById(sid).value])),
        trait_keywords: readTraitKeywords(),
        sanity: {
          imgKey: sanityFxKey || "",
          panic: sanityPanicText?.value || "",
          gain: sanityGainText?.value || "",
          loss: sanityLossText?.value || ""
        },
      };
      try{
        localStorage.setItem(KEY_CORE, JSON.stringify(payload));
        toast(coreToast, "ì €ì¥ ì™„ë£Œ!");
      }catch(e){
        toast(coreToast, "ì €ì¥ ì‹¤íŒ¨: ì €ì¥ê³µê°„ ì œí•œì¼ ìˆ˜ ìˆì–´.");
      }
    });

    document.getElementById("btnResetCore").addEventListener("click", async () => {
      document.getElementById("charName").value = "";
      fileInput.value = "";
      setPortrait("");

      if(corePortraitKey){
        try{ await idbDel(corePortraitKey); }catch(e){}
      }
      corePortraitKey = "";

      staggers = [];
      renderStaggers();

      document.getElementById("statLevel").value = "";
      document.getElementById("statHp").value = "";
      document.getElementById("statSpdMin").value = "";
      document.getElementById("statSpdMax").value = "";
      document.getElementById("statDefLv").value = "";

      physSlash.value = "ë³´í†µ"; physUpdate(physSlash, coef_physSlash);
      physPierce.value = "ë³´í†µ"; physUpdate(physPierce, coef_physPierce);
      physBlunt.value = "ë³´í†µ"; physUpdate(physBlunt, coef_physBlunt);

      for(const [sid, cid] of sinIds){
        const sel = document.getElementById(sid);
        const coef = document.getElementById(cid);
        sel.value = "ë³´í†µ";
        setTone(sel.closest(".sinBox"), "tone-normal");
        coef.textContent = fmtCoef("ë³´í†µ");
      }

      // ì •ì‹ ë ¥ íš¨ê³¼ ì´ˆê¸°í™”
      sanityPanicText.value = "";
      sanityGainText.value = "";
      sanityLossText.value = "";
      sanityFxFile.value = "";
      setSanityFxPreview("");
      sanityFxPendingDataURL = "";

      if(sanityFxKey){
        try{ await idbDel(sanityFxKey); }catch(e){}
      }
      sanityFxKey = "";

      loadTraitKeywords([]);
      localStorage.removeItem(KEY_CORE);
      toast(coreToast, "ì´ˆê¸°í™” ì™„ë£Œ!");
    });

    // load core (async + êµ¬ë²„ì „ ë§ˆì´ê·¸ë ˆì´ì…˜)
    (async () => {
      try{
        const saved = JSON.parse(localStorage.getItem(KEY_CORE) || "null");
        if(!saved) return;

        document.getElementById("charName").value = saved.name || "";

        corePortraitKey = saved.portraitKey || "";

        // âœ… êµ¬ë²„ì „: saved.portrait(dataURL) -> IndexedDBë¡œ ì´ê´€
        if(!corePortraitKey && saved.portrait && String(saved.portrait).startsWith("data:image/")){
          try{
            const blob = dataURLToBlob(saved.portrait);
            corePortraitKey = "core_portrait_v1";
            await idbPutBlob(corePortraitKey, blob);

            saved.portraitKey = corePortraitKey;
            delete saved.portrait;
            localStorage.setItem(KEY_CORE, JSON.stringify(saved));
          }catch(e){
            console.error("portrait migrate fail:", e);
          }
        }

        if(corePortraitKey){
          const blob = await idbGetBlob(corePortraitKey);
          if(blob){
            setPortraitFromObjectURL(makeObjectURLFromBlob(blob));
          }else{
            setPortrait("");
          }
        }else{
          setPortrait("");
        }

        if(Array.isArray(saved.staggers)){
          staggers = saved.staggers.map(normalizePercent).filter((x)=>typeof x === "number");
          staggers = [...new Set(staggers)];
        }
        renderStaggers();

        if(saved.status){
          document.getElementById("statLevel").value = saved.status.level ?? "";
          document.getElementById("statHp").value = saved.status.hp ?? "";
          document.getElementById("statSpdMin").value = saved.status.spdMin ?? "";
          document.getElementById("statSpdMax").value = saved.status.spdMax ?? "";
          document.getElementById("statDefLv").value = saved.status.defLv ?? "";
        }
        if(saved.phys){
          physSlash.value = saved.phys.slash || "ë³´í†µ"; physUpdate(physSlash, coef_physSlash);
          physPierce.value = saved.phys.pierce || "ë³´í†µ"; physUpdate(physPierce, coef_physPierce);
          physBlunt.value = saved.phys.blunt || "ë³´í†µ"; physUpdate(physBlunt, coef_physBlunt);
        }
        if(saved.sins){
          for(const [sid, cid] of sinIds){
            const sel = document.getElementById(sid);
            const coef = document.getElementById(cid);
            sel.value = saved.sins[sid] || "ë³´í†µ";
            setTone(sel.closest(".sinBox"), toneOf(sel.value));
            coef.textContent = fmtCoef(sel.value);
          }
        }
        loadTraitKeywords(saved.trait_keywords || []);
        // ì •ì‹ ë ¥ íš¨ê³¼ ë¶ˆëŸ¬ì˜¤ê¸°
        sanityPanicText.value = saved?.sanity?.panic ?? "";
        sanityGainText.value = saved?.sanity?.gain ?? "";
        sanityLossText.value = saved?.sanity?.loss ?? "";

        sanityFxPendingDataURL = "";
        sanityFxKey = saved?.sanity?.imgKey || "";
        setSanityFxPreview("");

        if(sanityFxKey){
          try{
            const blob = await idbGetBlob(sanityFxKey);
            if(blob){
              setSanityFxPreview(makeObjectURLFromBlob(blob));
            }else{
              setSanityFxPreview("");
            }
          }catch(e){
            console.error("sanity fx load fail:", e);
            setSanityFxPreview("");
          }
        }
        if(APP_MODE === "view") applyViewCoreUI();
      }catch(e){
        console.error("core load fail:", e);
      }
    })();

/* âœ… ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì¦ˆ+ì••ì¶• -> dataURL ë°˜í™˜ */
async function compressImageToDataURL(file, {
  maxSize = 256,       // ì•„ì´ì½˜ì€ 128~256 ì¶”ì²œ, ì´ˆìƒí™”ëŠ” 768~1400
  mime = "image/webp", // webp ë¯¸ì§€ì›ì´ë©´ ìë™ìœ¼ë¡œ jpegë¡œ ë‚´ë ¤ê°
  quality = 0.82
} = {}){
  const dataURL = await new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = () => res(String(r.result || ""));
    r.onerror = rej;
    r.readAsDataURL(file);
  });

  const img = await new Promise((res, rej) => {
    const im = new Image();
    im.onload = () => res(im);
    im.onerror = rej;
    im.src = dataURL;
  });

  const ow = img.naturalWidth || img.width;
  const oh = img.naturalHeight || img.height;

  const scale = Math.min(1, maxSize / Math.max(ow, oh));
  const w = Math.max(1, Math.round(ow * scale));
  const h = Math.max(1, Math.round(oh * scale));

  const canvas = document.createElement("canvas");
  canvas.width = w;
  canvas.height = h;

  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.drawImage(img, 0, 0, w, h);

  let out = canvas.toDataURL(mime, quality);
  if(mime === "image/webp" && !out.startsWith("data:image/webp")){
    out = canvas.toDataURL("image/jpeg", quality);
  }
  return out;
}

    const dkToast = document.getElementById("dkToast");

    const dkIconFile = document.getElementById("dkIconFile");
    const dkIconImg = document.getElementById("dkIconImg");
    const dkIconPh = document.getElementById("dkIconPh");
    const dkIconClear = document.getElementById("dkIconClear");

    const dkName = document.getElementById("dkName");
    const dkText = document.getElementById("dkText");
    const dkStateBtn = document.getElementById("dkStateBtn");
    const dkSaveBtn = document.getElementById("dkSaveBtn");
    const dkDeleteBtn = document.getElementById("dkDeleteBtn");
    const dkAddBtn = document.getElementById("dkAddBtn");
    const dkList = document.getElementById("dkList");

    /** @type {{id:string, name:string, text:string, state:'buff'|'debuff', iconKey:string}[]} */
    let dks = [];
    let activeDkId = null;
    let dkPendingIcon = "";

    function uid(){
      return Math.random().toString(16).slice(2) + Date.now().toString(16);
    }

    function setDkIcon(src){
      if(!src){
        dkIconImg.style.display = "none";
        dkIconImg.src = "";
        dkIconPh.style.display = "block";
        return;
      }
      dkIconImg.src = src;
      dkIconImg.style.display = "block";
      dkIconPh.style.display = "none";
    }

    // ì—…ë¡œë“œ: ì¼ë‹¨ pending(dataURL)ë¡œë§Œ ì¡ì•„ë‘ê³ , "ì €ì¥" ëˆŒë €ì„ ë•Œ DBì— ì €ì¥
    dkIconFile.addEventListener("change", async (e) => {
      const f = e.target.files && e.target.files[0];
      if(!f) return;

      try{
        dkPendingIcon = await compressImageToDataURL(f, {
          maxSize: 256,
          mime: "image/webp",
          quality: 0.82
        });

        setDkIcon(dkPendingIcon);
        toast(dkToast, "ì•„ì´ì½˜ ì„ íƒë¨(ì••ì¶•ë¨). 'ì €ì¥'ì„ ëˆ„ë¥´ë©´ ì˜êµ¬ ë°˜ì˜ë¼.");
      }catch(err){
        console.error(err);
        toast(dkToast, "ì•„ì´ì½˜ ì²˜ë¦¬ ì‹¤íŒ¨(íŒŒì¼ì´ ì†ìƒëê±°ë‚˜ ë¸Œë¼ìš°ì € ì œí•œì¼ ìˆ˜ ìˆì–´).");
      }
    });

    dkIconClear.addEventListener("click", async () => {
      dkIconFile.value = "";
      setDkIcon("");
      dkPendingIcon = "";

      // âœ… ì„ íƒëœ í•­ëª©ì´ ìˆìœ¼ë©´: DBì—ì„œë„ ì‚­ì œ + iconKey ë¹„ìš°ê¸°
      if(activeDkId){
        const idx = dks.findIndex(x => x.id === activeDkId);
        if(idx >= 0){
          const oldKey = dks[idx].iconKey || "";
          if(oldKey){
            try{ await idbDel(oldKey); }catch(e){}
            revokeIconURL(oldKey);
          }
          dks[idx] = { ...dks[idx], iconKey: "" };
          saveDks();
          renderDkList();
          toast(dkToast, "ì•„ì´ì½˜ ì œê±° ì™„ë£Œ!");
          return;
        }
      }
    });

    function setDkState(state){
      if(state === "debuff"){
        dkStateBtn.textContent = "ë””ë²„í”„";
        dkStateBtn.classList.remove("buff");
        dkStateBtn.classList.add("debuff");
        dkStateBtn.dataset.state = "debuff";
      }else{
        dkStateBtn.textContent = "ë²„í”„";
        dkStateBtn.classList.remove("debuff");
        dkStateBtn.classList.add("buff");
        dkStateBtn.dataset.state = "buff";
      }
    }

    function dkAutosave(){
      if(!activeDkId) return;
      const idx = dks.findIndex(x => x.id === activeDkId);
      if(idx < 0) return;

      dks[idx] = {
        ...dks[idx],
        name: dkName.value,
        text: dkText.value,
        state: (dkStateBtn.dataset.state === "debuff") ? "debuff" : "buff",
        // âœ… iconKeyëŠ” ìë™ì €ì¥ì—ì„œ ê±´ë“œë¦¬ì§€ ì•ŠìŒ
      };
      saveDks();
    }

    dkName.addEventListener("input", dkAutosave);
    dkText.addEventListener("input", dkAutosave);

    dkStateBtn.addEventListener("click", () => {
      const cur = dkStateBtn.dataset.state || "buff";
      setDkState(cur === "buff" ? "debuff" : "buff");
      dkAutosave();
    });

    function saveDks(){
      try{
        localStorage.setItem(KEY_DK, JSON.stringify(dks));
      }catch(e){
        console.error("DK ì €ì¥ ì‹¤íŒ¨:", e);
        toast(dkToast, "ì „ìš© í‚¤ì›Œë“œ ì €ì¥ ì‹¤íŒ¨! (ê¶Œí•œ/ìš©ëŸ‰ ë¬¸ì œì¼ ìˆ˜ ìˆì–´)");
      }
    }

    function clearDkEditor(){
      activeDkId = null;
      dkName.value = "";
      dkText.value = "";
      dkIconFile.value = "";
      setDkIcon("");
      setDkState("buff");
      renderDkList();
    }

    async function loadDkToEditor(item){
      dkPendingIcon = "";
      activeDkId = item.id;
      dkName.value = item.name || "";
      dkText.value = item.text || "";
      setDkState(item.state || "buff");

      // ë¯¸ë¦¬ë³´ê¸°: IndexedDBì—ì„œ ì½ì–´ì˜¤ê¸°
      setDkIcon("");
      if(item.iconKey){
        try{
          const blob = await idbGetBlob(item.iconKey);
          if(blob){
            setDkIcon(makeObjectURLFromBlob(blob));
          }else{
            setDkIcon("");
          }
        }catch(e){
          console.error(e);
          setDkIcon("");
        }
      }

      renderDkList();
    }

    function displayTitle(k){
      const nm = String(k.name || "").trim();
      if(nm) return nm;
      const txt = String(k.text || "").trim();
      if(!txt) return "(ë‚´ìš© ì—†ìŒ)";
      const firstLine = txt.split("\n")[0].trim();
      return firstLine || "(ë‚´ìš© ì—†ìŒ)";
    }

    function renderDkList(){
      dkList.innerHTML = "";

      if(dks.length === 0){
        const empty = document.createElement("div");
        empty.style.color = "rgba(238,241,255,.55)";
        empty.style.fontSize = "13px";
        empty.style.padding = "10px 6px";
        empty.textContent = "ì•„ì§ ì „ìš© í‚¤ì›Œë“œê°€ ì—†ì–´. ì•„ë˜ 'í‚¤ì›Œë“œ ì¶”ê°€'ë¡œ ë§Œë“¤ì.";
        dkList.appendChild(empty);
        return;
      }

      for(const k of dks){
        const item = document.createElement("div");
        const toneClass = (k.state === "debuff") ? " debuff" : " buff";
        item.className = "dkItem" + toneClass + (k.id === activeDkId ? " active" : "");

        const left = document.createElement("div");
        left.className = "dkLeft";

        const icon = document.createElement("div");
        icon.className = "dkMiniIcon";

        // âœ… iconKey -> IndexedDBë¡œ ë¡œë“œ
        const img = document.createElement("img");
        img.alt = "ì•„ì´ì½˜";
        img.style.display = "none";
        icon.appendChild(img);

        const ph = document.createElement("div");
        ph.className = "ph";
        ph.textContent = "ì•„ì´ì½˜";
        icon.appendChild(ph);

        if(k.iconKey){
          applyIconKeyToImg(img, k.iconKey).then(() => {
            if(img.style.display === "block") ph.style.display = "none";
          });
        }

        const titleEl = document.createElement("div");
        titleEl.className = "dkLeftTitle";
        titleEl.textContent = displayTitle(k);

        left.appendChild(icon);
        left.appendChild(titleEl);

        const meta = document.createElement("div");
        meta.className = "dkMeta";

        const d = document.createElement("div");
        d.className = "d";
        d.textContent = String(k.text || "").trim() || "(ë‚´ìš© ì—†ìŒ)";
        meta.appendChild(d);

        const tag = document.createElement("div");
        tag.className = "dkTag " + (k.state === "debuff" ? "debuff" : "buff");
        tag.textContent = (k.state === "debuff") ? "ë””ë²„í”„" : "ë²„í”„";

        item.appendChild(left);
        item.appendChild(meta);
        item.appendChild(tag);

        item.addEventListener("click", () => loadDkToEditor(k));
        dkList.appendChild(item);
      }
    }

    dkAddBtn.addEventListener("click", () => {
      const it = { id: uid(), name: "", text: "", state: "buff", iconKey: "" };
      dks.unshift(it);
      saveDks();
      loadDkToEditor(it);
      toast(dkToast, "ìƒˆ ì „ìš© í‚¤ì›Œë“œë¥¼ ë§Œë“¤ì—ˆì–´. ì´ë¦„/ë‚´ìš© ì‘ì„± í›„ ì €ì¥í•´ì¤˜.");
      selectTab("dk");
    });

    dkSaveBtn.addEventListener("click", async () => {
      if(!activeDkId){
        toast(dkToast, "ë¨¼ì € ì•„ë˜ì—ì„œ í‚¤ì›Œë“œë¥¼ ì„ íƒí•˜ê±°ë‚˜, 'í‚¤ì›Œë“œ ì¶”ê°€'ë¡œ ë§Œë“¤ì–´ì¤˜.");
        return;
      }
      const idx = dks.findIndex(x => x.id === activeDkId);
      if(idx < 0) return;

      // âœ… ê¸°ì¡´ iconKey ìœ ì§€
      let iconKey = dks[idx].iconKey || "";

      // âœ… pending ì•„ì´ì½˜ì´ ìˆìœ¼ë©´ IndexedDBì— ì €ì¥(í‚¤ëŠ” í•­ëª© id ê¸°ë°˜ ê³ ì •)
      if(dkPendingIcon && String(dkPendingIcon).startsWith("data:image/")){
        try{
          const blob = dataURLToBlob(dkPendingIcon);
          iconKey = `dk_icon_${activeDkId}`;
          await idbPutBlob(iconKey, blob);
          revokeIconURL(iconKey); // ìºì‹œ URL ê°±ì‹ 
        }catch(e){
          console.error(e);
          toast(dkToast, "ì•„ì´ì½˜ ì €ì¥ ì‹¤íŒ¨(ë¸Œë¼ìš°ì € ì œí•œ/í˜•ì‹ ë¬¸ì œ).");
          return;
        }
      }

      dks[idx] = {
        ...dks[idx],
        name: dkName.value,
        text: dkText.value,
        state: (dkStateBtn.dataset.state === "debuff") ? "debuff" : "buff",
        iconKey: iconKey || ""
      };

      saveDks();
      dkPendingIcon = "";
      toast(dkToast, "ì €ì¥ ì™„ë£Œ!");
      renderDkList();

      if(iconKey){
        try{
          const blob = await idbGetBlob(iconKey);
          if(blob) setDkIcon(makeObjectURLFromBlob(blob));
        }catch(e){}
      }
    });

    dkDeleteBtn.addEventListener("click", async () => {
      if(!activeDkId){
        toast(dkToast, "ì‚­ì œí•  í‚¤ì›Œë“œë¥¼ ë¨¼ì € ì„ íƒí•´ì¤˜.");
        return;
      }
      const idx = dks.findIndex(x => x.id === activeDkId);
      if(idx < 0) return;

      // âœ… ì•„ì´ì½˜ë„ ê°™ì´ ì‚­ì œ
      const oldKey = dks[idx].iconKey || "";
      if(oldKey){
        try{ await idbDel(oldKey); }catch(e){}
        revokeIconURL(oldKey);
      }

      dks.splice(idx, 1);
      saveDks();
      toast(dkToast, "í‚¤ì›Œë“œ ì‚­ì œ ì™„ë£Œ!");
      clearDkEditor();
    });

    // âœ… DK ì´ˆê¸° ë¡œë“œ + êµ¬ë²„ì „ icon(dataURL) ë§ˆì´ê·¸ë ˆì´ì…˜
    (async () => {
      try{
        const saved = JSON.parse(localStorage.getItem(KEY_DK) || "[]");
        if(Array.isArray(saved)) dks = saved;

        let changed = false;
        for(const k of dks){
          // êµ¬ë²„ì „: icon(dataURL) -> iconKey(DB)
          if(k.icon && String(k.icon).startsWith("data:image/") && !k.iconKey){
            try{
              const blob = dataURLToBlob(k.icon);
              const key = `dk_icon_${k.id}`;
              await idbPutBlob(key, blob);
              k.iconKey = key;
              delete k.icon;
              changed = true;
            }catch(e){
              console.error("dk icon migrate fail:", e);
            }
          }
          if(k.icon && k.iconKey){
            delete k.icon;
            changed = true;
          }
        }
        if(changed) localStorage.setItem(KEY_DK, JSON.stringify(dks));
      }catch(e){
        console.error(e);
      }
      clearDkEditor();
    })();

    const pvToast = document.getElementById("pvToast");
    const pvName = document.getElementById("pvName");
    const pvText = document.getElementById("pvText");
    const pvSaveBtn = document.getElementById("pvSaveBtn");
    const pvDeleteBtn = document.getElementById("pvDeleteBtn");
    const pvAddBtn = document.getElementById("pvAddBtn");
    const pvBoard = document.getElementById("pvBoard");
    const skList = document.getElementById("skList");
    const pvHighlightBtn = document.getElementById("pvHighlightBtn");
    const pvKeywordBtn = document.getElementById("pvKeywordBtn");
    const pvStyleBtns = [...document.querySelectorAll(".pvStyleBtn")];

const skListNormal = document.getElementById("skListNormal");
const skListSpecial = document.getElementById("skListSpecial");

    let passives = [];
    let activePvId = null;
    let activePvStyle = "brown"; // ë³´í†µ=brown | ì¤‘ìš”=orange | ë§¤ìš°ì¤‘ìš”=red

    function pvUid(){
      return Math.random().toString(16).slice(2) + Date.now().toString(16);
    }
function pvSaveStore(){
  try{
    const raw = JSON.stringify(passives);
    localStorage.setItem(KEY_PV, raw);

    // âœ… ì‹¤ì œë¡œ ì €ì¥ëëŠ”ì§€ ê²€ì¦
    const check = localStorage.getItem(KEY_PV);
    if(check !== raw){
      throw new Error("KEY_PV write verify failed");
    }

    return true;
  }catch(e){
    console.error("íŒ¨ì‹œë¸Œ ì €ì¥ ì‹¤íŒ¨:", e);
    try{ toast(pvToast, "íŒ¨ì‹œë¸Œ ì €ì¥ ì‹¤íŒ¨! (ë¸Œë¼ìš°ì € ì €ì¥ê³µê°„/ê¶Œí•œ ë¬¸ì œì¼ ìˆ˜ ìˆì–´)"); }catch(_){}
    return false;
  }
}
    function pvLoadStore(){
      try{
        const saved = JSON.parse(localStorage.getItem(KEY_PV) || "[]");
        if(Array.isArray(saved)) passives = saved;
      }catch(e){}
    }
    function pvToastMsg(msg){
      toast(pvToast, msg);
    }
    function pvSetStyle(style){
      activePvStyle = style;
      pvStyleBtns.forEach(b => b.classList.toggle("active", b.dataset.style === style));
    }
    pvStyleBtns.forEach(btn => {
      btn.addEventListener("click", () => pvSetStyle(btn.dataset.style || "brown"));
    });

    function pvHasHighlightTokens(text){
      return String(text || "").includes("[[hl]]") || String(text || "").includes("[[/hl]]");
    }
    function pvWrapSelectionWithHighlight(){
      const el = pvText;
      const start = el.selectionStart ?? 0;
      const end = el.selectionEnd ?? 0;
      if(start === end) return false;

      const txt = el.value;
      const before = txt.slice(0, start);
      const sel = txt.slice(start, end);
      const after = txt.slice(end);

      el.value = before + "[[hl]]" + sel + "[[/hl]]" + after;
      const newPos = end + "[[hl]]".length + "[[/hl]]".length;
      el.focus();
      el.setSelectionRange(newPos, newPos);
      return true;
    }
    function pvStripAllHighlights(text){
      return String(text || "").replaceAll("[[hl]]","").replaceAll("[[/hl]]","");
    }

    pvHighlightBtn.addEventListener("click", () => {
      const ok = pvWrapSelectionWithHighlight();
      if(!ok){
        pvToastMsg("ê°•ì¡°í•  í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ë“œë˜ê·¸í•´ì„œ ì„ íƒí•´ì¤˜.");
        return;
      }
      pvToastMsg("ì„ íƒí•œ ë¶€ë¶„ì— ê°•ì¡°ë¥¼ ì ìš©í–ˆì–´.");
      pvRenderBoard();
    });

    /* âœ… ì „ìš©í‚¤ì›Œë“œ í† í° -> ì¹´ë“œì—ì„œ ìƒ‰ í‘œì‹œ */
/* âœ… ì „ìš©í‚¤ì›Œë“œ í† í° -> ì¹´ë“œì—ì„œ ìƒ‰ í‘œì‹œ */
function pvToHtml(text){
  const esc = String(text || "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;");

  return esc
    .replaceAll("[[hl]]", '<span class="pvHL">')
    .replaceAll("[[/hl]]", "</span>")
    .replaceAll(/\[\[kw:(buff|debuff):([^\]]+)\]\]/g, (m, st, name) => {
      const cls = (st === "debuff") ? "debuff" : "buff";
      const safeName = String(name).replaceAll('"', "&quot;");
      return `<span class="pvKW ${cls}" data-kw="${safeName}" data-state="${st}">${name}</span>`;
    });
}

    function pvDisplayTitle(p){
      const n = String(p.name || "").trim();
      if(n) return n;
      const t = pvStripAllHighlights(String(p.text || "")).trim();
      if(!t) return "(ë‚´ìš© ì—†ìŒ)";
      return (t.split("\n")[0] || "(ë‚´ìš© ì—†ìŒ)").trim();
    }

    function pvRenderBoard(){
      if(!pvBoard) return;
      pvBoard.innerHTML = "";

      if(passives.length === 0){
        const d = document.createElement("div");
        d.style.color = "rgba(238,241,255,.55)";
        d.style.fontSize = "13px";
        d.style.padding = "8px";
        d.textContent = "ì•„ì§ íŒ¨ì‹œë¸Œê°€ ì—†ì–´. ì˜¤ë¥¸ìª½ì˜ 'íŒ¨ì‹œë¸Œ ì¶”ê°€'ë¡œ ë§Œë“¤ì.";
        pvBoard.appendChild(d);
        return;
      }

      for(const p of passives){
        const card = document.createElement("div");
        card.className = "pvCard" + (p.id === activePvId ? " active" : "");

        const hdr = document.createElement("div");
        hdr.className = "pvHdr " + (p.style || "brown");
        hdr.textContent = pvDisplayTitle(p);

        const sl = document.createElement("div");
        sl.className = "slashes";
        sl.innerHTML = "<i></i><i></i><i></i>";
        hdr.appendChild(sl);

        const body = document.createElement("div");
        body.className = "pvBody";
        body.innerHTML = pvToHtml(p.text || "");

        card.appendChild(hdr);
        card.appendChild(body);

        card.addEventListener("click", () => {
          activePvId = p.id;
          pvName.value = p.name || "";
          pvText.value = p.text || "";
          pvSetStyle(p.style || "brown");
          pvRenderBoard();
        });

        pvBoard.appendChild(card);
      }
    }

    function pvClearEditor(){
      activePvId = null;
      pvName.value = "";
      pvText.value = "";
      pvSetStyle("brown");
      pvRenderBoard();
    }

    pvAddBtn.addEventListener("click", () => {
      const it = { id: pvUid(), name: "", text: "", style: "brown" };
      passives.push(it);
      pvSaveStore();

      activePvId = it.id;
      pvName.value = "";
      pvText.value = "";
      pvSetStyle("brown");

      pvRenderBoard();
      pvToastMsg("ìƒˆ íŒ¨ì‹œë¸Œë¥¼ ì¶”ê°€í–ˆì–´. ì´ë¦„/ë‚´ìš© ì‘ì„± í›„ ì €ì¥í•´ì¤˜.");
      selectTab("passive");
    });

function forceSavePassivesIfEditing(){
  // í¸ì§‘ ì¤‘ì¸ íŒ¨ì‹œë¸Œê°€ ìˆìœ¼ë©´, í˜„ì¬ ì…ë ¥ì¹¸ ê°’ì„ passives[]ì— ë°˜ì˜
  if(activePvId){
    const idx = passives.findIndex(x => x.id === activePvId);
    if(idx >= 0){
      passives[idx] = {
        ...passives[idx],
        name: pvName.value,
        text: pvText.value,
        style: activePvStyle
      };
    }
  }

  // localStorage ë°˜ì˜
  try{
    localStorage.setItem(KEY_PV, JSON.stringify(passives));
  }catch(e){
    console.error("íŒ¨ì‹œë¸Œ ê°•ì œì €ì¥ ì‹¤íŒ¨:", e);
    try{ toast(pvToast, "íŒ¨ì‹œë¸Œ ì €ì¥ ì‹¤íŒ¨(ìš©ëŸ‰/ê¶Œí•œ ë¬¸ì œì¼ ìˆ˜ ìˆì–´)."); }catch(_){}
  }
}

// âœ… íŒ¨ì‹œë¸Œ í¸ì§‘ ìë™ì €ì¥ (ì…ë ¥/ìŠ¤íƒ€ì¼ ë°”ë€” ë•Œë§ˆë‹¤)
pvName?.addEventListener("input", forceSavePassivesIfEditing);
pvText?.addEventListener("input", forceSavePassivesIfEditing);

// ìŠ¤íƒ€ì¼ ë²„íŠ¼ í´ë¦­ ì‹œì—ë„ ì €ì¥
pvStyleBtns.forEach(btn => {
  btn.addEventListener("click", () => {
    // pvSetStyle()ëŠ” ê¸°ì¡´ ì½”ë“œê°€ ì´ë¯¸ í˜¸ì¶œí•˜ë‹ˆê¹Œ, ê·¸ ë’¤ì— ì €ì¥ë§Œ ì¶”ê°€
    forceSavePassivesIfEditing();
  });
});

    pvSaveBtn.addEventListener("click", () => {
      if(!activePvId){
        pvToastMsg("ë¨¼ì € ì•„ë˜ì—ì„œ íŒ¨ì‹œë¸Œë¥¼ ì„ íƒí•˜ê±°ë‚˜, 'íŒ¨ì‹œë¸Œ ì¶”ê°€'ë¡œ ë§Œë“¤ì–´ì¤˜.");
        return;
      }
      const idx = passives.findIndex(x => x.id === activePvId);
      if(idx < 0) return;

      passives[idx] = {
        ...passives[idx],
        name: pvName.value,
        text: pvText.value,
        style: activePvStyle
      };

pvSaveStore();
pvToastMsg("ì €ì¥ ì™„ë£Œ!");
pvRenderBoard();
    });

    pvDeleteBtn.addEventListener("click", () => {
      if(!activePvId){
        pvToastMsg("ì‚­ì œí•  íŒ¨ì‹œë¸Œë¥¼ ë¨¼ì € ì„ íƒí•´ì¤˜.");
        return;
      }
      const idx = passives.findIndex(x => x.id === activePvId);
      if(idx < 0) return;

      passives.splice(idx, 1);
      pvSaveStore();
      pvToastMsg("ì‚­ì œ ì™„ë£Œ!");
      pvClearEditor();
    });

/* ========= í‚¤ì›Œë“œ(ê¸°ë³¸/ëŒ€í‘œ/ì „ìš©) í”¼ì»¤ ========= */
const kwModal = document.getElementById("kwModal");
const kwCloseBtn = document.getElementById("kwCloseBtn");
const kwModalList = document.getElementById("kwModalList");
const kwModalTitle = document.getElementById("kwModalTitle");
const kwTabBtns = [...document.querySelectorAll(".kwTab")];
const kwStateToggle = document.getElementById("kwStateToggle");
let kwStateFilter = "buff"; // âœ… ê¸°ë³¸ì€ ë²„í”„ë§Œ

function setKwStateFilter(next){
  kwStateFilter = (next === "debuff") ? "debuff" : "buff";

  if(kwStateToggle){
    kwStateToggle.classList.remove("buff","debuff");
    kwStateToggle.classList.add(kwStateFilter);
    kwStateToggle.textContent = (kwStateFilter === "debuff") ? "ë””ë²„í”„" : "ë²„í”„";
  }

  renderKwModal(); // âœ… ë¦¬ìŠ¤íŠ¸ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
}

kwStateToggle?.addEventListener("click", () => {
  setKwStateFilter(kwStateFilter === "buff" ? "debuff" : "buff");
});

/** âœ… ê¸°ë³¸/ëŒ€í‘œ í‚¤ì›Œë“œ(ìˆ˜ì • ë¶ˆê°€, assets ì•„ì´ì½˜) */
const REP_KEYWORDS = [
  // debuff
  { name:"í™”ìƒ", state:"debuff", icon:"assets/icon_rep_burn.png", text:"í„´ ì¢…ë£Œ ì‹œ, íš¨ê³¼ ìœ„ë ¥ë§Œí¼ ê³ ì • í”¼í•´ë¥¼ ë°›ê³  íšŸìˆ˜ 1 ê°ì†Œ" },
  { name:"ì¶œí˜ˆ", state:"debuff", icon:"assets/icon_rep_bleed.png", text:"ê³µê²© ìŠ¤í‚¬ì˜ ì½”ì¸ íŒì • ì‹œ, íš¨ê³¼ ìœ„ë ¥ë§Œí¼ ê³ ì • ì²´ë ¥ í”¼í•´ë¥¼ ë°›ìŒ. ê³µê²© ìŠ¤í‚¬ì˜ ì½”ì¸ íŒì • í›„ íšŸìˆ˜ 1 ê°ì†Œ" },
  { name:"ì§„ë™", state:"debuff", icon:"assets/icon_rep_tremor.png", text:"ì§„ë™ í­ë°œ ìŠ¤í‚¬ë¡œ í”¼ê²© ì‹œ, íš¨ê³¼ ìœ„ë ¥ë§Œí¼ ííŠ¸ëŸ¬ì§ ì†ìƒ. í„´ ì¢…ë£Œ í›„ íšŸìˆ˜ 1 ê°ì†Œ" },
  { name:"íŒŒì—´", state:"debuff", icon:"assets/icon_rep_rupture.png", text:"ê³µê²© ìŠ¤í‚¬ë¡œ í”¼ê²© ì‹œ, íš¨ê³¼ ìœ„ë ¥ë§Œí¼ ê³ ì • ì²´ë ¥ í”¼í•´ë¥¼ ë°›ìŒ. í”¼ê²© í›„ íšŸìˆ˜ 1 ê°ì†Œ" },
  { name:"ì¹¨ì ", state:"debuff", icon:"assets/icon_rep_sinking.png", text:"ê³µê²© ìŠ¤í‚¬ë¡œ í”¼ê²© ì‹œ, íš¨ê³¼ ìœ„ë ¥ë§Œí¼ ê³ ì • ì •ì‹ ë ¥ í”¼í•´ë¥¼ ë°›ìŒ (ì •ì‹ ë ¥ì´ ì—†ëŠ” ëŒ€ìƒì—ê²ŒëŠ” ìš°ìš¸ ì†ì„± í”¼í•´ë¡œ ì ìš©ë¨) í”¼ê²© í›„ íšŸìˆ˜ 1 ê°ì†Œ" },
  { name:"ì§„ë™ í­ë°œ", state:"debuff", icon:"assets/icon_rep_tremor_boom.png", text:"ëŒ€ìƒì˜ ì§„ë™ ìœ„ë ¥ë§Œí¼ ííŠ¸ëŸ¬ì§ ì†ìƒì„ ì…í˜" },
  { name:"ì§„í­ ë³€í™˜", state:"debuff", icon:"assets/icon_rep_tremor_urthim.png", text:"ëŒ€ìƒì˜ ì§„ë™ ë˜ëŠ” ë³€ê²½ëœ ì§„ë™ì„ ë‹¤ë¥¸ ìœ í˜•ì˜ ì§„ë™ìœ¼ë¡œ ë³€ê²½í•¨. ë³€ê²½ ì‹œ ê¸°ì¡´ íš¨ê³¼ì˜ ìœ„ë ¥, íšŸìˆ˜ê°€ ìœ ì§€ë¨" },
  // buff
  { name:"ì¶©ì „", state:"buff", icon:"assets/icon_rep_charge.png", text:"ì†Œëª¨ ì‹œ íŠ¹ì • ìŠ¤í‚¬ì˜ ìœ„ë ¥ì´ ìƒìŠ¹í•¨. íšŸìˆ˜ë¥¼ ìµœëŒ€ 20ê¹Œì§€ ì–»ì„ ìˆ˜ ìˆìŒ. í„´ ì¢…ë£Œ ì‹œ íšŸìˆ˜ 1 ê°ì†Œ" },
  { name:"í˜¸í¡", state:"buff", icon:"assets/icon_rep_breath.png", text:"ì ì¤‘ ì‹œ íš¨ê³¼ ìœ„ë ¥ 1ë‹¹ 5%ì˜ í™•ë¥ ë¡œ 120%ì˜ ì¹˜ëª…íƒ€ í”¼í•´ë¥¼ ì…í˜. í„´ ì¢…ë£Œ ì‹œ, ì¹˜ëª…íƒ€ ë°œë™ í›„ íšŸìˆ˜ 1 ê°ì†Œ" },
];

const BASE_KEYWORDS = [
  // debuff
  { name:"ì·¨ì•½", state:"debuff", icon:"assets/icon_base_fragile.png", text:"í•œ í„´ ë™ì•ˆ ìŠ¤í‚¬ë¡œ ë°›ëŠ” í”¼í•´ê°€ ìˆ˜ì¹˜ì— ë¹„ë¡€í•˜ì—¬ ì¦ê°€ (ìˆ˜ì¹˜ 1ë‹¹ 10%)" },
  { name:"ì†ë°•", state:"debuff", icon:"assets/icon_base_bind.png", text:"í•œ í„´ ë™ì•ˆ ì†ë„ê°€ ìˆ˜ì¹˜ë§Œí¼ ì¦ê°€/ê°ì†Œ" },
  { name:"ìœ„ë ¥ ê°ì†Œ", state:"debuff", icon:"assets/icon_base_power_down.png", text:"í•œ í„´ ë™ì•ˆ ìŠ¤í‚¬ì˜ ìµœì¢… ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ê°ì†Œ" },
  { name:"ê³µê²© ìœ„ë ¥ ê°ì†Œ", state:"debuff", icon:"assets/icon_base_atk_power_down.png", text:"í•œ í„´ ë™ì•ˆ ê³µê²© ìŠ¤í‚¬ì˜ ìµœì¢… ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ê°ì†Œ" },
  { name:"ìˆ˜ë¹„ ìœ„ë ¥ ê°ì†Œ", state:"debuff", icon:"assets/icon_base_def_power_down.png", text:"í•œ í„´ ë™ì•ˆ ìˆ˜ë¹„ ìŠ¤í‚¬ì˜ ìµœì¢… ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ê°ì†Œ" },
  { name:"í•© ìœ„ë ¥ ê°ì†Œ", state:"debuff", icon:"assets/icon_base_clash_power_down.png", text:"í•© ì§„í–‰ ì‹œ, í•© ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ê°ì†Œ" },
  { name:"ë”í•˜ê¸° ì½”ì¸ ì•½í™”", state:"debuff", icon:"assets/icon_base_plus_coin_down.png", text:"í•œ í„´ ë™ì•ˆ ë”í•˜ê¸° ì½”ì¸ ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ê°ì†Œ" },
  { name:"ë¹¼ê¸° ì½”ì¸ ì•½í™”", state:"debuff", icon:"assets/icon_base_minus_coin_down.png", text:"í•œ í„´ ë™ì•ˆ ë¹¼ê¸° ì½”ì¸ ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ê°ì†Œ" },
  { name:"í”¼í•´ëŸ‰ ê°ì†Œ", state:"debuff", icon:"assets/icon_base_damage_down.png", text:"í•œ í„´ ë™ì•ˆ ìŠ¤í‚¬ë¡œ ê°€í•˜ëŠ” í”¼í•´ê°€ ìˆ˜ì¹˜ì— ë¹„ë¡€í•˜ì—¬ 10%ì”© ê°ì†Œ (ìµœëŒ€ 10)" },
  { name:"ê³µê²© ë ˆë²¨ ê°ì†Œ", state:"debuff", icon:"assets/icon_base_atk_level_down.png", text:"í•œ í„´ ë™ì•ˆ ê³µê²© ë ˆë²¨ì´ ìˆ˜ì¹˜ì— ë¹„ë¡€í•˜ì—¬ ê°ì†Œ" },
  { name:"ë°©ì–´ ë ˆë²¨ ê°ì†Œ", state:"debuff", icon:"assets/icon_base_def_level_down.png", text:"í•œ í„´ ë™ì•ˆ ë°©ì–´ ë ˆë²¨ì´ ìˆ˜ì¹˜ì— ë¹„ë¡€í•˜ì—¬ ê°ì†Œ" },
  { name:"ë§ˆë¹„", state:"debuff", icon:"assets/icon_base_paralysis.png", text:"í•œ í„´ ë™ì•ˆ ìˆ˜ì¹˜ë§Œí¼ ì½”ì¸ ìœ„ë ¥ì´ 0ìœ¼ë¡œ ê³ ì •" },

  // buff
  { name:"ë³´í˜¸", state:"buff", icon:"assets/icon_base_protection.png", text:"í•œ í„´ ë™ì•ˆ ìŠ¤í‚¬ë¡œ ë°›ëŠ” í”¼í•´ê°€ ìˆ˜ì¹˜ì— ë¹„ë¡€í•˜ì—¬ ê°ì†Œ (ìˆ˜ì¹˜ 1ë‹¹ 10%)" },
  { name:"ì‹ ì†", state:"buff", icon:"assets/icon_base_haste.png", text:"í•œ í„´ ë™ì•ˆ ì†ë„ê°€ ìˆ˜ì¹˜ë§Œí¼ ì¦ê°€" },
  { name:"ìœ„ë ¥ ì¦ê°€", state:"buff", icon:"assets/icon_base_power_up.png", text:"í•œ í„´ ë™ì•ˆ ìŠ¤í‚¬ì˜ ìµœì¢… ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ì¦ê°€" },
  { name:"ê³µê²© ìœ„ë ¥ ì¦ê°€", state:"buff", icon:"assets/icon_base_atk_power_up.png", text:"í•œ í„´ ë™ì•ˆ ê³µê²© ìŠ¤í‚¬ì˜ ìµœì¢… ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ì¦ê°€" },
  { name:"ìˆ˜ë¹„ ìœ„ë ¥ ì¦ê°€", state:"buff", icon:"assets/icon_base_def_power_up.png", text:"í•œ í„´ ë™ì•ˆ ìˆ˜ë¹„ ìŠ¤í‚¬ì˜ ìµœì¢… ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ì¦ê°€" },
  { name:"í•© ìœ„ë ¥ ì¦ê°€", state:"buff", icon:"assets/icon_base_clash_power_up.png", text:"í•© ì§„í–‰ ì‹œ, í•© ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ì¦ê°€" },
  { name:"ë”í•˜ê¸° ì½”ì¸ ì¦ê°€", state:"buff", icon:"assets/icon_base_plus_coin_up.png", text:"í•œ í„´ ë™ì•ˆ ë”í•˜ê¸° ì½”ì¸ ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ì¦ê°€" },
  { name:"ë¹¼ê¸° ì½”ì¸ ì¦ê°€", state:"buff", icon:"assets/icon_base_minus_coin_up.png", text:"í•œ í„´ ë™ì•ˆ ë¹¼ê¸° ì½”ì¸ ìœ„ë ¥ì´ ìˆ˜ì¹˜ë§Œí¼ ì¦ê°€" },
  { name:"í”¼í•´ëŸ‰ ì¦ê°€", state:"buff", icon:"assets/icon_base_damage_up.png", text:"í•œ í„´ ë™ì•ˆ ìŠ¤í‚¬ë¡œ ê°€í•˜ëŠ” í”¼í•´ê°€ ìˆ˜ì¹˜ì— ë¹„ë¡€í•˜ì—¬ 10%ì”© ì¦ê°€ (ìµœëŒ€ 10)" },
  { name:"ê³µê²© ë ˆë²¨ ì¦ê°€", state:"buff", icon:"assets/icon_base_atk_level_up.png", text:"í•œ í„´ ë™ì•ˆ ê³µê²© ë ˆë²¨ì´ ìˆ˜ì¹˜ì— ë¹„ë¡€í•˜ì—¬ ì¦ê°€" },
  { name:"ë°©ì–´ ë ˆë²¨ ì¦ê°€", state:"buff", icon:"assets/icon_base_def_level_up.png", text:"í•œ í„´ ë™ì•ˆ ë°©ì–´ ë ˆë²¨ì´ ìˆ˜ì¹˜ì— ë¹„ë¡€í•˜ì—¬ ì¦ê°€" },
];

/** ì „ìš© í‚¤ì›Œë“œ ë¡œë“œ(localStorage) */
function loadDedicatedKeywords(){
  try{
    const raw = JSON.parse(localStorage.getItem(KEY_DK) || "[]");
    if(Array.isArray(raw)) return raw;
  }catch(e){}
  return [];
}

/** íƒ­ ìƒíƒœ */
let kwActiveTab = "base"; // base | rep | ded

function setKwTab(tab){
  kwActiveTab = tab;
  kwTabBtns.forEach(b => {
    const on = (b.dataset.tab === tab);
    b.classList.toggle("active", on);
    b.setAttribute("aria-selected", on ? "true" : "false");
  });

  if(kwModalTitle){
    kwModalTitle.textContent =
      (tab === "base") ? "ê¸°ë³¸ í‚¤ì›Œë“œ" :
      (tab === "rep")  ? "ëŒ€í‘œ í‚¤ì›Œë“œ" : "ì „ìš© í‚¤ì›Œë“œ";
  }
  renderKwModal();
}

function insertAtCursor(textarea, text){
  const start = textarea.selectionStart ?? textarea.value.length;
  const end = textarea.selectionEnd ?? textarea.value.length;
  const v = textarea.value;
  textarea.value = v.slice(0, start) + text + v.slice(end);
  const pos = start + text.length;
  textarea.focus();
  textarea.setSelectionRange(pos, pos);
}

let kwTargetTextarea = null;

function openKwModalFor(textarea){
  kwTargetTextarea = textarea || pvText;
  kwModal.classList.remove("hidden");
  setKwTab(kwActiveTab);
}
function openKwModal(){
  openKwModalFor(pvText);
}
function closeKwModal(){
  kwModal.classList.add("hidden");
}

/** ê³µí†µ ë Œë” row */
function makeKwRow({name, state, iconSrc, iconKey, isDedicated}){
  const row = document.createElement("button");
  row.type = "button";
  row.style.display = "grid";
  row.style.gridTemplateColumns = "52px 1fr 90px";
  row.style.gap = "10px";
  row.style.alignItems = "center";
  row.style.textAlign = "left";
  row.style.padding = "12px";
  row.style.borderRadius = "14px";

  const icon = document.createElement("div");
  icon.style.width = "48px";
  icon.style.height = "48px";
  icon.style.borderRadius = "14px";
  icon.style.border = "1px solid rgba(255,255,255,.12)";
  icon.style.background = "rgba(0,0,0,.22)";
  icon.style.display = "grid";
  icon.style.placeItems = "center";
  icon.style.overflow = "hidden";

  // ì•„ì´ì½˜: (1) assets ê²½ë¡œ (2) ì „ìš©í‚¤ì›Œë“œ iconKey(IndexedDB)
  const img = document.createElement("img");
  img.alt = "ì•„ì´ì½˜";
  img.style.width = "100%";
  img.style.height = "100%";
  img.style.objectFit = "contain";
  img.style.display = "none";
  icon.appendChild(img);

  const ph = document.createElement("div");
  ph.textContent = "ì•„ì´ì½˜";
  ph.style.fontSize = "11px";
  ph.style.color = "rgba(238,241,255,.45)";
  icon.appendChild(ph);

  if(iconSrc){
    img.src = iconSrc;
    img.style.display = "block";
    ph.style.display = "none";
  }else if(isDedicated && iconKey){
    applyIconKeyToImg(img, iconKey).then(() => {
      if(img.style.display === "block") ph.style.display = "none";
    });
  }

  const title = document.createElement("div");
  title.style.fontWeight = "900";
  title.style.color = "rgba(243,211,154,.95)";
  title.textContent = name;

  const isDebuff = (state === "debuff");
  const tag = document.createElement("div");
  tag.textContent = isDebuff ? "ë””ë²„í”„" : "ë²„í”„";
  tag.style.fontWeight = "900";
  tag.style.fontSize = "12px";
  tag.style.padding = "8px 10px";
  tag.style.borderRadius = "999px";
  tag.style.border = "1px solid rgba(255,255,255,.12)";
  tag.style.background = "rgba(0,0,0,.18)";
  tag.style.textAlign = "center";
  tag.style.color = isDebuff ? "rgba(255,120,120,.98)" : "rgba(243,211,154,.95)";

  row.appendChild(icon);
  row.appendChild(title);
  row.appendChild(tag);

    // âœ… í† í°ì€ í†µì¼: ì–´ë””ì„œ ì˜¤ë“  ë™ì¼í•˜ê²Œ [[kw:state:name]]
row.addEventListener("click", async () => {
  const nm = String(name || "").trim() || "í‚¤ì›Œë“œ";
  const st = (state === "debuff") ? "debuff" : "buff";

  const target = kwTargetTextarea || pvText;
  insertAtCursor(target, `[[kw:${st}:${nm}]]`);
  closeKwModal();

  // âœ… íƒ€ê²Ÿì— ë”°ë¼ ê°±ì‹ 
  if(target === skText){
    await renderSkillPreview();
  }else{
    pvRenderBoard();
  }
});

  return row;
}

function renderKwModal(){
  kwModalList.innerHTML = "";

  // íƒ­ë³„ ë°ì´í„°
  if(kwActiveTab === "base"){
    for(const k of BASE_KEYWORDS){
      if(k.state !== kwStateFilter) continue;
      kwModalList.appendChild(makeKwRow({
        name: k.name,
        state: k.state,
        iconSrc: k.icon,
        isDedicated: false
      }));
    }
    return;
  }

  if(kwActiveTab === "rep"){
    for(const k of REP_KEYWORDS){
      if(k.state !== kwStateFilter) continue;
      kwModalList.appendChild(makeKwRow({
        name: k.name,
        state: k.state,
        iconSrc: k.icon,
        isDedicated: false
      }));
    }
    return;
  }

  // ì „ìš©
  const list = loadDedicatedKeywords();

  if(list.length === 0){
    const empty = document.createElement("div");
    empty.style.color = "rgba(238,241,255,.55)";
    empty.style.fontSize = "13px";
    empty.style.padding = "8px";
    empty.textContent = "ì „ìš© í‚¤ì›Œë“œê°€ ì—†ì–´. ì „ìš© í‚¤ì›Œë“œ íƒ­ì—ì„œ ë¨¼ì € ë§Œë“¤ì–´ì¤˜.";
    kwModalList.appendChild(empty);
    return;
  }

  const filtered = list.filter(k => {
    const st = (k.state === "debuff") ? "debuff" : "buff";
    return st === kwStateFilter;
  });

  if(filtered.length === 0){
    const empty = document.createElement("div");
    empty.style.color = "rgba(238,241,255,.55)";
    empty.style.fontSize = "13px";
    empty.style.padding = "8px";
    empty.textContent = (kwStateFilter === "debuff")
      ? "ë””ë²„í”„ ì „ìš© í‚¤ì›Œë“œê°€ ì—†ì–´."
      : "ë²„í”„ ì „ìš© í‚¤ì›Œë“œê°€ ì—†ì–´.";
    kwModalList.appendChild(empty);
    return;
  }

  for(const k of filtered){
    const nm = (k.name && String(k.name).trim()) ? k.name : "(ì´ë¦„ ì—†ìŒ)";
    kwModalList.appendChild(makeKwRow({
      name: nm,
      state: (k.state === "debuff") ? "debuff" : "buff",
      iconKey: k.iconKey || "",
      isDedicated: true
    }));
  }
} // âœ… ì´ ë‹«ëŠ” ì¤‘ê´„í˜¸ê°€ ì—†ì–´ì„œ ë¨¹í†µë‚¬ë˜ ê±°ì•¼

// âœ… íƒ­ í´ë¦­(í•¨ìˆ˜ ë°–!)
kwTabBtns.forEach(btn => {
  btn.addEventListener("click", () => setKwTab(btn.dataset.tab || "base"));
});

// âœ… ì—´ê¸°/ë‹«ê¸°(í•¨ìˆ˜ ë°–!)
pvKeywordBtn?.addEventListener("click", () => openKwModalFor(pvText));
kwCloseBtn?.addEventListener("click", closeKwModal);
kwModal?.addEventListener("click", (e) => { if(e.target === kwModal) closeKwModal(); });

/* ========= í‚¤ì›Œë“œ Hover Tooltip ========= */
const kwTip = document.getElementById("kwTip");
const kwTipImg = document.getElementById("kwTipImg");
const kwTipTitle = document.getElementById("kwTipTitle");
const kwTipText = document.getElementById("kwTipText");

function normKwName(v){
  return String(v || "")
    .trim()
    .replace(/\s+/g, "")
    .replace(/[â€-â€’â€“â€”â€•\-]/g, "-") // í•˜ì´í”ˆë¥˜ í†µì¼
    .toLowerCase();
}

function getDedicatedKeywordIconFallback(name){
  const n = normKwName(name);

  const map = {
    [normKwName("ì¶”ë ¥ ìƒì‹¤")]: "assets/kw_thrust_loss.png",
    [normKwName("ì¬ì¥ì „")]: "assets/kw_reload.png",
    [normKwName("ì¶”ì§„íƒ„")]: "assets/kw_propellant_bullet.png",
    [normKwName("ì§„ë™ - ì‘ì—´")]: "assets/kw_tremor_burn.png",
  };

  return map[n] || "";
}

function getAiSkillImageFallback(skillName){
  const raw = String(skillName || "").trim();
  const n = raw
    .replace(/\s*-\s*ì¶”\[[^\]]+\]\s*$/g, "") // " - ì¶”[æ¨]" ë³€í˜• ì œê±°
    .trim();

  const map = {
    // ì†”ë‹¤í†  II / III ê³µìš© (assets í´ë” íŒŒì¼ëª…)
    "ì§„íƒ• ê¿°ëš«ê¸°": "assets/sk_thumb_soldato_jintang_ggettulgi.png",
    "ì‘ì—´ ê¿°ëš«ê¸°": "assets/sk_thumb_soldato_jakyeol_ggettulgi.png",
    "ì¶”ì§„ ê°€ë¥´ê¸°": "assets/sk_thumb_soldato_chujin_gareugi.png",
    "ì¶”ì§„íƒ„ ì¬ì¥ì „": "assets/sk_thumb_soldato_reload.png"
  };

  return map[n] || map[raw] || "";
}

function findKeywordAny(name){
  const key = String(name || "").trim();
  if(!key) return null;

  const keyNorm = normKwName(key);

  const sameKw = (a, b) => normKwName(a) === normKwName(b);

  // 1) ê¸°ë³¸ í‚¤ì›Œë“œ
  let hit = (Array.isArray(BASE_KEYWORDS) ? BASE_KEYWORDS : []).find(x => sameKw(x?.name, key));
  if(hit){
    return {
      name: hit.name,
      state: hit.state,
      text: hit.text,
      iconSrc: hit.icon || hit.iconSrc || "",
      isDedicated: false,
      iconKey: ""
    };
  }

  // 2) ëŒ€í‘œ í‚¤ì›Œë“œ
  hit = (Array.isArray(REP_KEYWORDS) ? REP_KEYWORDS : []).find(x => sameKw(x?.name, key));
  if(hit){
    return {
      name: hit.name,
      state: hit.state,
      text: hit.text,
      iconSrc: hit.icon || hit.iconSrc || "",
      isDedicated: false,
      iconKey: ""
    };
  }

  // 3) ì „ìš© í‚¤ì›Œë“œ(localStorage)
  const localList = loadDedicatedKeywords?.() || [];
  hit = localList.find(x => sameKw(x?.name, key));
  if(!hit){
    hit = localList.find(x => {
      const n = normKwName(x?.name);
      return n && (n.includes(keyNorm) || keyNorm.includes(n));
    });
  }
  if(hit){
    return {
      name: String(hit.name || "").trim() || key,
      state: (hit.state === "debuff") ? "debuff" : "buff",
      text: String(hit.text || "").trim(),
      iconSrc: hit.iconSrc || hit.icon || getDedicatedKeywordIconFallback(hit.name),
      isDedicated: true,
      iconKey: hit.iconKey || ""
    };
  }

  // 4) ë§¤ì¹˜ ì¤‘ ìºë¦­í„°(JSON) ì „ìš© í‚¤ì›Œë“œ fallback (ì•„êµ°/ì  ë‘˜ ë‹¤)
  try{
    const unitLists = [
      ...(Array.isArray(MATCH_STATE?.my?.raw?.dedicatedKeywords) ? [MATCH_STATE.my.raw.dedicatedKeywords] : []),
      ...(Array.isArray(MATCH_STATE?.enemy?.raw?.dedicatedKeywords) ? [MATCH_STATE.enemy.raw.dedicatedKeywords] : []),
    ];

    for(const arr of unitLists){
      let loose = arr.find(x => sameKw(x?.name, key));
      if(!loose){
        loose = arr.find(x => {
          const n = normKwName(x?.name);
          return n && (n.includes(keyNorm) || keyNorm.includes(n));
        });
      }

      if(loose){
        const kwName = String(loose.name || "").trim() || key;
        return {
          name: kwName,
          state: (loose.state === "debuff") ? "debuff" : "buff",
          text: String(loose.text || "").trim(),
          iconSrc: loose.iconSrc || loose.icon || getDedicatedKeywordIconFallback(kwName),
          isDedicated: true,
          iconKey: loose.iconKey || ""
        };
      }
    }
  }catch(e){}

  return null;
}

async function showKwTipFor(name, stateHint, clientX, clientY){
  const info = findKeywordAny(name);

  const titleText = String(name || "").trim() || "í‚¤ì›Œë“œ";
  kwTipTitle.textContent = titleText;

  // âœ… ìƒ‰: ì°¾ì€ state ìš°ì„ , ì—†ìœ¼ë©´ í† í°ì˜ data-state íŒíŠ¸ ì‚¬ìš©
  const st = info?.state || (stateHint === "debuff" ? "debuff" : "buff");
  kwTipTitle.classList.remove("buff","debuff");
  kwTipTitle.classList.add(st === "debuff" ? "debuff" : "buff");

  // âœ… í…ìŠ¤íŠ¸
  if(info && info.text){
    kwTipText.textContent = info.text;
  }else{
    kwTipText.textContent = "ìƒì„¸ì •ë³´ë¥¼ ì°¾ì§€ ëª»í–ˆì–´.";
  }

  // âœ… ì•„ì´ì½˜: (ê¸°ë³¸/ëŒ€í‘œ)=assets src, (ì „ìš©)=IndexedDB iconKey
  if(info?.iconSrc){
    kwTipImg.src = info.iconSrc;
    kwTipImg.style.display = "block";
  }else if(info?.isDedicated && info.iconKey){
    try{
      await applyIconKeyToImg(kwTipImg, info.iconKey);
      if(kwTipImg.src){
        kwTipImg.style.display = "block";
      }else{
        const fb = getDedicatedKeywordIconFallback(info?.name || name);
        kwTipImg.src = fb || "";
        kwTipImg.style.display = fb ? "block" : "none";
      }
    }catch(e){
      const fb = getDedicatedKeywordIconFallback(info?.name || name);
      kwTipImg.src = fb || "";
      kwTipImg.style.display = fb ? "block" : "none";
    }
  }else{
    const fb = getDedicatedKeywordIconFallback(info?.name || name);
    kwTipImg.src = fb || "";
    kwTipImg.style.display = fb ? "block" : "none";
  }

  kwTip.classList.remove("hidden");
  kwTip.setAttribute("aria-hidden", "false");

  const pad = 14;
  const offset = 16;

  // ì„ì‹œ ìœ„ì¹˜
  kwTip.style.left = (clientX + offset) + "px";
  kwTip.style.top  = (clientY + offset) + "px";

  // í™”ë©´ ë°”ê¹¥ ë³´ì •
  const rect = kwTip.getBoundingClientRect();
  let x = clientX + offset;
  let y = clientY + offset;

  if(x + rect.width + pad > window.innerWidth) x = clientX - rect.width - offset;
  if(y + rect.height + pad > window.innerHeight) y = clientY - rect.height - offset;

  x = Math.max(pad, Math.min(x, window.innerWidth - rect.width - pad));
  y = Math.max(pad, Math.min(y, window.innerHeight - rect.height - pad));

  kwTip.style.left = x + "px";
  kwTip.style.top  = y + "px";
}

function hideKwTip(){
  kwTip.classList.add("hidden");
  kwTip.setAttribute("aria-hidden", "true");
}

/* âœ… pvBoard ì•ˆì˜ .pvKWì— hoverë¡œë§Œ í‘œì‹œ (ë–¼ë©´ ì¦‰ì‹œ ì‚¬ë¼ì§) */
pvBoard.addEventListener("mousemove", (e) => {
  const t = e.target;
  if(!(t instanceof HTMLElement)) return;

  const kwEl = t.closest(".pvKW");
  if(!kwEl) { hideKwTip(); return; }

  const name = kwEl.getAttribute("data-kw") || kwEl.textContent || "";
  const stateHint = kwEl.getAttribute("data-state") || ""; // âœ… base/repë„ ì—¬ê¸° ë“¤ì–´ìˆìŒ
  showKwTipFor(name, stateHint, e.clientX, e.clientY);
});

/* âœ… í‚¤ì›Œë“œ(span.pvKW)ì—ì„œ ë²—ì–´ë‚˜ë©´ ì¦‰ì‹œ ìˆ¨ê¹€ */
pvBoard.addEventListener("mouseout", (e) => {
  const from = e.target;
  if(!(from instanceof HTMLElement)) return;

  const fromKw = from.closest(".pvKW");
  if(!fromKw) return;

  const to = e.relatedTarget;
  if(to instanceof HTMLElement && to.closest(".pvKW")) return;

  hideKwTip();
});

/* âœ… ë³´ë“œ ìì²´ë¥¼ ë– ë‚˜ë„ ìˆ¨ê¹€ */
pvBoard.addEventListener("mouseleave", hideKwTip);

// âœ… ìŠ¤í‚¬ ëª©ë¡(í†µí•©/ë¶„ë¦¬ ë‘˜ ë‹¤)ì—ì„œ í‚¤ì›Œë“œ íˆ´íŒ ì‘ë™
function bindKwTooltipHover(rootEl){
  if(!rootEl) return;

  rootEl.addEventListener("mousemove", (e) => {
    const t = e.target;
    if(!(t instanceof HTMLElement)) return;

    const kwEl = t.closest(".pvKW");
    if(!kwEl) { hideKwTip(); return; }

    const name = kwEl.getAttribute("data-kw") || kwEl.textContent || "";
    const stateHint = kwEl.getAttribute("data-state") || "";
    showKwTipFor(name, stateHint, e.clientX, e.clientY);
  });

  rootEl.addEventListener("mouseout", (e) => {
    const from = e.target;
    if(!(from instanceof HTMLElement)) return;

    const fromKw = from.closest(".pvKW");
    if(!fromKw) return;

    const to = e.relatedTarget;
    if(to instanceof HTMLElement && to.closest(".pvKW")) return;

    hideKwTip();
  });

  rootEl.addEventListener("mouseleave", hideKwTip);
}

// ê¸°ì¡´ ë‹¨ì¼ ëª©ë¡ + ë¶„ë¦¬ ëª©ë¡ ë‘˜ ë‹¤ ì»¤ë²„
bindKwTooltipHover(skList);
bindKwTooltipHover(skListNormal);
bindKwTooltipHover(skListSpecial);

bindKwTooltipHover(document.getElementById("myKeywordsMini"));
bindKwTooltipHover(document.getElementById("enemyKeywordsMini"));

pvLoadStore();
pvClearEditor();
pvRenderBoard();

function ensureKwTooltipBound(el){
  if(!el) return;
  if(el.dataset.kwTipBound === "1") return;
  if(typeof bindKwTooltipHover === "function"){
    bindKwTooltipHover(el);
    el.dataset.kwTipBound = "1";
  }
}

function toRoman(num){
  const romanMap = [
    { value: 1000, numeral: "M" },
    { value: 900, numeral: "CM" },
    { value: 500, numeral: "D" },
    { value: 400, numeral: "CD" },
    { value: 100, numeral: "C" },
    { value: 90, numeral: "XC" },
    { value: 50, numeral: "L" },
    { value: 40, numeral: "XL" },
    { value: 10, numeral: "X" },
    { value: 9, numeral: "IX" },
    { value: 5, numeral: "V" },
    { value: 4, numeral: "IV" },
    { value: 1, numeral: "I" }
  ];

  let result = "";
  let n = Math.floor(Number(num) || 0);
  if(n <= 0) return "";

  for(const item of romanMap){
    while(n >= item.value){
      result += item.numeral;
      n -= item.value;
    }
  }
  return result;
}

// ===== SKILL =====
const skToast = document.getElementById("skToast");
const skName = document.getElementById("skName");
const skAtkType = document.getElementById("skAtkType");
const skSin = document.getElementById("skSin");
const skTier = document.getElementById("skTier");
const skAtkLevel = document.getElementById("skAtkLevel");
const skGrowth   = document.getElementById("skGrowth");
const skActionTypeBtn = document.getElementById("skSkillTypeBtn");
const skLevelLabel = document.getElementById("skLevelLabel");
const skPrevGrowthBase = document.getElementById("skPrevGrowthBase"); // ê³µê²©ë ˆë²¨ í‘œì‹œ
const skPrevGrowthPlus = document.getElementById("skPrevGrowthPlus"); // ì„±ì¥ê³„ìˆ˜ í‘œì‹œ
const skPrevGrowthSign = document.getElementById("skPrevGrowthSign");
const skPower = document.getElementById("skPower");
const skCoinPower = document.getElementById("skCoinPower");
const skCoinSignBtn = document.getElementById("skCoinSignBtn");
const skWeight = document.getElementById("skWeight");
const skText = document.getElementById("skText");
const skHitSfx = document.getElementById("skHitSfx");
// âœ… ê³µê²©ìœ í˜• ë³€ê²½ ì‹œ: ë¯¸ë¦¬ë³´ê¸°/ìŒì„± UI ì¦‰ì‹œ ê°±ì‹ 
skAtkType?.addEventListener("change", ()=>{
  refreshSkLevelLabelOnly();
  renderSkillPreview();
  try{ if(typeof updateSfxUIVisibility === "function") updateSfxUIVisibility(); }catch(_e){}
  try{ if(typeof refreshSkillSfxInfo === "function") refreshSkillSfxInfo(); }catch(_e){}
  try{ if(typeof renderCoinVoiceListNew === "function") renderCoinVoiceListNew(); else if(typeof renderCoinVoiceList === "function") renderCoinVoiceList(); }catch(_e){}
});
const skHitSfxFile = document.getElementById("skHitSfxFile");
const skHitSfxClear = document.getElementById("skHitSfxClear");
const skHitSfxInfo = document.getElementById("skHitSfxInfo");
const skCoinSfxPathEls = [1,2,3,4,5].map(n=>document.getElementById(`skCoinSfxPath${n}`));
const skCoinSfxFileEls = [1,2,3,4,5].map(n=>document.getElementById(`skCoinSfxFile${n}`));
const skCoinSfxClearEls = [1,2,3,4,5].map(n=>document.getElementById(`skCoinSfxClear${n}`));
const skCoinSfxInfoEls = [1,2,3,4,5].map(n=>document.getElementById(`skCoinSfxInfo${n}`));
const skAutoRulesJson = document.getElementById("skAutoRulesJson");
const skAutoRuleList = document.getElementById("skAutoRuleList");

const arTrigger = document.getElementById("arTrigger");
const arApplyTarget = document.getElementById("arApplyTarget");
const arRefTarget = document.getElementById("arRefTarget");

const arCondType = document.getElementById("arCondType");
const arCondStat = document.getElementById("arCondStat");
const arCondKw1  = document.getElementById("arCondKw1");
const arCondKw2  = document.getElementById("arCondKw2");
const arCondOp   = document.getElementById("arCondOp");
const arCondN    = document.getElementById("arCondN");
const arCondPerN = document.getElementById("arCondPerN");
const arConsumeStat = document.getElementById("arConsumeStat");
const arConsumeN    = document.getElementById("arConsumeN");

const arActType  = document.getElementById("arActType");
const arCap      = document.getElementById("arCap");
const arPowerKind= document.getElementById("arPowerKind");
const arPowerSign= document.getElementById("arPowerSign");
const arPowerAmt = document.getElementById("arPowerAmt");
const arDmgKind  = document.getElementById("arDmgKind");
const arDmgAmt   = document.getElementById("arDmgAmt");
const arActKw    = document.getElementById("arActKw");
const arActKwPowSign = document.getElementById("arActKwPowSign");
const arActKwPow = document.getElementById("arActKwPow");
const arActKwCntSign = document.getElementById("arActKwCntSign");
const arActKwCnt = document.getElementById("arActKwCnt");

const arHitIndex = document.getElementById("arHitIndex");
const arLabel    = document.getElementById("arLabel");
const arVisible  = document.getElementById("arVisible");

const arAddBtn = document.getElementById("arAddBtn");
// cancel edit button (created dynamically to avoid touching HTML)
let arCancelEditBtn = document.getElementById("arCancelEditBtn");
if(!arCancelEditBtn && arAddBtn && arAddBtn.parentElement){
  arCancelEditBtn = document.createElement("button");
  arCancelEditBtn.type = "button";
  arCancelEditBtn.id = "arCancelEditBtn";
  arCancelEditBtn.textContent = "ìˆ˜ì • ì·¨ì†Œ";
  arCancelEditBtn.className = "ghost";
  arCancelEditBtn.style.marginLeft = "8px";
  arCancelEditBtn.style.display = "none";
  arAddBtn.insertAdjacentElement("afterend", arCancelEditBtn);
}
arCancelEditBtn?.addEventListener("click", ()=>{ endEditAutoRule(); toast(skToast, "ìˆ˜ì • ëª¨ë“œë¥¼ ì·¨ì†Œí–ˆì–´."); });

const arPresetPowerBtn = document.getElementById("arPresetPowerBtn");
const arPresetTransferBtn = document.getElementById("arPresetTransferBtn");

const skKindToggle = document.getElementById("skKindToggle");
const skSpawnWrap = document.getElementById("skSpawnWrap");
const skillSpawnChance = document.getElementById("skillSpawnChance");


function updateAutoRuleFieldVisibility(){
  const trg = String(arTrigger?.value || "use");
  const cond = String(arCondType?.value || "none");
  const act  = String(arActType?.value || "powerMod");

  // helper: show/hide by wrapper id
  const setDisp = (id, show)=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.style.display = show ? "" : "none";
  };

  // trigger specific
  const needsHit = (trg === "onHit");
  setDisp("arActRowKw2", true);
  if(arHitIndex){
    const wrap = arHitIndex.closest("div");
    if(wrap) wrap.style.display = needsHit ? "" : "none";
    if(!needsHit) arHitIndex.value = "1";
  }

  // condition inputs
  const needsKw2 = (cond === "kwSumCompare");
  if(arCondKw2){
    const wrap = arCondKw2.closest("div");
    if(wrap) wrap.style.display = needsKw2 ? "" : "none";
  }

  // compare row only for compare/sum
  setDisp("arCondRowCmp", (cond === "kwCompare" || cond === "kwSumCompare"));
  // per row only for per
  setDisp("arCondRowPer", (cond === "kwPer"));
  // consume row only for consume
  setDisp("arCondRowConsume", (cond === "kwConsume"));

  // keyword row shown unless none
  setDisp("arCondRowKw1", (cond !== "none"));

  // action inputs
  setDisp("arActRowPower", act === "powerMod");
  setDisp("arActRowDamage", act === "damageMod");
  setDisp("arActRowKw", act === "keywordMod");
  setDisp("arActRowKw2", act === "keywordMod" || act === "skillChange"); // hitIndex wrapper handled separately
  const note = document.getElementById("arSkillChangeNote");
  if(note) note.style.display = (act === "skillChange") ? "" : "none";

  // ì°¸ì¡°/ì ìš© ëŒ€ìƒì´ noneì´ë©´ ì…ë ¥ ì‹¤ìˆ˜ ì¤„ì´ê¸°
  if(arRefTarget && arRefTarget.value === "none" && cond !== "none"){
    // ì¡°ê±´ì´ ìˆëŠ”ë° refTargetì´ noneì´ë©´ ì‹¤ìˆ˜ ê°€ëŠ¥ì„±ì´ ì»¤ì„œ ìë™ìœ¼ë¡œ selfë¡œ ë˜ëŒë¦¼
    arRefTarget.value = "self";
  }
  if(arApplyTarget && arApplyTarget.value === "none" && act !== "skillChange"){
    // ê²°ê³¼ê°€ ìˆëŠ”ë° ì ìš©ëŒ€ìƒì´ noneì´ë©´ ì˜ë¯¸ ì—†ìœ¼ë‹ˆ ê²½ê³ ì„±ìœ¼ë¡œ selfë¡œ ë˜ëŒë¦¼(ìŠ¤í‚¬ë³€ê²½ë§Œ ì˜ˆì™¸)
    arApplyTarget.value = "self";
  }
}

["change","input"].forEach(ev=>{
  arTrigger?.addEventListener(ev, updateAutoRuleFieldVisibility);
  arApplyTarget?.addEventListener(ev, updateAutoRuleFieldVisibility);
  arRefTarget?.addEventListener(ev, updateAutoRuleFieldVisibility);
  arCondType?.addEventListener(ev, updateAutoRuleFieldVisibility);
  arActType?.addEventListener(ev, updateAutoRuleFieldVisibility);
});

// ì´ˆê¸° 1íšŒ
setTimeout(updateAutoRuleFieldVisibility, 0);
let skCurrentKind = "normal"; // "normal" | "special"

const selectedKindBtn = document.querySelector("#skKindToggle .skKindBtn.active");
const skillKind = selectedKindBtn?.dataset.kind === "special" ? "special" : "normal";

const spawnChanceInput = document.getElementById("skillSpawnChance");
const spawnChance = Math.max(0, Math.min(100, Number(spawnChanceInput?.value || 100)));

const skKeywordBtn = document.getElementById("skKeywordBtn");
skKeywordBtn?.addEventListener("click", () => openKwModalFor(skText));
const skHighlightBtn = document.getElementById("skHighlightBtn");
const skSaveBtn = document.getElementById("skSaveBtn");
const skDeleteBtn = document.getElementById("skDeleteBtn");
const skNewBtn = document.getElementById("skNewBtn");

const skImgFile = document.getElementById("skImgFile");
const skImgClear = document.getElementById("skImgClear");
const skImgEl = document.getElementById("skImgEl");
const skImgPh = document.getElementById("skImgPh");
const skAtkIcon = document.getElementById("skAtkIcon");
const skSinIcon = document.getElementById("skSinIcon");
const skFrameImg = document.getElementById("skFrameImg");
const skInnerImg = document.getElementById("skInnerImg");
const skTitleTxt = document.getElementById("skTitleTxt");
const skTitleBar = document.getElementById("skTitleBar");

const skPrevAtkIcon = document.getElementById("skPrevAtkIcon");
const skPrevSinIcon = document.getElementById("skPrevSinIcon");
const skPrevAtk = document.getElementById("skPrevAtk");
const skPrevSin = document.getElementById("skPrevSin");

const skPrevPow = document.getElementById("skPrevPow");
const skPrevCoin = document.getElementById("skPrevCoin");
const skPrevW = document.getElementById("skPrevW");
const skCoinType = document.getElementById("skCoinType");
const skCoinCount = document.getElementById("skCoinCount");
const skDefenseMode = document.getElementById("skDefenseMode");
const skCoinRow = document.getElementById("skCoinRow");
const skEffectBox = document.getElementById("skEffectBox");

const skGreenBtn = document.getElementById("skGreenBtn");
const skBlueBtn  = document.getElementById("skBlueBtn");
const skRedBtn   = document.getElementById("skRedBtn");

const skCoinEffectBtn = document.getElementById("skCoinEffectBtn");

/** @type {{id:string,name:string,atkType:'slash'|'pierce'|'blunt',sin:string,tier:number,atkLevel:number,growth:number,qty:number,power:number,coinSign:'+'|'-',coinPower:number,weight:number,text:string,imgKey:string,coinType?:string,coinCount?:number}[]} */
let skills = [];
let activeSkId = null;
  window.activeSkId = activeSkId;
window.skills = skills;
window.activeSkId = activeSkId;
let skPendingImgDataURL = "";
let currentAutoRules = [];
let skPendingHitSfxFile = null;
let skHitSfxWasCleared = false;
let skPendingCoinSfxFiles = [null,null,null,null,null];
let activeCoinVoiceSlots = new Set();
let skCoinVoiceDrafts = Array.from({length:5}, ()=>({path:"", key:"", name:""}));

function getSkillById(id){
  return id ? skills.find(x => x.id === id) || null : null;
}

function blankVoiceDraft(){ return { path:"", key:"", name:"" }; }

function hydrateVoiceDraftsFromSkill(skill){
  const src = skill || {};
  skCoinVoiceDrafts = Array.from({length:5}, (_,i)=>({
    path: Array.isArray(src.coinSfxPaths) ? String(src.coinSfxPaths[i] || "") : "",
    key:  Array.isArray(src.coinSfxKeys)  ? String(src.coinSfxKeys[i]  || "") : "",
    name: Array.isArray(src.coinSfxNames) ? String(src.coinSfxNames[i] || "") : "",
  }));
  activeCoinVoiceSlots = new Set();
  skCoinVoiceDrafts.forEach((d,i)=>{
    if((d.path && String(d.path).trim()) || d.key) activeCoinVoiceSlots.add(i+1);
  });
}

function normalizeAutoRule(rule){
  const r = rule || {};

  // v2 (ê°œí¸)
  if(Number(r.v||0) === 2 || r.condType || r.actType){
    return {
      v: 2,
      trigger: String(r.trigger || "use"),
      applyTarget: String(r.applyTarget || "self"),
      refTarget: String(r.refTarget || "self"),

      // condition
      condType: String(r.condType || "none"),
      condStat: String(r.condStat || "power"),
      kw1: String(r.kw1 || r.condKw1 || "").trim(),
      kw2: String(r.kw2 || r.condKw2 || "").trim(),
      op: String(r.op || ">="),
      n: Number(r.n || 0) || 0,
      perN: Math.max(1, Number(r.perN || 1) || 1),
      consumeStat: String(r.consumeStat || "power"),
      consumeN: Math.max(0, Number(r.consumeN || 0) || 0),

      // action
      actType: String(r.actType || "powerMod"),
      cap: Math.max(0, Number(r.cap || 0) || 0),

      powerKind: String(r.powerKind || "attackPower"),
      powerAmt: Number(r.powerAmt || 0) || 0,

      dmgKind: String(r.dmgKind || "dealUp"),
      dmgAmt: Number(r.dmgAmt || 0) || 0,

      actKw: String(r.actKw || "").trim(),
      actKwPow: Number(r.actKwPow || 0) || 0,
      actKwCnt: Number(r.actKwCnt || 0) || 0,

      hitIndex: Math.max(1, Number(r.hitIndex || 1) || 1),
      visible: (String(r.visible ?? "1") === "0") ? 0 : 1,
      label: String(r.label || "").trim(),
    };
  }

  // v1 (ë ˆê±°ì‹œ) -> ë‚´ë¶€ì—ì„œ ê³„ì† ì§€ì›
  return {
    v: 1,
    trigger: String(r.trigger || "use"),
    applyTarget: String(r.applyTarget || r.target || "self"),
    refTarget: String(r.refTarget || "self"),
    from: String(r.from || "fixed"),
    effect: String(r.effect || "basePower"),
    name: String(r.name || "").trim(),
    name2: String(r.name2 || "").trim(),
    value: Number(r.value || 0) || 0,
    per: Math.max(1, Number(r.per || 1) || 1),
    max: Number(r.max || 0) || 0,
    hitIndex: Math.max(1, Number(r.hitIndex || 1) || 1),
    visible: (String(r.visible ?? "1") === "0") ? 0 : 1,
    label: String(r.label || "").trim(),
  };
}

function syncAutoRulesJson(){
  if(skAutoRulesJson) skAutoRulesJson.value = JSON.stringify(currentAutoRules, null, 2);
}

function autoRuleSummary(r0){
  const r = normalizeAutoRule(r0);

  if(r.v === 1){
    const trgMap = {use:"ì‚¬ìš©ì‹œ", clashWin:"í•© ìŠ¹ë¦¬", clashLose:"í•© íŒ¨ë°°", onHit:"ì ì¤‘ì‹œ"};
    const tgtMap = {self:"ìì‹ ", target:"ìƒëŒ€", none:"ì—†ìŒ"};
    const effMap = {basePower:"ê¸°ë³¸ ìœ„ë ¥", coinPower:"ì½”ì¸ ìœ„ë ¥", clashPower:"í•© ìœ„ë ¥", consumeKeyword:"í‚¤ì›Œë“œ ì†Œëª¨", grantKeyword:"í‚¤ì›Œë“œ ë¶€ì—¬"};
    const fromMap = {fixed:"ê³ ì •ê°’", debuffCount:"ë””ë²„í”„ ê°œìˆ˜", keywordPower:"í‚¤ì›Œë“œ ìœ„ë ¥", keywordCount:"í‚¤ì›Œë“œ íšŸìˆ˜", keywordCountPer:"í‚¤ì›Œë“œ Në‹¹", keywordPowerPlusCount:"í‚¤ì›Œë“œ ìœ„ë ¥+íšŸìˆ˜"};
    const bits = [`[${trgMap[r.trigger]||r.trigger}]`, `ì ìš©:${tgtMap[r.applyTarget]||r.applyTarget}`, `ì°¸ì¡°:${tgtMap[r.refTarget]||r.refTarget}`, fromMap[r.from]||r.from, effMap[r.effect]||r.effect];
    if(r.name) bits.push(`í‚¤ì›Œë“œ1 ${r.name}`);
    if(r.name2) bits.push(`í‚¤ì›Œë“œ2 ${r.name2}`);
    if(r.from==="keywordCountPer") bits.push(`Në‹¹ ${r.per||1}`);
    if(r.trigger==="onHit") bits.push(`ì½”ì¸ ${r.hitIndex}`);
    bits.push(`ê°’ ${r.value}`);
    if(r.max>0) bits.push(`ìµœëŒ€ ${r.max}`);
    return bits.join(' / ');
  }

  // v2
  const trgMap = {use:"ì‚¬ìš©ì‹œ", onHit:"ì ì¤‘ì‹œ", clashWin:"í•© ìŠ¹ë¦¬", clashLose:"í•© íŒ¨ë°°", always:"ìƒì‹œ"};
  const tgtMap = {self:"ìì‹ ", target:"ìƒëŒ€", none:"ì—†ìŒ"};
  const statMap = {power:"ìœ„ë ¥", count:"íšŸìˆ˜", powerPlusCount:"ìœ„ë ¥+íšŸìˆ˜"};
  const opMap = {">=":"ì´ìƒ", "<=":"ì´í•˜"};
  const condMap = {
    none:"(ì¡°ê±´ ì—†ìŒ)",
    kwCompare:"í‚¤ì›Œë“œ N ì´ìƒ/ì´í•˜",
    kwPer:"í‚¤ì›Œë“œ Në§ˆë‹¤",
    kwSumCompare:"ë‘ í‚¤ì›Œë“œ í•© N ì´ìƒ/ì´í•˜",
    kwConsume:"í‚¤ì›Œë“œ N ì†Œëª¨"
  };
  const actMap = {powerMod:"ìœ„ë ¥ ì¦ê°", damageMod:"í”¼í•´ëŸ‰ ì¦ê°", keywordMod:"í‚¤ì›Œë“œ ì¦ê°", skillChange:"ìŠ¤í‚¬ ë³€ê²½"};
  const powerKindMap = {
    attackPower:"ê³µê²© ìœ„ë ¥",
    clashPower:"í•© ìœ„ë ¥",
    basePower:"ê¸°ë³¸ ìœ„ë ¥",
    plusCoinPower:"ë”í•˜ê¸° ì½”ì¸",
    minusCoinPower:"ë¹¼ê¸° ì½”ì¸",
    defensePower:"ìˆ˜ë¹„ ìœ„ë ¥"
  };
  const dmgKindMap = {dealUp:"í”¼í•´ëŸ‰ ì¦ê°€", dealDown:"í”¼í•´ëŸ‰ ê°ì†Œ"};

  const bits = [`[${trgMap[r.trigger]||r.trigger}]`, `ì ìš©:${tgtMap[r.applyTarget]||r.applyTarget}`, `ì°¸ì¡°:${tgtMap[r.refTarget]||r.refTarget}`];

  // condition
  if(r.condType === "none"){
    bits.push(condMap.none);
  }else if(r.condType === "kwPer"){
    bits.push(`${condMap.kwPer}: ${r.kw1} ${statMap[r.condStat]||r.condStat} ${r.perN}ë‹¹ Ã— (ìº¡ ${r.cap||0||'âˆ'})`);
  }else if(r.condType === "kwSumCompare"){
    bits.push(`${condMap.kwSumCompare}: (${r.kw1}+${r.kw2}) ${statMap[r.condStat]||r.condStat} ${opMap[r.op]||r.op} ${r.n}`);
  }else if(r.condType === "kwConsume"){
    bits.push(`${condMap.kwConsume}: ${r.kw1} ${r.consumeStat==="count"?"íšŸìˆ˜":"ìœ„ë ¥"} ${r.consumeN}`);
  }else{
    bits.push(`${condMap.kwCompare}: ${r.kw1} ${statMap[r.condStat]||r.condStat} ${opMap[r.op]||r.op} ${r.n}`);
  }

  // action
  if(r.actType === "powerMod"){
    bits.push(`${actMap.powerMod}: ${powerKindMap[r.powerKind]||r.powerKind} ${r.powerAmt>=0?`+${r.powerAmt}`:String(r.powerAmt)}`);
  }else if(r.actType === "damageMod"){
    bits.push(`${actMap.damageMod}: ${dmgKindMap[r.dmgKind]||r.dmgKind} ${r.dmgAmt>=0?`+${r.dmgAmt}`:String(r.dmgAmt)}(ìŠ¤íƒ)`);
  }else if(r.actType === "keywordMod"){
    bits.push(`${actMap.keywordMod}: ${r.actKw} ${r.actKwPow?`ìœ„ë ¥ ${r.actKwPow>=0?`+${r.actKwPow}`:r.actKwPow}`:''}${r.actKwCnt?` / íšŸìˆ˜ ${r.actKwCnt>=0?`+${r.actKwCnt}`:r.actKwCnt}`:''}`.trim());
  }else{
    bits.push(`${actMap.skillChange} (ì‹¤í–‰ ì ê¸ˆ)`);
  }

  if(r.trigger === "onHit") bits.push(`ì½”ì¸ ${r.hitIndex}`);
  if(r.cap > 0 && r.condType !== "kwPer") bits.push(`ìº¡ ${r.cap}`);
  return bits.join(" / ");
}

// --- Auto Rule Edit/Copy helpers ---
let __autoRuleEditingIdx = -1;

function loadAutoRuleToForm(r0){
  const r = normalizeAutoRule(r0);
  if(!r) return;

  if(arTrigger) arTrigger.value = r.trigger || "use";
  if(arApplyTarget) arApplyTarget.value = r.applyTarget || "self";
  if(arRefTarget) arRefTarget.value = r.refTarget || "self";

  if(r.v === 1){
    // v1 -> v2 í¼ìœ¼ë¡œ ìµœëŒ€í•œ ì´ì‹
    if(arCondType) arCondType.value = "none";
    if(arCondStat) arCondStat.value = "power";
    if(arCondKw1) arCondKw1.value = r.name || "";
    if(arCondKw2) arCondKw2.value = r.name2 || "";
    if(arCondOp) arCondOp.value = ">=";
    if(arCondN) arCondN.value = "1";
    if(arCondPerN) arCondPerN.value = String(r.per || 1);
    if(arConsumeStat) arConsumeStat.value = "power";
    if(arConsumeN) arConsumeN.value = "0";

    if(arActType) arActType.value = (r.effect === "grantKeyword") ? "keywordMod" : "powerMod";
    if(arCap) arCap.value = String(r.max || 0);

    if(arPowerKind) arPowerKind.value = (r.effect === "coinPower") ? "plusCoinPower" : (r.effect==="clashPower") ? "clashPower" : "basePower";
    if(arPowerSign) arPowerSign.value = (Number(r.value||0) < 0) ? "-1" : "1";
    if(arPowerAmt) arPowerAmt.value = String(Math.abs(Number(r.value || 0) || 0));

    if(arDmgKind) arDmgKind.value = "dealUp";
    if(arDmgAmt) arDmgAmt.value = "1";

    if(arActKw) arActKw.value = r.name2 || r.name || "";
    if(arActKwPowSign) arActKwPowSign.value = (Number(r.value||0) < 0) ? "-1" : "1";
    if(arActKwPow) arActKwPow.value = String(Math.abs(Number(r.value || 0) || 0));
    if(arActKwCntSign) arActKwCntSign.value = (Number(r.max||0) < 0) ? "-1" : "1";
    if(arActKwCnt) arActKwCnt.value = String(Math.abs(Number(r.max || 0) || 0));

    if(arHitIndex) arHitIndex.value = String(r.hitIndex || 1);
    if(arVisible) arVisible.value = String(r.visible ?? 1);
    if(arLabel) arLabel.value = r.label || "";
  }else{
    if(arCondType) arCondType.value = r.condType || "none";
    if(arCondStat) arCondStat.value = r.condStat || "power";
    if(arCondKw1) arCondKw1.value = r.kw1 || "";
    if(arCondKw2) arCondKw2.value = r.kw2 || "";
    if(arCondOp) arCondOp.value = r.op || ">=";
    if(arCondN) arCondN.value = String(Number(r.n||0));
    if(arCondPerN) arCondPerN.value = String(Math.max(1, Number(r.perN||1)||1));
    if(arConsumeStat) arConsumeStat.value = r.consumeStat || "power";
    if(arConsumeN) arConsumeN.value = String(Math.max(0, Number(r.consumeN||0)||0));

    if(arActType) arActType.value = r.actType || "powerMod";
    if(arCap) arCap.value = String(Math.max(0, Number(r.cap||0)||0));

    if(arPowerKind) arPowerKind.value = r.powerKind || "attackPower";
    if(arPowerSign) arPowerSign.value = (Number(r.powerAmt||0) < 0) ? "-1" : "1";
    if(arPowerAmt) arPowerAmt.value = String(Math.abs(Number(r.powerAmt||0) || 0));

    if(arDmgKind) arDmgKind.value = r.dmgKind || "dealUp";
    if(arDmgAmt) arDmgAmt.value = String(Number(r.dmgAmt||0));

    if(arActKw) arActKw.value = r.actKw || "";
    if(arActKwPowSign) arActKwPowSign.value = (Number(r.actKwPow||0) < 0) ? "-1" : "1";
    if(arActKwPow) arActKwPow.value = String(Math.abs(Number(r.actKwPow||0) || 0));
    if(arActKwCntSign) arActKwCntSign.value = (Number(r.actKwCnt||0) < 0) ? "-1" : "1";
    if(arActKwCnt) arActKwCnt.value = String(Math.abs(Number(r.actKwCnt||0) || 0));

    if(arHitIndex) arHitIndex.value = String(r.hitIndex || 1);
    if(arVisible) arVisible.value = String(r.visible ?? 1);
    if(arLabel) arLabel.value = r.label || "";
  }

  updateAutoRuleFieldVisibility();
}

function beginEditAutoRule(idx){
  const r = currentAutoRules[idx];
  if(!r) return;
  __autoRuleEditingIdx = idx;
  loadAutoRuleToForm(r);
  if(arAddBtn) arAddBtn.textContent = "ìˆ˜ì • ì €ì¥";
  const cancelBtn = document.getElementById("arCancelEditBtn");
  if(cancelBtn) cancelBtn.style.display = "";
  toast(skToast, "ê·œì¹™ì„ ìˆ˜ì • ëª¨ë“œë¡œ ë¶ˆëŸ¬ì™”ì–´. ê°’ ë°”ê¾¸ê³  'ìˆ˜ì • ì €ì¥'ì„ ëˆŒëŸ¬.");
}

function endEditAutoRule(){
  __autoRuleEditingIdx = -1;
  if(arAddBtn) arAddBtn.textContent = "ê·œì¹™ ì¶”ê°€";
  const cancelBtn = document.getElementById("arCancelEditBtn");
  if(cancelBtn) cancelBtn.style.display = "none";
}

function duplicateAutoRule(idx){
  const r = currentAutoRules[idx];
  if(!r) return;
  const copy = JSON.parse(JSON.stringify(r));
  if(copy.label) copy.label = String(copy.label) + " (ë³µì‚¬)";
  currentAutoRules.splice(idx+1, 0, copy);
  renderAutoRuleEditor();
  toast(skToast, "ê·œì¹™ì„ ë³µì‚¬í–ˆì–´.");
}
// --- /Auto Rule Edit/Copy helpers ---

function renderAutoRuleEditor(){
  if(!skAutoRuleList) return;
  syncAutoRulesJson();
  if(!currentAutoRules.length){
    skAutoRuleList.innerHTML = `<div class="toast" style="display:block;">ì•„ì§ ìë™ ê·œì¹™ì´ ì—†ì–´.</div>`;
    return;
  }
  skAutoRuleList.innerHTML = currentAutoRules.map((r0, idx)=>{
    const r = normalizeAutoRule(r0);
    const title = r.label ? escHtml(r.label) : escHtml(autoRuleSummary(r));
    return `
      <div class="miniBlock" data-ar-idx="${idx}">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
          <div style="font-weight:900; color:rgba(243,211,154,.95);">${title}</div>
          <div style="display:flex; gap:8px; align-items:center;">
            <button type="button" class="ghost arEditBtn" data-ar-edit="${idx}">í¸ì§‘</button>
            <button type="button" class="ghost arCopyBtn" data-ar-copy="${idx}">ë³µì‚¬</button>
            <button type="button" class="ghost arDelBtn" data-ar-del="${idx}">ì‚­ì œ</button>
          </div>
        </div>
        <div style="margin-top:6px; color:var(--muted); font-size:12px; line-height:1.45;">
          ${escHtml(autoRuleSummary(r))}${r.visible ? '' : ' Â· (ìˆ¨ê¹€)'}
        </div>
      </div>
    `;
  }).join('');

  skAutoRuleList.querySelectorAll('.arDelBtn').forEach(btn=>btn.addEventListener('click', ()=>{
    const i = Number(btn.dataset.arDel||-1);
    if(i<0) return;
    if(__autoRuleEditingIdx===i){ endEditAutoRule(); }
    if(__autoRuleEditingIdx>i){ __autoRuleEditingIdx--; }
    currentAutoRules.splice(i,1);
    renderAutoRuleEditor();
  }));

  skAutoRuleList.querySelectorAll('.arEditBtn').forEach(btn=>btn.addEventListener('click', ()=>{
    const i = Number(btn.dataset.arEdit||-1);
    if(i<0) return;
    beginEditAutoRule(i);
  }));

  skAutoRuleList.querySelectorAll('.arCopyBtn').forEach(btn=>btn.addEventListener('click', ()=>{
    const i = Number(btn.dataset.arCopy||-1);
    if(i<0) return;
    duplicateAutoRule(i);
  }));
}

function buildAutoRuleFromForm(){
  const trigger = String(arTrigger?.value || "use");
  const applyTarget = String(arApplyTarget?.value || "self");
  const refTarget = String(arRefTarget?.value || "self");

  const condType = String(arCondType?.value || "none");
  const condStat = String(arCondStat?.value || "power");
  const kw1 = String(arCondKw1?.value || "").trim();
  const kw2 = String(arCondKw2?.value || "").trim();
  const op = String(arCondOp?.value || ">=");
  const n = Number(arCondN?.value || 0) || 0;
  const perN = Math.max(1, Number(arCondPerN?.value || 1) || 1);
  const consumeStat = String(arConsumeStat?.value || "power");
  const consumeN = Math.max(0, Number(arConsumeN?.value || 0) || 0);

  const actType = String(arActType?.value || "powerMod");
  const cap = Math.max(0, Number(arCap?.value || 0) || 0);

  const powerKind = String(arPowerKind?.value || "attackPower");
  const powerSign = Number(arPowerSign?.value || 1) || 1;
  const powerAmtRaw = Math.max(0, Number(arPowerAmt?.value || 0) || 0);
  const powerAmt = powerAmtRaw * (powerSign < 0 ? -1 : 1);

  const dmgKind = String(arDmgKind?.value || "dealUp");
  const dmgAmt = Number(arDmgAmt?.value || 0) || 0;

  const actKw = String(arActKw?.value || "").trim();
  const actKwPowSign = Number(arActKwPowSign?.value || 1) || 1;
  const actKwCntSign = Number(arActKwCntSign?.value || 1) || 1;
  const actKwPowRaw = Math.max(0, Number(arActKwPow?.value || 0) || 0);
  const actKwCntRaw = Math.max(0, Number(arActKwCnt?.value || 0) || 0);
  const actKwPow = actKwPowRaw * (actKwPowSign < 0 ? -1 : 1);
  const actKwCnt = actKwCntRaw * (actKwCntSign < 0 ? -1 : 1);

  const hitIndex = Math.max(1, Number(arHitIndex?.value || 1) || 1);
  const visible = (String(arVisible?.value || "1") === "0") ? 0 : 1;
  const label = String(arLabel?.value || "").trim();

  return normalizeAutoRule({
    v: 2,
    trigger, applyTarget, refTarget,
    condType, condStat, kw1, kw2, op, n, perN, consumeStat, consumeN,
    actType, cap, powerKind, powerAmt, dmgKind, dmgAmt, actKw, actKwPow, actKwCnt,
    hitIndex, visible, label
  });
}

function addAutoRuleFromEditor(preset){
  const rule = preset ? normalizeAutoRule(preset) : buildAutoRuleFromForm();
  if(__autoRuleEditingIdx>=0 && __autoRuleEditingIdx<currentAutoRules.length){
    currentAutoRules[__autoRuleEditingIdx] = rule;
    endEditAutoRule();
  }else{
    currentAutoRules.push(rule);
  }
  renderAutoRuleEditor();
}
function refreshSkillSfxInfo(baseSkill=null){
  const skill = baseSkill || getSkillById(activeSkId) || null;

  if(skHitSfxInfo){
    if(skPendingHitSfxFile){
      skHitSfxInfo.textContent = `ì„ íƒë¨: ${skPendingHitSfxFile.name}`;
    }else if((skHitSfx?.value || '').trim()){
      skHitSfxInfo.textContent = `ê²½ë¡œ ì§€ì •ë¨: ${(skHitSfx.value || '').trim()}`;
    }else if(skill?.hitSfxKey){
      const nm = skill.hitSfxName || 'ì—…ë¡œë“œ ìŒì„±';
      skHitSfxInfo.textContent = `ì €ì¥ëœ íŒŒì¼: ${nm}`;
    }else if((skill?.hitSfx || '').trim()){
      skHitSfxInfo.textContent = `ê²½ë¡œ ì§€ì •ë¨: ${(skill.hitSfx || '').trim()}`;
    }else{
      skHitSfxInfo.textContent = 'ì—…ë¡œë“œëœ íŒŒì¼ ì—†ìŒ';
    }
  }
}

function renderCoinVoiceList(baseSkill=null){
  if(!skCoinVoiceList) return;
  const skill = baseSkill || getSkillById(activeSkId) || null;
  const slots = Array.from(activeCoinVoiceSlots).sort((a,b)=>a-b);
  skCoinVoiceList.innerHTML = '';
  if(skCoinVoiceEmpty) skCoinVoiceEmpty.style.display = slots.length ? 'none' : 'block';

  slots.forEach((slot)=>{
    const idx = slot - 1;
    const draft = skCoinVoiceDrafts[idx] || blankVoiceDraft();
    const row = document.createElement('div');
    row.className = 'miniBlock';
    row.innerHTML = `
      <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
        <div style="font-weight:800;color:rgba(243,211,154,.95);">${slot}ì½”ì¸ ìŒì„±</div>
        <button type="button" class="ghost" data-remove-slot="${slot}">ì œê±°</button>
      </div>
      <div style="margin-top:8px;">
        <input class="textInput" id="skCoinVoicePathLive${slot}" type="text" placeholder="ì˜ˆ: assets/voice_coin_${slot}.mp3 (ì„ íƒ)" />
      </div>
      <div class="dkButtons" style="margin-top:8px;">
        <button class="primary file" type="button">íš¨ê³¼ìŒ íŒŒì¼ ì—…ë¡œë“œ<input id="skCoinVoiceFileLive${slot}" type="file" accept="audio/*" /></button>
      </div>
      <div id="skCoinVoiceInfoLive${slot}" style="margin-top:6px; color:var(--muted); font-size:12px;">ì—…ë¡œë“œëœ íŒŒì¼ ì—†ìŒ</div>
    `;
    skCoinVoiceList.appendChild(row);

    const livePath = row.querySelector(`#skCoinVoicePathLive${slot}`);
    const liveFile = row.querySelector(`#skCoinVoiceFileLive${slot}`);
    const liveInfo = row.querySelector(`#skCoinVoiceInfoLive${slot}`);

    if(livePath) livePath.value = draft.path || '';

    const refreshOne = ()=>{
      const cur = skCoinVoiceDrafts[idx] || blankVoiceDraft();
      if(skPendingCoinSfxFiles[idx]){
        liveInfo.textContent = `ì„ íƒë¨: ${skPendingCoinSfxFiles[idx].name}`;
      }else if((cur.path || '').trim()){
        liveInfo.textContent = `ê²½ë¡œ ì§€ì •ë¨: ${cur.path.trim()}`;
      }else if(cur.key){
        liveInfo.textContent = `ì €ì¥ëœ íŒŒì¼: ${cur.name || `ì½”ì¸${slot} ìŒì„±`}`;
      }else if(skill?.coinSfxKeys?.[idx]){
        liveInfo.textContent = `ì €ì¥ëœ íŒŒì¼: ${skill.coinSfxNames?.[idx] || `ì½”ì¸${slot} ìŒì„±`}`;
      }else{
        liveInfo.textContent = 'ì—…ë¡œë“œëœ íŒŒì¼ ì—†ìŒ';
      }
    };
    refreshOne();

    livePath?.addEventListener('input', ()=>{
      skCoinVoiceDrafts[idx] = {
        ...(skCoinVoiceDrafts[idx] || blankVoiceDraft()),
        path: livePath.value || ''
      };
      refreshOne();
      renderSkillPreview();
    });

    liveFile?.addEventListener('change', (e)=>{
      skPendingCoinSfxFiles[idx] = e.target.files && e.target.files[0] ? e.target.files[0] : null;
      refreshOne();
    });

    row.querySelector('[data-remove-slot]')?.addEventListener('click', ()=>{
      activeCoinVoiceSlots.delete(slot);
      skPendingCoinSfxFiles[idx] = null;
      skCoinVoiceDrafts[idx] = blankVoiceDraft();
      renderCoinVoiceList(skill);
      renderSkillPreview();
    });
  });
}

async function playSkillAudioSpec(path, key, vol=0.72){
  try{
    if(path){
      playMatchSfx(path, vol);
      return true;
    }
    if(key){
      const blob = await idbGetBlob(key);
      if(blob){
        const url = URL.createObjectURL(blob);
        const a = new Audio(url);
        a.volume = vol;
        a.play().catch(()=>{});
        a.addEventListener('ended', ()=>{ try{ URL.revokeObjectURL(url); }catch(_){} }, {once:true});
        return true;
      }
    }
  }catch(_){}
  return false;
}

function pickEvadeVoiceSpec(skill, kind){
  try{
    const parity = (kind === 'fail') ? 1 : 0;

    // 1) ìš°ì„ ìˆœìœ„: ë°œë™ ì‹œ ìŒì„± ë°°ì—´(íšŒí”¼ ëª¨ë“œì—ì„œ ì„±ê³µ/ì‹¤íŒ¨ ìŒì„± í’€ë¡œ ì‚¬ìš©)
    const aPaths = Array.isArray(skill?.activationSfxPaths) ? skill.activationSfxPaths : [];
    const aKeys  = Array.isArray(skill?.activationSfxKeys)  ? skill.activationSfxKeys  : [];
    const aMax = Math.max(aPaths.length, aKeys.length);
    const aCands = [];
    for(let i=parity;i<aMax;i+=2){
      const p = String(aPaths[i]||'');
      const k = String(aKeys[i]||'');
      if(p || k) aCands.push({path:p, key:k});
    }
    if(aCands.length){
      return aCands[Math.floor(Math.random()*aCands.length)];
    }

    // 2) í´ë°±: ì½”ì¸ ìŒì„± ë°°ì—´(ìˆë‹¤ë©´ ë™ì¼ ê·œì¹™ ì ìš©)
    const cPaths = Array.isArray(skill?.coinSfxPaths) ? skill.coinSfxPaths : [];
    const cKeys  = Array.isArray(skill?.coinSfxKeys)  ? skill.coinSfxKeys  : [];
    const cMax = Math.max(cPaths.length, cKeys.length);
    const cCands = [];
    for(let i=parity;i<cMax;i+=2){
      const p = String(cPaths[i]||'');
      const k = String(cKeys[i]||'');
      if(p || k) cCands.push({path:p, key:k});
    }
    if(cCands.length){
      return cCands[Math.floor(Math.random()*cCands.length)];
    }

    // 3) ìµœí›„ í´ë°±: ë‹¨ì¼ ê²½ë¡œ
    if(kind === 'fail'){
      const p = String(skill?.evadeFailSfxPath||'');
      return {path:p, key:''};
    }else{
      const p = String(skill?.evadeSuccessSfxPath||'');
      return {path:p, key:''};
    }
  }catch(_){}
  return {path:'', key:''};
}


function skUid(){
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}

function setSkillKind(kind){
  skCurrentKind = (kind === "special") ? "special" : "normal";

  // ë²„íŠ¼ active í‘œì‹œ
  document.querySelectorAll(".skKindBtn").forEach(btn => {
    btn.classList.toggle("active", btn.dataset.kind === skCurrentKind);
  });

  // ì¼ë°˜ ìŠ¤í‚¬ì¼ ë•Œë§Œ ë“±ì¥ í™•ë¥  í™œì„±í™”
  const isNormal = skCurrentKind === "normal";
  if(skSpawnWrap){
    skSpawnWrap.classList.toggle("disabled", !isNormal);
  }
  if(skillSpawnChance){
    skillSpawnChance.disabled = !isNormal;
    if(!isNormal){
      // íŠ¹ìˆ˜ìŠ¤í‚¬ì´ë©´ ì‚¬ì‹¤ìƒ ì˜ë¯¸ ì—†ìŒ (í‘œì‹œë§Œ ìœ ì§€í•´ë„ ë˜ê³  100ìœ¼ë¡œ ê³ ì •í•´ë„ ë¨)
      // skillSpawnChance.value = "100";
    }
  }
}

function clampSkillSpawn(v){
  const n = Number(v);
  if(!Number.isFinite(n)) return 100;
  return Math.max(0, Math.min(100, Math.round(n)));
}

function skSaveStore(){
  try{
    // âœ… localStorageì—ëŠ” "ê°€ë²¼ìš´ ë°ì´í„°ë§Œ" ì €ì¥í•œë‹¤ (ì´ë¯¸ì§€ëŠ” imgKeyë§Œ)
    const compact = skills.map(s => ({
      id: s.id,
      name: s.name || "",
      atkType: s.atkType || "pierce",
      sin: s.sin || "pride",
      tier: Number(s.tier || 1),
      power: Number(s.power || 0),
      coinSign: (s.coinSign === "-") ? "-" : "+",
      coinPower: Number(s.coinPower || 0),
      atkLevel: Number(s.atkLevel || 0),
      growth: Number(s.growth || 0),
      weight: Number(s.weight || 0),
kind: (s.kind === "special") ? "special" : "normal",
actionType: (s.actionType === "defense") ? "defense" : "attack",
spawnChance: clampSkillSpawn(s.spawnChance ?? 100),
      coinType: s.coinType || "normal",
      coinCount: Number(s.coinCount || 1),
      text: s.text || "",
      hitSfx: s.hitSfx || "",
      hitSfxKey: s.hitSfxKey || "",
      hitSfxName: s.hitSfxName || "",
      coinSfxPaths: Array.isArray(s.coinSfxPaths) ? s.coinSfxPaths.slice(0,5) : ["","","","",""],
      coinSfxKeys: Array.isArray(s.coinSfxKeys) ? s.coinSfxKeys.slice(0,5) : ["","","","",""],
      coinSfxNames: Array.isArray(s.coinSfxNames) ? s.coinSfxNames.slice(0,5) : ["","","","",""],
      autoRules: Array.isArray(s.autoRules) ? s.autoRules.map(normalizeAutoRule) : [],
      imgKey: s.imgKey || "" // âœ… í‚¤ë§Œ!
    }));

    const raw = JSON.stringify(compact);
    localStorage.setItem(KEY_SK, raw);

    const ok = localStorage.getItem(KEY_SK);
    if(ok !== raw) throw new Error("localStorage write verify failed");

    return true;
  }catch(e){
    console.error("SK ì €ì¥ ì‹¤íŒ¨:", e);
    const isQuota =
      String(e?.name || "").includes("Quota") ||
      String(e || "").includes("Quota") ||
      String(e || "").includes("QUOTA");

    const msg = isQuota
      ? "ìŠ¤í‚¬ ì €ì¥ ì‹¤íŒ¨: ë¸Œë¼ìš°ì € ì €ì¥ê³µê°„(localStorage)ì´ ê½‰ ì°¼ì–´. (í° ë¬¸ìì—´ì´ ì„ì˜€ì„ ê°€ëŠ¥ì„± ë†’ìŒ)"
      : "ìŠ¤í‚¬ ì €ì¥ ì‹¤íŒ¨: ë¸Œë¼ìš°ì €ê°€ ì €ì¥ì„ ë§‰ì•˜ê±°ë‚˜(ì‹œí¬ë¦¿/ê¶Œí•œ), ì½”ë“œ ì—ëŸ¬ê°€ ìˆì–´.";

    try{ toast(skToast, msg); }catch(_){}
    return false;
  }
}

function skLoadStore(){
  try{
    const raw = localStorage.getItem(KEY_SK);
    if(!raw){
      skills = [];
      window.skills = skills;
      return;
    }
    const saved = JSON.parse(raw);
    skills = Array.isArray(saved) ? saved : [];
    window.skills = skills;
  }catch(e){
    console.error("SK ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:", e);
    skills = [];
    window.skills = skills;
    try{ toast(skToast, "ìŠ¤í‚¬ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ì €ì¥ ë°ì´í„°ê°€ ê¹¨ì¡Œê±°ë‚˜ JSON íŒŒì‹± ì˜¤ë¥˜ì•¼."); }catch(_){}
  }
}

function setSkImgPreview(src){
  if(!src){
    skImgEl.style.display = "none";
    skImgEl.src = "";
    skImgPh.style.display = "block";
    return;
  }
  skImgEl.src = src;
  skImgEl.style.display = "block";
  skImgPh.style.display = "none";
}

// ===== ìŠ¤í‚¬ ìœ í˜•(ê³µê²©/ë°©ì–´) =====
const SK_ACTION_TYPES = {
  attack: [
    { value: "slash",  label: "ì°¸ê²©" },
    { value: "pierce", label: "ê´€í†µ" },
    { value: "blunt",  label: "íƒ€ê²©" },
  ],
  defense: [
    { value: "counter",        label: "ë°˜ê²©" },
    { value: "guard",          label: "ìˆ˜ë¹„" },
    { value: "evade",          label: "íšŒí”¼" },
    { value: "clash_counter",  label: "í•©ê°€ëŠ¥ ë°˜ê²©" },
    { value: "clash_guard",    label: "í•©ê°€ëŠ¥ ìˆ˜ë¹„" },
  ]
};

let skActionType = "attack"; // "attack" | "defense"

function isDefenseLevelType(atkType){
  // ìˆ˜ë¹„ / íšŒí”¼ / í•©ê°€ëŠ¥ ìˆ˜ë¹„ => ë°©ì–´ ë ˆë²¨ ì‚¬ìš©
  return atkType === "guard" || atkType === "evade" || atkType === "clash_guard";


function deriveDefenseModeFromEditor(){
  // âœ… ë¶„ë¥˜ UI ì œê±°: ê³µê²©ìœ í˜•(ë°©ì–´ ì˜µì…˜)ìœ¼ë¡œ ìë™ ê²°ì •
  if(skActionType !== "defense") return "";
  const v = String(skAtkType?.value || "").trim();
  if(v === "counter" || v === "guard" || v === "evade") return v;
  if(v === "clash_guard" || v === "clashGuard") return "clashGuard";
  if(v === "clash_counter" || v === "clashCounter") return "clashCounter";
  return "";
}
}

function setSkActionType(nextType, keepValue = true){
  skActionType = (nextType === "defense") ? "defense" : "attack";

  // ë²„íŠ¼ í…ìŠ¤íŠ¸/ìƒíƒœ
  if(skActionTypeBtn){
    skActionTypeBtn.dataset.action = skActionType;
    skActionTypeBtn.textContent = (skActionType === "defense") ? "ë°©ì–´ ìŠ¤í‚¬" : "ê³µê²© ìŠ¤í‚¬";
    skActionTypeBtn.classList.toggle("neg", skActionType === "defense");
    skActionTypeBtn.classList.toggle("pos", skActionType !== "defense");
  }

  // ê³µê²©ìœ í˜• select ì˜µì…˜ ì¬êµ¬ì„±
  const prev = keepValue ? (skAtkType?.value || "") : "";
  const opts = SK_ACTION_TYPES[skActionType];

  if(skAtkType){
    skAtkType.innerHTML = "";
    for(const o of opts){
      const op = document.createElement("option");
      op.value = o.value;
      op.textContent = o.label;
      skAtkType.appendChild(op);
    }

    const hasPrev = opts.some(o => o.value === prev);
    skAtkType.value = hasPrev ? prev : opts[0].value;
  }

  // ë ˆë²¨ ë¼ë²¨ ê°±ì‹  (ê³µê²©/ë°©ì–´ ë ˆë²¨)
  const useDefLv = isDefenseLevelType(skAtkType?.value);
  if(skLevelLabel){
    skLevelLabel.textContent = useDefLv ? "ë°©ì–´ ë ˆë²¨" : "ê³µê²© ë ˆë²¨";
  }

  // ë¯¸ë¦¬ë³´ê¸°/ìŒì„± UI ì¦‰ì‹œ ë°˜ì˜
  renderSkillPreview();
  try{ if(typeof refreshSkillSfxInfo === "function") refreshSkillSfxInfo(); }catch(_e){}
  try{ if(typeof renderCoinVoiceListNew === "function") renderCoinVoiceListNew(); else if(typeof renderCoinVoiceList === "function") renderCoinVoiceList(); }catch(_e){}
  try{ if(typeof updateSfxUIVisibility === "function") updateSfxUIVisibility(); }catch(_e){}

}


function updateSfxUIVisibility(){
  const at = String(skAtkType?.value || "");
  const evadeBox = document.getElementById("skEvadeSfxBox");
  const hitBox = skHitSfx ? skHitSfx.closest(".box") : null;
  const coinAddBtn = document.getElementById("skCoinVoiceAddBtn");
  const coinBox = coinAddBtn ? coinAddBtn.closest(".box") : null;

  // íšŒí”¼: ë°œë™/ì½”ì¸ ìŒì„± ëŒ€ì‹  ì„±ê³µ/ì‹¤íŒ¨ íš¨ê³¼ìŒ ì‚¬ìš©
  if(at === "evade"){
    if(evadeBox) evadeBox.style.display = "block";
    if(hitBox) hitBox.style.display = "none";
    if(coinBox) coinBox.style.display = "none";
    return;
  }

  // ìˆ˜ë¹„: ë³„ë„ ìŒì„±/ì½”ì¸ íš¨ê³¼ìŒ ì—†ìŒ
  if(at === "guard"){
    if(evadeBox) evadeBox.style.display = "none";
    if(hitBox) hitBox.style.display = "none";
    if(coinBox) coinBox.style.display = "none";
    return;
  }

  // ê·¸ ì™¸(ê³µê²©/ë°˜ê²© ë“±): ì¼ë°˜ ìŒì„± UI
  if(evadeBox) evadeBox.style.display = "none";
  if(hitBox) hitBox.style.display = "block";
  if(coinBox) coinBox.style.display = "block";
}

function refreshSkLevelLabelOnly(){
  const useDefLv = isDefenseLevelType(skAtkType?.value);
  if(skLevelLabel){
    skLevelLabel.textContent = useDefLv ? "ë°©ì–´ ë ˆë²¨" : "ê³µê²© ë ˆë²¨";
  }
}

function atkLabel(v){
  const map = {
    slash: "ì°¸ê²©",
    pierce: "ê´€í†µ",
    blunt: "íƒ€ê²©",
    counter: "ë°˜ê²©",
    guard: "ìˆ˜ë¹„",
    evade: "íšŒí”¼",
    clash_counter: "í•©ê°€ëŠ¥ ë°˜ê²©",
    clash_guard: "í•©ê°€ëŠ¥ ìˆ˜ë¹„",
  };
  return map[String(v)] || "ê³µê²©";
}
function sinLabel(v){
  const map = {
    wrath:"ë¶„ë…¸", lust:"ìƒ‰ìš•", sloth:"ë‚˜íƒœ", gluttony:"íƒì‹",
    melancholy:"ìš°ìš¸", pride:"ì˜¤ë§Œ", envy:"ì§ˆíˆ¬"
  };
  return map[v] || v;
}

/** âœ… í”„ë ˆì„ ì´ë¯¸ì§€ ê²½ë¡œ */
function framePath(sin, tier){
  const t = Math.min(3, Math.max(1, Number(tier)||1));
  const s = String(sin || "wrath").trim();
  return `assets/frame_${s}_${t}.png`;
}

function coinIconPath(type){
  const map = {
    normal: "assets/icon_coin_normal.png",
    fixed: "assets/icon_coin_fixed.png",
    extract: "assets/icon_coin_extract.png",
    annihilate: "assets/icon_coin_annihilate.png"
  };
  return map[type] || "";
}

function coinIconPath(type){
  const map = {
    normal: "assets/icon_coin_normal.png",
    fixed: "assets/icon_coin_fixed.png",
    extract: "assets/icon_coin_extract.png",
    annihilate: "assets/icon_coin_annihilate.png"
  };
  return map[type] || "";
}

function sinIconPath(sin){
  const map = {
    wrath:"assets/icon_wrath.png",
    lust:"assets/icon_lust.png",
    sloth:"assets/icon_sloth.png",
    gluttony:"assets/icon_gluttony.png",
    melancholy:"assets/icon_gloom.png",
    pride:"assets/icon_pride.png",
    envy:"assets/icon_envy.png",
  };
  return map[String(sin)] || "";
}

function levelIconPath(useDefense){
  return useDefense ? "assets/icon_deflv.png" : "assets/icon_growth.png";
}

function atkIconPath(atk){
  const map = {
    // ê³µê²© ìŠ¤í‚¬
    slash: "assets/icon_slash.png",
    pierce: "assets/icon_pierce.png",
    blunt: "assets/icon_blunt.png",

    // ë°©ì–´ ìŠ¤í‚¬ (ì•„ì´ì½˜ íŒŒì¼ëª…ì€ ë„¤ asset ì´ë¦„ì— ë§ê²Œ ìˆ˜ì • ê°€ëŠ¥)
    counter: "assets/icon_counter.png",
    guard: "assets/icon_guard.png",
    evade: "assets/icon_evade.png",
    clash_counter: "assets/icon_counter_clash.png",
    clash_guard: "assets/icon_guard_clash.png",
  };
  return map[String(atk)] || "";
}
function sinIconPath(sin){
  const map = {
    wrath:"assets/icon_wrath.png",
    lust:"assets/icon_lust.png",
    sloth:"assets/icon_sloth.png",
    gluttony:"assets/icon_gluttony.png",
    melancholy:"assets/icon_gloom.png",
    pride:"assets/icon_pride.png",
    envy:"assets/icon_envy.png",
  };
  return map[String(sin)] || "";
}

/** âœ… íƒ€ì´í‹€ë°”(6ë²ˆ)ë„ ì£„ì•…ì— ë§ì¶° í†¤ë§Œ ì‚´ì§ ë³€ê²½ (ì›í•˜ë©´ ë‚˜ì¤‘ì— ë” ë””í…Œì¼í•˜ê²Œ ê°€ëŠ¥) */
function applyTitleToneBySin(sin){
  const tone = {
    wrath:      { a:"rgba(255,60,60,.42)",  b:"rgba(90,10,10,.18)" },   // ë¹¨ê°•
    lust:       { a:"rgba(255,140,40,.42)", b:"rgba(90,40,10,.18)" },   // ì£¼í™©
    sloth:      { a:"rgba(255,220,60,.40)", b:"rgba(90,70,10,.16)" },   // ë…¸ë‘
    gluttony:   { a:"rgba(60,220,120,.34)", b:"rgba(10,70,30,.16)" },   // ì´ˆë¡
    melancholy: { a:"rgba(120,210,255,.34)", b:"rgba(10,40,70,.16)" },  // ì—°íŒŒë‘
    pride:      { a:"rgba(60,120,255,.34)", b:"rgba(10,20,70,.16)" },   // ë‚¨ìƒ‰
    envy:       { a:"rgba(170,90,255,.34)", b:"rgba(50,10,70,.16)" },   // ë³´ë¼
  }[String(sin)] || { a:"rgba(202,166,106,.22)", b:"rgba(0,0,0,.12)" };

  skTitleBar.style.background = `linear-gradient(180deg, ${tone.a}, ${tone.b})`;
  skTitleBar.style.borderColor = "rgba(255,255,255,.12)";
}

function escHtml(s){
  return String(s || "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;");
}

/* âœ… (A) ì¸ë¼ì¸ í† í° ì ìš©: "ì´ë¯¸ escapeëœ ë¬¸ìì—´"ì„ ëŒ€ìƒìœ¼ë¡œë§Œ ì²˜ë¦¬ */
function applyInlineTokensEscaped(escText){
  return String(escText || "")
    .replaceAll("[[g]]",  '<span class="fxGreen">').replaceAll("[[/g]]","</span>")
    .replaceAll("[[b]]",  '<span class="fxBlue">').replaceAll("[[/b]]","</span>")
    .replaceAll("[[r]]",  '<span class="fxRed">').replaceAll("[[/r]]","</span>")
    .replaceAll("[[hl]]", '<span class="pvHL">').replaceAll("[[/hl]]","</span>")
    .replaceAll(/\[\[kw:(buff|debuff):([^\]]+)\]\]/g, (m, st, name) => {
      const cls = (st === "debuff") ? "debuff" : "buff";
      const safeName = String(name).replaceAll('"', "&quot;");
      return `<span class="pvKW ${cls}" data-kw="${safeName}" data-state="${st}">${name}</span>`;
    });
}

/* âœ… ì¤„ ë‹¨ìœ„ ë Œë”: [[coin:n]]ì´ ì¤„ ë§¨ ì•ì´ë©´ ì™¼ìª½ ì¹¸ì— ì½”ì¸ ë±ƒì§€ë¡œ ë¶„ë¦¬ */
function skToHtml(text){
  const lines = String(text || "").split("\n");

  const out = lines.map((rawLine) => {
    let line = String(rawLine || "").replace(/^\s+/, ""); // ì•ê³µë°± ì œê±°

    // 1) ë§¨ ì• coin í† í°ë§Œ leadë¡œ ë¶„ë¦¬
    let leadHtml = "";
    const m = line.match(/^\[\[coin:(\d+)\]\]\s*/);
    if(m){
      const n = Number(m[1] || 0);
      const rn = toRoman(n);
      leadHtml = `
        <span class="coinEffIcon" style="width:22px;height:22px;flex:0 0 22px;position:relative;display:block;">
          <img src="assets/icon_coin_effect_frame.png" alt="coin" style="position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:block;">
          <span class="coinEffRoman" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:11px;font-weight:1000;color:rgba(255,255,255,.95);text-shadow:0 2px 6px rgba(0,0,0,.70);line-height:1;">
            ${escHtml(rn)}
          </span>
        </span>
      `.trim();
      line = line.slice(m[0].length);
    }

    // 2) ë³¸ë¬¸: ë¨¼ì € escape â†’ í† í°ì²˜ë¦¬ â†’ (ë‚¨ì€) [[coin:n]] ì¸ë¼ì¸ ì•„ì´ì½˜ ë³€í™˜
    let body = escHtml(line);
    body = applyInlineTokensEscaped(body);

    body = body.replace(/\[\[coin:(\d+)\]\]/g, (mm, nn) => {
      const rn = toRoman(Number(nn));
      return `<span class="coinEff" style="display:inline-flex;align-items:center;gap:4px;vertical-align:middle;margin:0 2px;">
        <span class="coinEffIcon" style="position:relative;width:22px;height:22px;flex:0 0 22px;display:block;">
          <img src="assets/icon_coin_effect_frame.png" alt="coin" style="position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:block;">
          <span class="coinEffRoman" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:11px;font-weight:1000;color:rgba(255,255,255,.95);text-shadow:0 2px 6px rgba(0,0,0,.70);line-height:1;">
            ${escHtml(rn)}
          </span>
        </span>
      </span>`;
    });

    if(!body.trim()) body = "&nbsp;";

    return `
      <div class="skLine">
        <div class="skLead">${leadHtml}</div>
        <div class="skBody">${body}</div>
      </div>
    `.trim();
  }).join("");

  return `<div class="skLines">${out}</div>`;
}

function snapshotCurrentWorkspace(){
  // âœ… íŒ¨ì‹œë¸Œ í¸ì§‘ ì¤‘ì¸ ë‚´ìš©ì´ ìˆìœ¼ë©´ ë¨¼ì € ê°•ì œ ë°˜ì˜
  try{
    if(typeof forceSavePassivesIfEditing === "function"){
      forceSavePassivesIfEditing();
    }else{
      // í˜¹ì‹œ í•¨ìˆ˜ê°€ ì—†ë”ë¼ë„ í˜„ì¬ passives ë°°ì—´ì€ ê·¸ëŒ€ë¡œ ì‚¬ìš© ê°€ëŠ¥
      if(activePvId){
        const idx = passives.findIndex(x => x.id === activePvId);
        if(idx >= 0){
          passives[idx] = {
            ...passives[idx],
            name: pvName?.value || "",
            text: pvText?.value || "",
            style: activePvStyle || "brown"
          };
          pvSaveStore();
        }
      }
    }
  }catch(e){
    console.error("íŒ¨ì‹œë¸Œ ê°•ì œë°˜ì˜ ì‹¤íŒ¨:", e);
  }

  // core
  let core = null;
  try{ core = JSON.parse(localStorage.getItem(KEY_CORE) || "null"); }catch(e){ core = null; }

  // âœ… passivesëŠ” localStorage ì¬ì¡°íšŒë³´ë‹¤ í˜„ì¬ ë©”ëª¨ë¦¬ê°’ì„ ìš°ì„  ì‚¬ìš©
  let pass = [];
  try{
    pass = Array.isArray(passives) ? JSON.parse(JSON.stringify(passives)) : [];
  }catch(e){
    pass = [];
  }

  // skills
  let sk = [];
  try{ sk = JSON.parse(localStorage.getItem(KEY_SK) || "[]"); }catch(e){ sk = []; }

  // dedicated keywords
  let dk = [];
  try{ dk = JSON.parse(localStorage.getItem(KEY_DK) || "[]"); }catch(e){ dk = []; }

  return {
    version: 1,
    savedAt: nowISO(),
    name: (core?.name || "").trim() || "ì´ë¦„ì—†ëŠ” ìºë¦­í„°",
    core: core,
    passives: pass,
    skills: sk,
    dedicatedKeywords: dk,
  };
}

async function restoreWorkspaceFromChar(charData){
  if(!charData) return;

  // localStorageì— ê·¸ëŒ€ë¡œ ê½‚ì•„ì£¼ê³ ,
  localStorage.setItem(KEY_CORE, JSON.stringify(charData.core || null));
  localStorage.setItem(KEY_PV, JSON.stringify(charData.passives || []));
  localStorage.setItem(KEY_SK, JSON.stringify(charData.skills || []));
  localStorage.setItem(KEY_DK, JSON.stringify(charData.dedicatedKeywords || []));

  // í™”ë©´ ê°±ì‹ : ê° íŒŒíŠ¸ê°€ ì´ë¯¸ "load" IIFEë¥¼ ê°€ì§€ê³  ìˆìœ¼ë‹ˆ
  // ê°€ì¥ ì•ˆì „í•œ ë°©ë²•ì€ ê·¸ëƒ¥ ìƒˆë¡œê³ ì¹¨ì´ì§€ë§Œ,
  // ì§€ê¸ˆ êµ¬ì¡°ì—ì„œë„ ìµœì†Œ ë™ì‘í•˜ê²Œ í•˜ë ¤ë©´ ì•„ë˜ì²˜ëŸ¼ ì£¼ìš” ë Œë” ì¬í˜¸ì¶œ:
  try{
    // coreëŠ” IIFEê°€ ìˆìœ¼ë‹ˆ ì—¬ê¸°ì„œëŠ” ê°„ë‹¨íˆ ìƒˆë¡œê³ ì¹¨ ì¶”ì²œ.
    // ê·¸ë˜ë„ ì¦‰ì‹œ ë°˜ì˜ì´ í•„ìš”í•˜ë©´ location.reload()ê°€ ì œì¼ ì•ˆì „.
    location.reload();
  }catch(e){}
}

/** âœ… ë¯¸ë¦¬ë³´ê¸° ê°±ì‹  */
async function renderSkillPreview(){
  const nm = String(skName.value || "").trim() || "ìŠ¤í‚¬";
  const atk = skAtkType.value;
  const sin = skSin.value;
  const tier = Number(skTier.value || 1);
  const pow = Number(skPower.value || 0);
  const coinP = Number(skCoinPower.value || 0);
  const sign = (skCoinSignBtn.dataset.sign === "-") ? "-" : "+";
  const atkLv = Number(skAtkLevel?.value || 0);
  const growth = Number(skGrowth?.value || 0);
  const w = Number(skWeight.value || 0);
  const txt = skText.value || "";
if(skAtkIcon) skAtkIcon.src = atkIconPath(atk);
if(skSinIcon) skSinIcon.src = sinIconPath(sin);
  skTitleTxt.textContent = nm;
  skPrevAtk.textContent = atkLabel(atk);
  skPrevSin.textContent = sinLabel(sin);

if(skPrevAtkIcon){
  skPrevAtkIcon.src = atkIconPath(atk);
  skPrevAtkIcon.alt = atkLabel(atk);
}
if(skPrevSinIcon){
  skPrevSinIcon.src = sinIconPath(sin);
  skPrevSinIcon.alt = sinLabel(sin);
}
  skPrevPow.textContent = String(Number.isFinite(pow) ? pow : 0);
  skPrevCoin.textContent = `${sign}${Number.isFinite(coinP) ? Math.abs(coinP) : 0}`;
  skPrevW.textContent = String(Number.isFinite(w) ? w : 0);

// âœ… ê³µê²©ë ˆë²¨ / ë°©ì–´ë ˆë²¨ í‘œì‹œ + ì•„ì´ì½˜ ë³€ê²½
if(skPrevGrowthBase) skPrevGrowthBase.textContent = String(Number.isFinite(atkLv) ? atkLv : 0);
if(skPrevGrowthPlus) skPrevGrowthPlus.textContent = String(Number.isFinite(growth) ? Math.abs(growth) : 0);
if(skPrevGrowthSign) skPrevGrowthSign.textContent = (growth < 0) ? "-" : "+";

// í˜„ì¬ ì„ íƒëœ ê³µê²©ìœ í˜• ê¸°ì¤€ìœ¼ë¡œ "ë°©ì–´ ë ˆë²¨" ê³„ì—´ì¸ì§€ íŒì •
const isDefLevelType = ["guard", "evade", "guardclash"].includes(String(atk));

// ë¯¸ë¦¬ë³´ê¸° ì„±ì¥ì¤„ ìš”ì†Œë“¤ (ë„¤ íŒŒì¼ êµ¬ì¡° ê¸°ì¤€: class ì‚¬ìš©)
const prevGrowthIconEl = document.querySelector("#skPreviewCard .skGrowthIcon");
const prevGrowthLabelEl = document.querySelector("#skPreviewCard .skGrowthLabel");

if(prevGrowthLabelEl){
  prevGrowthLabelEl.textContent = isDefLevelType ? "ë°©ì–´ë ˆë²¨" : "ì„±ì¥ê³„ìˆ˜";
}

if(prevGrowthIconEl){
  // íŒŒì¼ëª…ì€ ë„¤ê°€ ë§Œë“  ì‹¤ì œ íŒŒì¼ëª… ê¸°ì¤€ìœ¼ë¡œ ë§ì¶°ì¤˜
  // (ì˜ˆì‹œ) assets/icon_attack_level.png / assets/icon_defense_level.png
  prevGrowthIconEl.src = isDefLevelType
    ? "assets/icon_defense_level.png"
    : "assets/icon_growth.png";
  prevGrowthIconEl.alt = isDefLevelType ? "ë°©ì–´ë ˆë²¨" : "ì„±ì¥ê³„ìˆ˜";
}

// ì½”ì¸ ì•„ì´ì½˜ ë Œë”
if(skCoinRow){
  skCoinRow.innerHTML = "";

  const count = skCoinCount ? Number(skCoinCount.value || 1) : 1;
  const type  = skCoinType  ? skCoinType.value : "normal";

  for(let i=0;i<count;i++){
    const img = document.createElement("img");
    img.src = coinIconPath(type);
    img.className = "skCoinIcon";
    skCoinRow.appendChild(img);
  }
}

// íš¨ê³¼ ë Œë”(í‚¤ì›Œë“œ span í¬í•¨)
if(skEffectBox){
  skEffectBox.innerHTML = skToHtml(txt);
}

  // í”„ë ˆì„
  skFrameImg.src = framePath(sin, tier);
  applyTitleToneBySin(sin);

  // ë‚´ë¶€ ì´ë¯¸ì§€: (1) pending (2) ì €ì¥ëœ active skill imgKey
  if(skPendingImgDataURL && skPendingImgDataURL.startsWith("data:image/")){
    skInnerImg.src = skPendingImgDataURL;
    skInnerImg.style.display = "block";
  }else{
    skInnerImg.src = "";
    skInnerImg.style.display = "none";

    // activeSkIdê°€ ìˆê³  imgKeyê°€ ìˆìœ¼ë©´ IndexedDBì—ì„œ ë¡œë“œ
    const it = skills.find(x => x.id === activeSkId);
    const key = it?.imgKey || "";
    if(key){
      try{
        const blob = await idbGetBlob(key);
        if(blob){
          skInnerImg.src = makeObjectURLFromBlob(blob);
          skInnerImg.style.display = "block";
        }
      }catch(e){}
    }
  }
}

// í¼ì¹¨ ìƒíƒœ ê¸°ì–µìš©
const _skOpenMap = new Map(); // skillId -> boolean

function setOpen(id, v){ _skOpenMap.set(id, !!v); }
function isOpen(id){ return !!_skOpenMap.get(id); }

/** âœ… ë¦¬ìŠ¤íŠ¸ ë Œë” (ìŠ¤í‚¬ ëª©ë¡ ì¹´ë“œ) */
async function renderSkillList(){
  // âœ… ë¶„ë¦¬ ë¦¬ìŠ¤íŠ¸ ìš°ì„  ì‚¬ìš© (ì—†ìœ¼ë©´ ê¸°ì¡´ skListë¡œ í´ë°±)
  const useSplit = !!(skListNormal && skListSpecial);

  // ì´ˆê¸°í™”
  if(useSplit){
    skListNormal.innerHTML = "";
    skListSpecial.innerHTML = "";
  }else{
    if(!skList) return;
    skList.innerHTML = "";
  }

  // ë¹ˆ ëª©ë¡ ì²˜ë¦¬
  if(skills.length === 0){
    const makeEmpty = () => {
      const d = document.createElement("div");
      d.style.color = "rgba(238,241,255,.55)";
      d.style.fontSize = "13px";
      d.style.padding = "8px";
      d.textContent = "ì•„ì§ ì €ì¥ëœ ìŠ¤í‚¬ì´ ì—†ì–´. ìœ„ì—ì„œ ë§Œë“¤ê³  ì €ì¥í•´ì¤˜.";
      return d;
    };

    if(useSplit){
      skListNormal.appendChild(makeEmpty());
      skListSpecial.appendChild(makeEmpty());
    }else{
      skList.appendChild(makeEmpty());
    }
    return;
  }

  // ê° ëª©ë¡ ë¹„ì—ˆì„ ë•Œ ì•ˆë‚´ë¬¸ ë„£ê¸° ìœ„í•´ ì¹´ìš´íŠ¸
  let normalCount = 0;
  let specialCount = 0;

  for(const s of skills){
    const card = document.createElement("div");
    card.className = "skListCard" + (s.id === activeSkId ? " active" : "");

    // === TOP (í´ë¦­í•˜ë©´ í¸ì§‘ê¸°ì— ë¡œë“œ) ===
    const top = document.createElement("div");
    top.className = "skListTop";

    // ART (í”„ë ˆì„+ë‚´ë¶€)
    const art = document.createElement("div");
    art.className = "skListArt";

    const frameBox = document.createElement("div");
    frameBox.className = "skListFrame";

    const frame = document.createElement("img");
    frame.alt = "frame";
    frame.src = framePath(s.sin, s.tier);
    frameBox.appendChild(frame);

    const inner = document.createElement("div");
    inner.className = "inner";

    const innerImg = document.createElement("img");
    innerImg.alt = "skill image";
    inner.appendChild(innerImg);
    frameBox.appendChild(inner);

    if(s.imgKey){
      try{
        const blob = await idbGetBlob(s.imgKey);
        innerImg.src = blob ? makeObjectURLFromBlob(blob) : "";
      }catch(e){
        innerImg.src = "";
      }
    }else{
      innerImg.src = "";
    }

    art.appendChild(frameBox);

    // coin icons
    const coinRow = document.createElement("div");
    coinRow.className = "skListCoins";
    const count = Math.max(1, Number(s.coinCount || s.qty || 1));
    const type  = String(s.coinType || "normal");
    for(let i=0;i<count;i++){
      const c = document.createElement("img");
      c.src = coinIconPath(type);
      c.alt = "coin";
      coinRow.appendChild(c);
    }
    art.appendChild(coinRow);

    // MAIN
    const main = document.createElement("div");
    main.className = "skListMain";

    // titlebar tone
    const titleBar = document.createElement("div");
    titleBar.className = "skListTitleBar";
    const tone = {
      wrath:      { a:"rgba(255,60,60,.42)",  b:"rgba(90,10,10,.18)" },
      lust:       { a:"rgba(255,140,40,.42)", b:"rgba(90,40,10,.18)" },
      sloth:      { a:"rgba(255,220,60,.40)", b:"rgba(90,70,10,.16)" },
      gluttony:   { a:"rgba(60,220,120,.34)", b:"rgba(10,70,30,.16)" },
      melancholy: { a:"rgba(120,210,255,.34)", b:"rgba(10,40,70,.16)" },
      pride:      { a:"rgba(60,120,255,.34)", b:"rgba(10,20,70,.16)" },
      envy:       { a:"rgba(170,90,255,.34)", b:"rgba(50,10,70,.16)" },
    }[String(s.sin)] || { a:"rgba(202,166,106,.22)", b:"rgba(0,0,0,.12)" };
    titleBar.style.background = `linear-gradient(180deg, ${tone.a}, ${tone.b})`;

    const title = document.createElement("div");
    title.className = "skListTitle";
    title.textContent = String(s.name || "").trim() || "ìŠ¤í‚¬";
    titleBar.appendChild(title);

    // stats
    const stat = document.createElement("div");
    stat.className = "skListStat";

    const kindText = (String(s.kind || "normal") === "special") ? "íŠ¹ìˆ˜ ìŠ¤í‚¬" : "ì¼ë°˜ ìŠ¤í‚¬";
    const chanceNum = Number(s.spawnChance ?? 100);
    const chanceText = `${Number.isFinite(chanceNum) ? chanceNum : 100}%`;

    const rows = [
      ["í–‰ë™ ìœ í˜•", atkLabel(s.atkType)],
      ["ì£„ì•… ì†ì„±", sinLabel(s.sin)],
      ["ìŠ¤í‚¬ ìœ„ë ¥", String(Number(s.power ?? 0) || 0)],
      ["ì½”ì¸ ìœ„ë ¥", `${(s.coinSign === "-") ? "-" : "+"}${Math.abs(Number(s.coinPower ?? 0) || 0)}`],
      ["ê³µê²© ê°€ì¤‘ì¹˜", String(Number(s.weight ?? 0) || 0)],
      ["ìŠ¤í‚¬ ì¢…ë¥˜", kindText],       // âœ… ì¶”ê°€
      ["ë“±ì¥ í™•ë¥ ", chanceText],     // âœ… ì¶”ê°€
    ];

    for(const [th, td] of rows){
      const r = document.createElement("div");
      r.className = "skListStatRow";

      const thEl = document.createElement("div");
      thEl.className = "skListStatTh";
      thEl.textContent = th;

      const tdEl = document.createElement("div");
      tdEl.className = "skListStatTd";

      if(th === "ê³µê²© ìœ í˜•"){
        const img = document.createElement("img");
        img.className = "skMiniIcon";
        img.src = atkIconPath(s.atkType);
        img.alt = td;
        tdEl.appendChild(img);
      }
      if(th === "ì£„ì•… ì†ì„±"){
        const img = document.createElement("img");
        img.className = "skMiniIcon";
        img.src = sinIconPath(s.sin);
        img.alt = td;
        tdEl.appendChild(img);
      }

      const sp = document.createElement("span");
      sp.textContent = td;
      tdEl.appendChild(sp);

      r.appendChild(thEl);
      r.appendChild(tdEl);
      stat.appendChild(r);
    }

    main.appendChild(titleBar);

    // ê³µê²©ë ˆë²¨ / ì„±ì¥ê³„ìˆ˜ ì¤„
    const growthRow = document.createElement("div");
    growthRow.className = "skListGrowthRow";

    const gIcon = document.createElement("img");
    gIcon.className = "skListGrowthIcon";
const useDefLv = isDefenseLevelType(s.atkType);
gIcon.src = levelIconPath(useDefLv);
gIcon.alt = useDefLv ? "ë°©ì–´ ë ˆë²¨" : "ì„±ì¥ê³„ìˆ˜";

    const atkLv = Number(s.atkLevel ?? 0);
    const gr = Number(s.growth ?? 0);
    const sign = (gr < 0) ? "-" : "+";
    const absGr = Math.abs(gr);

    const gText = document.createElement("div");
    gText.className = "skListGrowthText";
gText.innerHTML = `
  <span>${atkLv}</span>
  <span class="skGrowthLabel">${useDefLv ? "ë°©ì–´ë ˆë²¨" : "ì„±ì¥ê³„ìˆ˜"}</span>
  <span class="skGrowthPlus">(${sign} ${absGr})</span>
`;

    growthRow.appendChild(gIcon);
    growthRow.appendChild(gText);

    main.appendChild(growthRow);
    main.appendChild(stat);

    top.appendChild(art);
    top.appendChild(main);

    // top í´ë¦­ => í¸ì§‘ê¸°ì— ë¡œë“œ
    top.addEventListener("click", async () => {
      await loadSkillToEditor(s.id);
    });

    card.appendChild(top);

    // === ACTION: [ì½”ì¸ë³„ íš¨ê³¼] í† ê¸€ ===
    const act = document.createElement("div");
    act.className = "skListActions";

    const toggle = document.createElement("button");
    toggle.type = "button";
    toggle.className = "skListToggle";
    toggle.textContent = "[ ì½”ì¸ë³„ íš¨ê³¼ ]";

    toggle.addEventListener("click", (e) => {
      e.stopPropagation();
      const now = !isOpen(s.id);
      setOpen(s.id, now);
      body.classList.toggle("open", now);
    });

    act.appendChild(toggle);
    card.appendChild(act);

    const body = document.createElement("div");
    body.className = "skListBody" + (isOpen(s.id) ? " open" : "");

    const eff = document.createElement("div");
    eff.className = "skListEffect";
    eff.innerHTML = skToHtml(s.text || "");
    body.appendChild(eff);

    body.addEventListener("click", (e) => e.stopPropagation());

    card.appendChild(body);

    // âœ… ì¼ë°˜/íŠ¹ìˆ˜ ëª©ë¡ìœ¼ë¡œ ë¶„ë°°
    if(useSplit){
      const kind = String(s.kind || "normal");
      if(kind === "special"){
        skListSpecial.appendChild(card);
        specialCount++;
      }else{
        skListNormal.appendChild(card);
        normalCount++;
      }
    }else{
      skList.appendChild(card);
    }
  }

  // âœ… ê° ë¶„ë¦¬ ëª©ë¡ì´ ë¹„ì–´ ìˆìœ¼ë©´ ì•ˆë‚´ë¬¸ í‘œì‹œ
  if(useSplit){
    if(normalCount === 0){
      const d = document.createElement("div");
      d.style.color = "rgba(238,241,255,.55)";
      d.style.fontSize = "13px";
      d.style.padding = "8px";
      d.textContent = "ì¼ë°˜ ìŠ¤í‚¬ì´ ì•„ì§ ì—†ì–´.";
      skListNormal.appendChild(d);
    }
    if(specialCount === 0){
      const d = document.createElement("div");
      d.style.color = "rgba(238,241,255,.55)";
      d.style.fontSize = "13px";
      d.style.padding = "8px";
      d.textContent = "íŠ¹ìˆ˜ ìŠ¤í‚¬ì´ ì•„ì§ ì—†ì–´.";
      skListSpecial.appendChild(d);
    }
  }
}

skKindToggle?.addEventListener("click", (e) => {
  const btn = e.target.closest(".skKindBtn");
  if(!btn) return;
  setSkillKind(btn.dataset.kind || "normal");
});

/** âœ… í¸ì§‘ê¸° ë¡œë“œ */
async function loadSkillToEditor(id){
  const it = skills.find(x => x.id === id);
  if(!it) return;

  activeSkId = it.id;
  window.activeSkId = activeSkId;
  skPendingImgDataURL = "";
  window.skPendingImgDataURL = skPendingImgDataURL;

  skName.value = it.name || "";
  // âœ… ë¶„ë¥˜ UI ì œê±°: ì €ì¥ëœ ê°’/ì„ íƒê°’ìœ¼ë¡œ ìë™ íŒì •
  const dm = String(it.defenseMode || "").trim();
  const at = String(it.atkType || "").trim();

  const inferDefense = (() => {
    if(it.actionType) return (String(it.actionType) === "defense");
    // defenseModeê°€ ìˆìœ¼ë©´ ë°©ì–´ë¡œ ì·¨ê¸‰
    if(dm) return true;
    // atkTypeê°€ ë°©ì–´ ì˜µì…˜ì´ë©´ ë°©ì–´ë¡œ ì·¨ê¸‰
    return ["counter","guard","evade","clash_counter","clash_guard","clashCounter","clashGuard"].includes(at);
  })();

  setSkActionType(inferDefense ? "defense" : "attack", false);

  if(skActionType === "defense"){
    // atkType ìš°ì„ , ì—†ê±°ë‚˜ ê³µê²© íƒ€ì…ì´ë©´ defenseModeì—ì„œ ë§¤í•‘
    let v = at;
    if(!["counter","guard","evade","clash_counter","clash_guard","clashCounter","clashGuard"].includes(v)){
      if(dm === "clashGuard") v = "clash_guard";
      else if(dm === "clashCounter") v = "clash_counter";
      else if(["counter","guard","evade"].includes(dm)) v = dm;
      else v = "counter";
    }else{
      // camelCaseë¡œ ì €ì¥ëœ ê°’ë„ í—ˆìš©
      if(v === "clashGuard") v = "clash_guard";
      if(v === "clashCounter") v = "clash_counter";
    }
    skAtkType.value = v || "counter";
  }else{
    skAtkType.value = at || "pierce";
  }

  refreshSkLevelLabelOnly();
  skSin.value = it.sin || "pride";
  skTier.value = String(it.tier || 1);
  if(skAtkLevel) skAtkLevel.value = String(it.atkLevel ?? 0);
  if(skGrowth)   skGrowth.value   = String(it.growth ?? 0);
  skPower.value = String(it.power ?? 0);
  skCoinPower.value = String(Math.abs(it.coinPower ?? 0));
  setCoinSign(it.coinSign === "-" ? "-" : "+");
  skWeight.value = String(it.weight ?? 0);
  setSkillKind(it.kind || "normal");
if(skillSpawnChance) skillSpawnChance.value = String(it.spawnChance ?? 100);
  skText.value = it.text || "";
  if(skHitSfx) skHitSfx.value = it.hitSfx || "";
  skPendingHitSfxFile = null;
  skHitSfxWasCleared = false;
  skPendingCoinSfxFiles = [null,null,null,null,null];
  hydrateVoiceDraftsFromSkill(it);
  currentAutoRules = Array.isArray(it.autoRules) ? it.autoRules.map(normalizeAutoRule) : [];
  renderAutoRuleEditor();
  renderCoinVoiceList(it);
  refreshSkillSfxInfo(it);

  if(skCoinType)  skCoinType.value  = it.coinType || "normal";
  if(skCoinCount) skCoinCount.value = String(it.coinCount ?? 1);
// ì´ë¯¸ì§€ í”„ë¦¬ë·°(ì™¼ìª½ ì—…ë¡œë“œ ë°•ìŠ¤)
  setSkImgPreview("");
  if(it.imgKey){
    try{
      const blob = await idbGetBlob(it.imgKey);
      if(blob) setSkImgPreview(makeObjectURLFromBlob(blob));
    }catch(e){}
  }

await renderSkillList();
await renderSkillPreview();
  toast(skToast, "ìŠ¤í‚¬ ë¶ˆëŸ¬ì˜´.");
}

setSkActionType("attack", false);
renderAutoRuleEditor();


/** ìƒˆ ìŠ¤í‚¬(ì—ë””í„° ì´ˆê¸°í™”) */
async function newSkill(){
  activeSkId = null;
  window.activeSkId = activeSkId;
  skPendingImgDataURL = "";
  window.skPendingImgDataURL = skPendingImgDataURL;
  skName.value = "";
  setSkActionType("attack", false);
skAtkType.value = "pierce";
refreshSkLevelLabelOnly();
  skSin.value = "pride";
  skTier.value = "1";
  if(skAtkLevel) skAtkLevel.value = "0";
  if(skGrowth)   skGrowth.value   = "0";
  skPower.value = "15";
  skCoinPower.value = "4";
  setCoinSign("+");
  skWeight.value = "1";
  skText.value = "";
  if(skHitSfx) skHitSfx.value = "";
  skPendingHitSfxFile = null;
  skHitSfxWasCleared = false;
  skPendingCoinSfxFiles = [null,null,null,null,null];
  hydrateVoiceDraftsFromSkill(null);
  renderCoinVoiceList();
  refreshSkillSfxInfo();
  currentAutoRules = [];
  renderAutoRuleEditor();
  skImgFile.value = "";
  setSkImgPreview("");
await renderSkillList();
await renderSkillPreview();
  try{ if(typeof updateSfxUIVisibility === "function") updateSfxUIVisibility(); }catch(_e){}

  toast(skToast, "ìƒˆ ìŠ¤í‚¬ ì‘ì„± ì¤‘.");
  if(skCoinType)  skCoinType.value  = "normal";
  if(skCoinCount) skCoinCount.value = "1";
setSkillKind("normal");
if(skillSpawnChance) skillSpawnChance.value = "100";
}

/** ì½”ì¸ ë¶€í˜¸ ë²„íŠ¼ */
function setCoinSign(sign){
  const s = (sign === "-") ? "-" : "+";
  skCoinSignBtn.dataset.sign = s;
  skCoinSignBtn.textContent = s;
  skCoinSignBtn.classList.toggle("neg", s === "-");
  skCoinSignBtn.classList.toggle("pos", s === "+");
}

skCoinSignBtn.addEventListener("click", () => {
  const cur = skCoinSignBtn.dataset.sign || "+";
  setCoinSign(cur === "+" ? "-" : "+");
  renderSkillPreview();
});

skActionTypeBtn?.addEventListener("click", () => {
  const cur = skActionTypeBtn.dataset.action || "attack";
  setSkActionType(cur === "attack" ? "defense" : "attack", false);
});

skAtkType?.addEventListener("change", () => {
  refreshSkLevelLabelOnly();
  renderSkillPreview();
  try{ if(typeof refreshSkillSfxInfo === "function") refreshSkillSfxInfo(); }catch(_e){}
  try{ if(typeof renderCoinVoiceListNew === "function") renderCoinVoiceListNew(); else if(typeof renderCoinVoiceList === "function") renderCoinVoiceList(); }catch(_e){}
});
/** ìŠ¤í‚¬ ì´ë¯¸ì§€ ì—…ë¡œë“œ -> pending + í”„ë¦¬ë·°. ì €ì¥ ëˆ„ë¥´ë©´ IndexedDB ë°˜ì˜ */
skImgFile.addEventListener("change", async (e) => {
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  try{
    skPendingImgDataURL = await compressImageToDataURL(f, {
      maxSize: 512,
      mime: "image/webp",
      quality: 0.88
    });
    window.skPendingImgDataURL = skPendingImgDataURL;
    setSkImgPreview(skPendingImgDataURL);
    await renderSkillPreview();
    toast(skToast, "ì´ë¯¸ì§€ ì„ íƒë¨. 'ì €ì¥'ì„ ëˆ„ë¥´ë©´ ì˜êµ¬ ë°˜ì˜ë¼.");
  }catch(err){
    console.error(err);
    toast(skToast, "ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹¤íŒ¨(íŒŒì¼/ë¸Œë¼ìš°ì € ì œí•œ).");
  }
});

skImgClear.addEventListener("click", async () => {
  skImgFile.value = "";
  skPendingImgDataURL = "";
  window.skPendingImgDataURL = skPendingImgDataURL;
  setSkImgPreview("");

  // ì„ íƒëœ í•­ëª©ì´ ìˆìœ¼ë©´ DBì—ì„œë„ ì‚­ì œ
  if(activeSkId){
    const idx = skills.findIndex(x => x.id === activeSkId);
    if(idx >= 0){
      const oldKey = skills[idx].imgKey || "";
      if(oldKey){
        try{ await idbDel(oldKey); }catch(e){}
      }
      skills[idx] = { ...skills[idx], imgKey: "" };
      skSaveStore();
      toast(skToast, "ì´ë¯¸ì§€ ì œê±° ì™„ë£Œ!");
    }
  }
  await renderSkillPreview();
});

skHitSfxFile?.addEventListener("change", (e)=>{
  skPendingHitSfxFile = e.target.files && e.target.files[0] ? e.target.files[0] : null;
  if(skPendingHitSfxFile) skHitSfxWasCleared = false;
  refreshSkillSfxInfo(getSkillById(activeSkId));
});

skHitSfx?.addEventListener("input", ()=>{
  if((skHitSfx?.value || '').trim()) skHitSfxWasCleared = false;
  refreshSkillSfxInfo(getSkillById(activeSkId));
});

skHitSfxClear?.addEventListener("click", async ()=>{
  skPendingHitSfxFile = null;
  if(skHitSfxFile) skHitSfxFile.value = "";
  if(skHitSfx) skHitSfx.value = "";
  skHitSfxWasCleared = true;
  refreshSkillSfxInfo(getSkillById(activeSkId));
});

skCoinVoiceAddBtn?.addEventListener("click", ()=>{
  const raw = prompt("ëª‡ ë²ˆì§¸ ì½”ì¸ ìŒì„±ì„ ì¶”ê°€í• ê¹Œ? (1~5)");
  if(raw === null) return;
  const slot = Math.max(1, Math.min(5, Number(raw)||0));
  if(!slot){ alert("1~5 ìˆ«ìë¥¼ ì…ë ¥í•´ì¤˜."); return; }
  activeCoinVoiceSlots.add(slot);
  renderCoinVoiceList(getSkillById(activeSkId));
});

/** ì…ë ¥ ë³€í™” -> ë¯¸ë¦¬ë³´ê¸° ì¦‰ì‹œ */
[skName, skAtkType, skSin, skTier, skPower, skCoinPower, skWeight, skText, skCoinType, skCoinCount, skAtkLevel, skGrowth, skHitSfx, ...skCoinSfxPathEls].forEach(el => {
  el?.addEventListener("input", renderSkillPreview);
  el?.addEventListener("change", renderSkillPreview);
});

/** í‚¤ì›Œë“œ ë²„íŠ¼: ìŠ¤í‚¬ textareaë¥¼ íƒ€ê²Ÿìœ¼ë¡œ ì—´ê¸° */
skCoinEffectBtn?.addEventListener("click", () => {
  const input = prompt("ëª‡ ë²ˆì§¸ ì½”ì¸ íš¨ê³¼ë¥¼ ë„£ì„ê¹Œ? (ì˜ˆ: 1, 2, 3...)");
  if(input === null) return;

  const num = Number(String(input).trim());
  if(!Number.isFinite(num) || num < 1){
    alert("1 ì´ìƒì˜ ìˆ«ìë¥¼ ì…ë ¥í•´ì¤˜.");
    return;
  }

  insertAtCursor(skText, `[[coin:${Math.floor(num)}]]`);
  renderSkillPreview();
});

function wrapSelection(textarea, openTag, closeTag){
  const el = textarea;
  const start = el.selectionStart ?? 0;
  const end = el.selectionEnd ?? 0;
  if(start === end) return false;

  const txt = el.value;
  const before = txt.slice(0, start);
  const sel = txt.slice(start, end);
  const after = txt.slice(end);

  el.value = before + openTag + sel + closeTag + after;

  // ì»¤ì„œëŠ” ê°ì‹¼ ë’¤ ëìœ¼ë¡œ
  const pos = end + openTag.length + closeTag.length;
  el.focus();
  el.setSelectionRange(pos, pos);
  return true;
}

/** ê°•ì¡° ë²„íŠ¼: pv ë°©ì‹ ì¬ì‚¬ìš©(í† í° [[hl]]) */
skHighlightBtn?.addEventListener("click", () => {
  const el = skText;
  const start = el.selectionStart ?? 0;
  const end = el.selectionEnd ?? 0;
  if(start === end){
    toast(skToast, "ê°•ì¡°í•  í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ë“œë˜ê·¸í•´ì„œ ì„ íƒí•´ì¤˜.");
    return;
  }
  const txt = el.value;
  el.value = txt.slice(0,start) + "[[hl]]" + txt.slice(start,end) + "[[/hl]]" + txt.slice(end);
  el.focus();
  el.setSelectionRange(end + 10 + 6, end + 10 + 6);
  toast(skToast, "ì„ íƒí•œ ë¶€ë¶„ì— ê°•ì¡°ë¥¼ ì ìš©í–ˆì–´.");
  renderSkillPreview();
});

skGreenBtn?.addEventListener("click", () => {
  const ok = wrapSelection(skText, "[[g]]", "[[/g]]");
  if(!ok){ toast(skToast, "íš¨ê³¼ë¥¼ ì ìš©í•  í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ë“œë˜ê·¸í•´ì„œ ì„ íƒí•´ì¤˜."); return; }
  toast(skToast, "ì„ íƒí•œ ë¶€ë¶„ì— ë…¹ìƒ‰ íš¨ê³¼ë¥¼ ì ìš©í–ˆì–´.");
  renderSkillPreview();
});

skBlueBtn?.addEventListener("click", () => {
  const ok = wrapSelection(skText, "[[b]]", "[[/b]]");
  if(!ok){ toast(skToast, "íš¨ê³¼ë¥¼ ì ìš©í•  í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ë“œë˜ê·¸í•´ì„œ ì„ íƒí•´ì¤˜."); return; }
  toast(skToast, "ì„ íƒí•œ ë¶€ë¶„ì— íŒŒë€ìƒ‰ íš¨ê³¼ë¥¼ ì ìš©í–ˆì–´.");
  renderSkillPreview();
});

skRedBtn?.addEventListener("click", () => {
  const ok = wrapSelection(skText, "[[r]]", "[[/r]]");
  if(!ok){ toast(skToast, "íš¨ê³¼ë¥¼ ì ìš©í•  í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ë“œë˜ê·¸í•´ì„œ ì„ íƒí•´ì¤˜."); return; }
  toast(skToast, "ì„ íƒí•œ ë¶€ë¶„ì— ë¹¨ê°„ìƒ‰ íš¨ê³¼ë¥¼ ì ìš©í–ˆì–´.");
  renderSkillPreview();
});


arAddBtn?.addEventListener("click", () => {
  const wasEditing = (__autoRuleEditingIdx>=0);
  addAutoRuleFromEditor();
  toast(skToast, wasEditing ? "ìë™ ê·œì¹™ì„ ìˆ˜ì •í–ˆì–´." : "ìë™ ê·œì¹™ì„ ì¶”ê°€í–ˆì–´.");
});

arPresetPowerBtn?.addEventListener("click", () => {
  endEditAutoRule();
  addAutoRuleFromEditor({
    v:2,
    trigger:"use",
    applyTarget:"self",
    refTarget:"self",
    condType:"none",
    actType:"powerMod",
    powerKind:"attackPower",
    powerAmt:3,
    cap:0,
    visible:1,
    label:"í”„ë¦¬ì…‹: [ì‚¬ìš©ì‹œ] ê³µê²© ìœ„ë ¥ +3"
  });
  toast(skToast, "í”„ë¦¬ì…‹ ê·œì¹™ì„ ì¶”ê°€í–ˆì–´.");
});

arPresetTransferBtn?.addEventListener("click", () => {
  endEditAutoRule();
  addAutoRuleFromEditor({
    v:2,
    trigger:"onHit",
    applyTarget:"target",
    refTarget:"self",
    condType:"none",
    actType:"keywordMod",
    actKw:"í™”ìƒ",
    actKwPow:3,
    actKwCnt:3,
    hitIndex:1,
    cap:0,
    visible:1,
    label:"í”„ë¦¬ì…‹: [1ì½”ì¸ ì ì¤‘ì‹œ] ëŒ€ìƒì—ê²Œ í™”ìƒ(3/3)"
  });
  toast(skToast, "í”„ë¦¬ì…‹ ê·œì¹™ì„ ì¶”ê°€í–ˆì–´.");
});

/** ì €ì¥ */
skSaveBtn.addEventListener("click", async () => {
  try {
    const before = skills.slice(); // ë¡¤ë°±ìš©
    const prev = activeSkId ? skills.find(x => x.id === activeSkId) : null;

    const payload = {
      id: activeSkId || skUid(),
      name: skName?.value || "",
      atkType: skAtkType?.value || "pierce",
      sin: skSin?.value || "pride",
      tier: Number(skTier?.value || 1),
      power: Number(skPower?.value || 0),
      coinSign: (skCoinSignBtn?.dataset?.sign === "-") ? "-" : "+",
      coinPower: Number(skCoinPower?.value || 0),
      atkLevel: Number(skAtkLevel?.value || 0),
      growth: Number(skGrowth?.value || 0),
      weight: Number(skWeight?.value || 0),
actionType: (skActionType === "defense") ? "defense" : "attack",

      // âœ… ìµœì¢… ì €ì¥ í•„ë“œ (ì´ë¦„ í†µì¼)
      kind: (skCurrentKind === "special") ? "special" : "normal",
      spawnChance: clampSkillSpawn(skillSpawnChance ? skillSpawnChance.value : 100),

      coinType: (skCoinType?.value || "normal"),
      coinCount: Number(skCoinCount?.value || 1),
          defenseMode: deriveDefenseModeFromEditor(),
      text: skText?.value || "",
      hitSfx: skHitSfxWasCleared ? "" : ((skHitSfx?.value?.trim()) || (prev?.hitSfx || "")),
      hitSfxKey: skHitSfxWasCleared ? "" : (prev?.hitSfxKey || ""),
      hitSfxName: skHitSfxWasCleared ? "" : (prev?.hitSfxName || ""),
      coinSfxPaths: skCoinVoiceDrafts.map(v => String(v?.path || "")),
      coinSfxKeys: Array.from({length:5}, (_,i)=> String(skCoinVoiceDrafts[i]?.key || "")),
      coinSfxNames: Array.from({length:5}, (_,i)=> String(skCoinVoiceDrafts[i]?.name || "")),
      autoRules: currentAutoRules.map(normalizeAutoRule),
      imgKey: ""
    };

    // ê¸°ì¡´ í•­ëª©ì´ë©´ imgKey ìœ ì§€
    payload.imgKey = prev?.imgKey || "";

    // pending ì´ë¯¸ì§€ ìˆìœ¼ë©´ IndexedDB ì €ì¥
    if (skPendingImgDataURL && skPendingImgDataURL.startsWith("data:image/")) {
      try {
        const blob = dataURLToBlob(skPendingImgDataURL);
        payload.imgKey = `skill_img_${payload.id}`;
        await idbPutBlob(payload.imgKey, blob);
      } catch (e) {
        console.error("ìŠ¤í‚¬ ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨:", e);
        toast(skToast, "ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨(ë¸Œë¼ìš°ì € ì œí•œ/í˜•ì‹ ë¬¸ì œ).");
        return;
      }
    }

    try{
      if(skPendingHitSfxFile){
        const key = `skill_hit_sfx_${payload.id}`;
        await idbPutBlob(key, skPendingHitSfxFile);
        payload.hitSfxKey = key;
        payload.hitSfxName = skPendingHitSfxFile.name || 'ì—…ë¡œë“œ ìŒì„±';
        skHitSfxWasCleared = false;
      }
      for(let i=0;i<5;i++){
        const f = skPendingCoinSfxFiles[i];
        if(f){
          const key = `skill_coin_sfx_${payload.id}_${i+1}`;
          await idbPutBlob(key, f);
          payload.coinSfxKeys[i] = key;
          payload.coinSfxNames[i] = f.name || `ì½”ì¸${i+1} íš¨ê³¼ìŒ`;
        }
      }
      for(let i=0;i<5;i++){
        skCoinVoiceDrafts[i] = {
          path: payload.coinSfxPaths[i] || "",
          key: payload.coinSfxKeys[i] || "",
          name: payload.coinSfxNames[i] || ""
        };
      }
    }catch(e){
      console.error("ìŠ¤í‚¬ íš¨ê³¼ìŒ ì €ì¥ ì‹¤íŒ¨:", e);
      toast(skToast, "íš¨ê³¼ìŒ ì €ì¥ ì‹¤íŒ¨(ë¸Œë¼ìš°ì € ì œí•œ/í˜•ì‹ ë¬¸ì œ).");
      return;
    }

    // skills ë°°ì—´ ë°˜ì˜
    if (activeSkId) {
      const idx = skills.findIndex(x => x.id === activeSkId);
      if (idx >= 0) skills[idx] = payload;
      else skills.unshift(payload);
    } else {
      skills.unshift(payload);
    }

    activeSkId = payload.id;
  window.activeSkId = activeSkId;
    skPendingImgDataURL = "";
    window.skPendingImgDataURL = skPendingImgDataURL;
    skPendingHitSfxFile = null;
    skHitSfxWasCleared = false;
    skPendingCoinSfxFiles = [null,null,null,null,null];
    hydrateVoiceDraftsFromSkill(payload);
    refreshSkillSfxInfo(payload);

    // localStorage ì €ì¥
    if (!skSaveStore()) {
      skills = before;
      try { await renderSkillList(); } catch (_) {}
      try { await renderSkillPreview(); } catch (_) {}
      return;
    }

    // âœ… ì €ì¥ ì„±ê³µ í† ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ë³´ì—¬ì¤Œ (ë Œë” ì—ëŸ¬ê°€ ë‚˜ë„ ì‚¬ìš©ì í”¼ë“œë°± ë³´ì´ê²Œ)
    toast(skToast, "ìŠ¤í‚¬ ì €ì¥ ì™„ë£Œ!");

    // ë Œë”
    try {
      await renderSkillList();
    } catch (e) {
      console.error("renderSkillList ì‹¤íŒ¨:", e);
      toast(skToast, "ì €ì¥ì€ ëëŠ”ë° ëª©ë¡ ê°±ì‹  ì¤‘ ì—ëŸ¬ê°€ ë‚¬ì–´. ì½˜ì†” í™•ì¸ í•„ìš”.");
      return;
    }

    try {
      await renderSkillPreview();
    } catch (e) {
      console.error("renderSkillPreview ì‹¤íŒ¨:", e);
      // ë¯¸ë¦¬ë³´ê¸° ì‹¤íŒ¨í•´ë„ ì €ì¥ì€ ëœ ìƒíƒœ
    }

  } catch (e) {
    console.error("ìŠ¤í‚¬ ì €ì¥ í•¸ë“¤ëŸ¬ ì „ì²´ ì‹¤íŒ¨:", e);
    try { toast(skToast, `ì €ì¥ ì‹¤íŒ¨: ${e?.message || e}`); } catch (_) {}
  }
});
/** ì‚­ì œ */
skDeleteBtn.addEventListener("click", async () => {
  if(!activeSkId){
    toast(skToast, "ì‚­ì œí•  ìŠ¤í‚¬ì„ ë¨¼ì € ì„ íƒí•´ì¤˜.");
    return;
  }
  const idx = skills.findIndex(x => x.id === activeSkId);
  if(idx < 0) return;

  const oldKey = skills[idx].imgKey || "";
  if(oldKey){
    try{ await idbDel(oldKey); }catch(e){}
  }

  skills.splice(idx, 1);
  skSaveStore();
  toast(skToast, "ìŠ¤í‚¬ ì‚­ì œ ì™„ë£Œ!");
  await newSkill();
});

/** ìƒˆ ìŠ¤í‚¬ */
skNewBtn.addEventListener("click", newSkill);

/** ì´ˆê¸° ë¡œë“œ */
(async () => {
  try{ skLoadStore();
window.skills = skills; }catch(e){ console.error(e); }
  await renderSkillList();
  await newSkill();
})();

/** âœ… ìŠ¤í‚¬ ë¯¸ë¦¬ë³´ê¸° ì˜ì—­ì—ì„œë„ í‚¤ì›Œë“œ hover íˆ´íŒ ì‘ë™í•˜ê²Œ ì—°ê²° */
document.getElementById("skPreviewCard").addEventListener("mousemove", (e) => {
  const t = e.target;
  if(!(t instanceof HTMLElement)) return;

  const kwEl = t.closest(".pvKW");
  if(!kwEl) { hideKwTip(); return; }

  const name = kwEl.getAttribute("data-kw") || kwEl.textContent || "";
  const stateHint = kwEl.getAttribute("data-state") || "";
  showKwTipFor(name, stateHint, e.clientX, e.clientY);
});
document.getElementById("skPreviewCard").addEventListener("mouseout", (e) => {
  const from = e.target;
  if(!(from instanceof HTMLElement)) return;

  const fromKw = from.closest(".pvKW");
  if(!fromKw) return;

  const to = e.relatedTarget;
  if(to instanceof HTMLElement && to.closest(".pvKW")) return;

  hideKwTip();
});
document.getElementById("skPreviewCard").addEventListener("mouseleave", hideKwTip);

    // (ì„ íƒ) í˜ì´ì§€ ë– ë‚  ë•Œ objectURL ì •ë¦¬
    window.addEventListener("beforeunload", () => {
      if(_portraitObjectURL){
        try{ URL.revokeObjectURL(_portraitObjectURL); }catch(e){}
      }
      for(const [k, u] of _iconObjectURLMap.entries()){
        try{ URL.revokeObjectURL(u); }catch(e){}
      }
      _iconObjectURLMap.clear();
    });

  

/* ==== index41 voice multi override ==== */
(function(){
  function normActivationList(skill){
    const out = [];
    if(Array.isArray(skill?.activationSfxPaths) || Array.isArray(skill?.activationSfxKeys) || Array.isArray(skill?.activationSfxNames)){
      const maxlen = Math.max(skill?.activationSfxPaths?.length||0, skill?.activationSfxKeys?.length||0, skill?.activationSfxNames?.length||0);
      for(let i=0;i<maxlen;i++){
        const path = String(skill?.activationSfxPaths?.[i] || "");
        const key = String(skill?.activationSfxKeys?.[i] || "");
        const name = String(skill?.activationSfxNames?.[i] || "");
        if(path.trim() || key) out.push({path,key,name});
      }
    }
    if(!out.length && ((skill?.hitSfx||'').trim() || skill?.hitSfxKey)){
      out.push({path:String(skill?.hitSfx||''), key:String(skill?.hitSfxKey||''), name:String(skill?.hitSfxName||'')});
    }
    return out;
  }
  function normCoinVoiceMap(skill){
    const map = {1:[],2:[],3:[],4:[],5:[]};
    if(skill && skill.coinSfxMap && typeof skill.coinSfxMap === 'object'){
      for(let slot=1; slot<=5; slot++){
        const arr = Array.isArray(skill.coinSfxMap[slot]) ? skill.coinSfxMap[slot] : [];
        map[slot] = arr.map(v=>({path:String(v?.path||''), key:String(v?.key||''), name:String(v?.name||'')})).filter(v=>v.path.trim()||v.key);
      }
      return map;
    }
    for(let slot=1; slot<=5; slot++){
      const idx = slot-1;
      const path = String(skill?.coinSfxPaths?.[idx] || '');
      const key = String(skill?.coinSfxKeys?.[idx] || '');
      const name = String(skill?.coinSfxNames?.[idx] || '');
      if(path.trim() || key) map[slot].push({path,key,name});
    }
    return map;
  }

  window.skActivationVoiceDrafts = [];
  window.skPendingActivationSfxFiles = [];
  // íšŒí”¼(ì„±ê³µ/ì‹¤íŒ¨) ì „ìš© ìŒì„± í’€(ì—ë””í„° ìƒíƒœ)
  window.skEvadeSuccessVoiceDrafts = [];
  window.skEvadeFailVoiceDrafts = [];
  window.skPendingEvadeSuccessSfxFiles = [];
  window.skPendingEvadeFailSfxFiles = [];
  window.skCoinVoiceDraftsMulti = {1:[],2:[],3:[],4:[],5:[]};
  window.skPendingCoinSfxFilesMulti = {1:[],2:[],3:[],4:[],5:[]};

  function buildVoiceEditorUI(){
    const hitBox = document.getElementById('skHitSfx')?.closest('.box');
    if(hitBox && !document.getElementById('skActivationVoiceList')){
      hitBox.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
          <div class="passLabel">ë°œë™ ì‹œ ìŒì„±</div>
          <button type="button" id="skActivationVoiceAddBtn">ìŒì„± ì¶”ê°€</button>
        </div>
        <div id="skActivationVoiceList" style="margin-top:8px; display:flex; flex-direction:column; gap:10px;"></div>
        <div id="skActivationVoiceEmpty" style="margin-top:8px; color:var(--muted); font-size:12px;">ì¶”ê°€ëœ ë°œë™ ì‹œ ìŒì„±ì´ ì—†ì–´. 'ìŒì„± ì¶”ê°€'ë¥¼ ëˆŒëŸ¬ ë„£ì–´ì¤˜.</div>
        <div style="margin-top:6px; color:var(--muted); font-size:12px;">ì´ ìŠ¤í‚¬ì´ í•©ì—ì„œ ìŠ¹ë¦¬í•œ ë’¤ ì‹¤ì œë¡œ ì ì„ ê³µê²©í•  ë•Œ ì¬ìƒë¼. ì—¬ëŸ¬ ê°œë¥¼ ë“±ë¡í•˜ë©´ ë™ì‹œì— ì¬ìƒë¼.</div>
      `;
    }
    const coinBox = document.getElementById('skCoinVoiceList')?.closest('.box');
    if(coinBox){
      coinBox.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
          <div class="passLabel">ì½”ì¸ë³„ íš¨ê³¼ìŒ</div>
          <button type="button" id="skCoinVoiceAddBtn">ìŒì„± ì¶”ê°€</button>
        </div>
        <div id="skCoinVoiceList" style="margin-top:8px; display:flex; flex-direction:column; gap:10px;"></div>
        <div id="skCoinVoiceEmpty" style="margin-top:8px; color:var(--muted); font-size:12px;">ì¶”ê°€ëœ ì½”ì¸ ìŒì„±ì´ ì—†ì–´. 'ìŒì„± ì¶”ê°€'ë¥¼ ëˆŒëŸ¬ ì½”ì¸ ë²ˆí˜¸ë¥¼ ê³¨ë¼ ë„£ì–´ì¤˜.</div>
      `;
    }
  }
  buildVoiceEditorUI();

  const skActivationVoiceList = document.getElementById('skActivationVoiceList');
  const skActivationVoiceEmpty = document.getElementById('skActivationVoiceEmpty');
  const skActivationVoiceAddBtn = document.getElementById('skActivationVoiceAddBtn');
  const skCoinVoiceList2 = document.getElementById('skCoinVoiceList');
  const skCoinVoiceEmpty2 = document.getElementById('skCoinVoiceEmpty');
  const skCoinVoiceAddBtn2 = document.getElementById('skCoinVoiceAddBtn');

  function hydrateVoiceDraftsFromSkillNew(skill){
    // ê¸°ë³¸: ë°œë™ ì‹œ ìŒì„±(ê³µê²©/ê¸°íƒ€)
    window.skActivationVoiceDrafts = normActivationList(skill);
    window.skPendingActivationSfxFiles = new Array(window.skActivationVoiceDrafts.length).fill(null);

    // íšŒí”¼ ì „ìš©: ì„±ê³µ/ì‹¤íŒ¨ ìŒì„± í’€(êµì°¨ ì €ì¥ì„ UIì—ì„œ ë¶„ë¦¬í•´ ë³´ì—¬ì¤Œ)
    window.skEvadeSuccessVoiceDrafts = [];
    window.skEvadeFailVoiceDrafts = [];
    const a = window.skActivationVoiceDrafts;
    for(let i=0;i<a.length;i++){
      const v = a[i] || {path:'',key:'',name:''};
      if(i%2===0) window.skEvadeSuccessVoiceDrafts.push({path:v.path||'', key:v.key||'', name:v.name||''});
      else window.skEvadeFailVoiceDrafts.push({path:v.path||'', key:v.key||'', name:v.name||''});
    }
    window.skPendingEvadeSuccessSfxFiles = new Array(window.skEvadeSuccessVoiceDrafts.length).fill(null);
    window.skPendingEvadeFailSfxFiles = new Array(window.skEvadeFailVoiceDrafts.length).fill(null);

    // ì½”ì¸ ìŒì„±(ìŠ¬ë¡¯ë³„ ë‹¤ì¤‘)
    window.skCoinVoiceDraftsMulti = normCoinVoiceMap(skill);
    window.skPendingCoinSfxFilesMulti = {1:[],2:[],3:[],4:[],5:[]};
    for(let slot=1; slot<=5; slot++){
      const arr = window.skCoinVoiceDraftsMulti[slot] || [];
      window.skPendingCoinSfxFilesMulti[slot] = new Array(arr.length).fill(null);
    }
  }
  window.hydrateVoiceDraftsFromSkill = hydrateVoiceDraftsFromSkillNew;

  function renderActivationVoiceList(baseSkill=null){
    const addBtn = document.getElementById('skActivationVoiceAddBtn');
    if(!skActivationVoiceList) return;
    const skill = baseSkill || (typeof getSkillById === 'function' ? getSkillById(window.activeSkId) : null) || null;
    skActivationVoiceList.innerHTML = '';

    const modeRaw = String((typeof skAtkType!=='undefined' && skAtkType && skAtkType.value) ? skAtkType.value : (skill?.defenseMode || skill?.atkType || skill?.type || '')).toLowerCase();
    const isEvadeUi = (modeRaw === "evade");

    // íšŒí”¼ ëª¨ë“œì—ì„œëŠ” ê¸°ì¡´ "ë°œë™ ì‹œ ìŒì„± ì¶”ê°€" ë²„íŠ¼ ìˆ¨ê¸°ê³ , ì„±ê³µ/ì‹¤íŒ¨ ê°ê° ì¶”ê°€ ë²„íŠ¼ì„ ë³„ë„ë¡œ ì œê³µ
    if(addBtn) addBtn.style.display = isEvadeUi ? 'none' : '';

    // í—¬í¼: í–‰ ìƒì„±
    const makeRow = (kind, idx, labelText, draftsArr, pendingArr)=>{
      const row = document.createElement('div');
      row.className = 'miniBlock';
      row.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
          <div style="font-weight:800;color:rgba(243,211,154,.95);">${labelText}</div>
          <button type="button" class="ghost" data-remove-ev-row="${kind}:${idx}">ì œê±°</button>
        </div>
        <div style="margin-top:8px;"><input class="textInput" data-ev-path="${kind}:${idx}" type="text" placeholder="ì˜ˆ: assets/voice_skill_hit_01.mp3 (ì„ íƒ)" /></div>
        <div class="dkButtons" style="margin-top:8px;">
          <button class="primary file" type="button">íš¨ê³¼ìŒ íŒŒì¼ ì—…ë¡œë“œ
            <input data-ev-file="${kind}:${idx}" type="file" accept="audio/*" />
          </button>
        </div>
        <div data-ev-info="${kind}:${idx}" style="margin-top:6px; color:var(--muted); font-size:12px;">ì—…ë¡œë“œëœ íŒŒì¼ ì—†ìŒ</div>
      `;
      skActivationVoiceList.appendChild(row);

      const pathEl = row.querySelector('[data-ev-path]');
      const fileEl = row.querySelector('[data-ev-file]');
      const infoEl = row.querySelector('[data-ev-info]');

      const d = draftsArr[idx] || {path:'',key:'',name:''};
      pathEl.value = d.path || '';

      const refresh = ()=>{
        const cur = draftsArr[idx] || {path:'',key:'',name:''};
        const pending = pendingArr[idx];
        if(pending){
          infoEl.textContent = `ì—…ë¡œë“œë¨: ${pending.name || 'audio'}`;
        }else if(cur.key){
          infoEl.textContent = `ì €ì¥ëœ íŒŒì¼: ${cur.name || cur.key}`;
        }else if(cur.path){
          infoEl.textContent = `ê²½ë¡œ: ${cur.path}`;
        }else{
          infoEl.textContent = 'ì—…ë¡œë“œëœ íŒŒì¼ ì—†ìŒ';
        }
      };

      pathEl.addEventListener('input', ()=>{
        draftsArr[idx] = draftsArr[idx] || {path:'',key:'',name:''};
        draftsArr[idx].path = pathEl.value || '';
        refresh();
      });

      fileEl.addEventListener('change', ()=>{
        const f = fileEl.files && fileEl.files[0] ? fileEl.files[0] : null;
        pendingArr[idx] = f;
        draftsArr[idx] = draftsArr[idx] || {path:'',key:'',name:''};
        // ì—…ë¡œë“œ íŒŒì¼ì€ ê²½ë¡œ ëŒ€ì‹  keyë¡œ ì €ì¥ë  ì˜ˆì •ì´ë¯€ë¡œ pathëŠ” ìœ ì§€/ë¹„ì›Œë„ ë¬´ë°©. ì•ˆì „í•˜ê²Œ ë¹„ìš°ì§€ ì•ŠìŒ.
        refresh();
      });

      row.querySelector('[data-remove-ev-row]')?.addEventListener('click', ()=>{
        draftsArr.splice(idx, 1);
        pendingArr.splice(idx, 1);
        renderActivationVoiceList(typeof getSkillById==='function' ? getSkillById(window.activeSkId) : null);
      });

      refresh();
    };

    if(isEvadeUi){
      // âœ… íšŒí”¼: ì„±ê³µ/ì‹¤íŒ¨ ìŒì„± í’€ì„ ë¶„ë¦¬í•´ì„œ í‘œì‹œ
      const wrap = document.createElement('div');
      wrap.style.display = 'grid';
      wrap.style.gridTemplateColumns = 'repeat(auto-fit, minmax(240px, 1fr))';
      wrap.style.gap = '10px';
      skActivationVoiceList.appendChild(wrap);

      const makeSection = (title, kind)=>{
        const box = document.createElement('div');
        box.className = 'miniBlock';
        box.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
            <div style="font-weight:900;">${title}</div>
            <button type="button" class="primary" data-add-ev="${kind}">ì¶”ê°€</button>
          </div>
          <div data-ev-list="${kind}" style="margin-top:10px; display:flex; flex-direction:column; gap:10px;"></div>
          <div data-ev-empty="${kind}" style="margin-top:10px; color:var(--muted); font-size:12px; display:none;">ë“±ë¡ëœ ìŒì„±ì´ ì—†ì–´</div>
        `;
        wrap.appendChild(box);
        return box;
      };

      const secS = makeSection('íšŒí”¼ ì„±ê³µ ìŒì„±', 'success');
      const secF = makeSection('íšŒí”¼ ì‹¤íŒ¨ ìŒì„±', 'fail');

      const listS = secS.querySelector('[data-ev-list="success"]');
      const listF = secF.querySelector('[data-ev-list="fail"]');
      const emptyS = secS.querySelector('[data-ev-empty="success"]');
      const emptyF = secF.querySelector('[data-ev-empty="fail"]');

      // ìµœì†Œ 1ì¹¸ ë³´ì¥(ì™„ì „ ë¹„ë©´ UIê°€ í—·ê°ˆë ¤ì„œ)
      if(!Array.isArray(window.skEvadeSuccessVoiceDrafts)) window.skEvadeSuccessVoiceDrafts = [];
      if(!Array.isArray(window.skEvadeFailVoiceDrafts)) window.skEvadeFailVoiceDrafts = [];
      if(!Array.isArray(window.skPendingEvadeSuccessSfxFiles)) window.skPendingEvadeSuccessSfxFiles = [];
      if(!Array.isArray(window.skPendingEvadeFailSfxFiles)) window.skPendingEvadeFailSfxFiles = [];

      if(window.skEvadeSuccessVoiceDrafts.length === 0){
        window.skEvadeSuccessVoiceDrafts.push({path:'',key:'',name:''});
        window.skPendingEvadeSuccessSfxFiles.push(null);
      }
      if(window.skEvadeFailVoiceDrafts.length === 0){
        window.skEvadeFailVoiceDrafts.push({path:'',key:'',name:''});
        window.skPendingEvadeFailSfxFiles.push(null);
      }

      // ë Œë”
      listS.innerHTML = '';
      listF.innerHTML = '';
      window.skEvadeSuccessVoiceDrafts.forEach((d, i)=>{
        const holder = document.createElement('div');
        listS.appendChild(holder);
        // makeRowëŠ” skActivationVoiceListì— appendí•˜ë¯€ë¡œ, ì ê¹ ëŒ€ì²´ë¡œ ë¶™ì˜€ë‹¤ê°€ ì´ë™
      });
      // makeRowëŠ” ì§ì ‘ skActivationVoiceListì— ë¶™ì´ë¯€ë¡œ, ì„¹ì…˜ë³„ ë¦¬ìŠ¤íŠ¸ì— ë¶™ì´ê¸° ìœ„í•´ ì„ì‹œ ì»¨í…Œì´ë„ˆë¥¼ ì‚¬ìš©
      const __appendInto = (targetList, kind, idx, label, draftsArr, pendingArr)=>{
        const prev = skActivationVoiceList;
        // hack: row ìƒì„± í›„ targetListë¡œ ì˜®ê¸°ê¸°
        const beforeCount = prev.children.length;
        makeRow(kind, idx, label, draftsArr, pendingArr);
        const row = prev.children[beforeCount]; // ë§ˆì§€ë§‰ ì¶”ê°€ëœ ìš”ì†Œ
        if(row) targetList.appendChild(row);
      };

      // ì„±ê³µ/ì‹¤íŒ¨ rows
      for(let i=0;i<window.skEvadeSuccessVoiceDrafts.length;i++){
        __appendInto(listS, 'success', i, `ì„±ê³µ ìŒì„± ${i+1}`, window.skEvadeSuccessVoiceDrafts, window.skPendingEvadeSuccessSfxFiles);
      }
      for(let i=0;i<window.skEvadeFailVoiceDrafts.length;i++){
        __appendInto(listF, 'fail', i, `ì‹¤íŒ¨ ìŒì„± ${i+1}`, window.skEvadeFailVoiceDrafts, window.skPendingEvadeFailSfxFiles);
      }

      if(emptyS) emptyS.style.display = window.skEvadeSuccessVoiceDrafts.length ? 'none' : 'block';
      if(emptyF) emptyF.style.display = window.skEvadeFailVoiceDrafts.length ? 'none' : 'block';

      // ì¶”ê°€ ë²„íŠ¼
      secS.querySelector('[data-add-ev="success"]')?.addEventListener('click', ()=>{
        window.skEvadeSuccessVoiceDrafts.push({path:'',key:'',name:''});
        window.skPendingEvadeSuccessSfxFiles.push(null);
        renderActivationVoiceList(typeof getSkillById==='function' ? getSkillById(window.activeSkId) : null);
      });
      secF.querySelector('[data-add-ev="fail"]')?.addEventListener('click', ()=>{
        window.skEvadeFailVoiceDrafts.push({path:'',key:'',name:''});
        window.skPendingEvadeFailSfxFiles.push(null);
        renderActivationVoiceList(typeof getSkillById==='function' ? getSkillById(window.activeSkId) : null);
      });

      return;
    }

    // âœ… ê¸°ë³¸(íšŒí”¼ ì•„ë‹˜): ê¸°ì¡´ ë°œë™ ì‹œ ìŒì„± ë¦¬ìŠ¤íŠ¸
    if(skActivationVoiceEmpty) skActivationVoiceEmpty.style.display = window.skActivationVoiceDrafts.length ? 'none' : 'block';
    window.skActivationVoiceDrafts.forEach((draft, idx)=>{
      const row = document.createElement('div');
      row.className = 'miniBlock';
      row.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
          <div style="font-weight:800;color:rgba(243,211,154,.95);">ë°œë™ ì‹œ ìŒì„± ${idx+1}</div>
          <button type="button" class="ghost" data-remove-activation="${idx}">ì œê±°</button>
        </div>
        <div style="margin-top:8px;"><input class="textInput" data-activation-path="${idx}" type="text" placeholder="ì˜ˆ: assets/voice_skill_hit_01.mp3 (ì„ íƒ)" /></div>
        <div class="dkButtons" style="margin-top:8px;"><button class="primary file" type="button">íš¨ê³¼ìŒ íŒŒì¼ ì—…ë¡œë“œ<input data-activation-file="${idx}" type="file" accept="audio/*" /></button></div>
        <div data-activation-info="${idx}" style="margin-top:6px; color:var(--muted); font-size:12px;">ì—…ë¡œë“œëœ íŒŒì¼ ì—†ìŒ</div>
      `;
      skActivationVoiceList.appendChild(row);
      const pathEl = row.querySelector('[data-activation-path]');
      const fileEl = row.querySelector('[data-activation-file]');
      const infoEl = row.querySelector('[data-activation-info]');
      pathEl.value = draft.path || '';
      const refresh=()=>{
        const cur = window.skActivationVoiceDrafts[idx] || {path:'',key:'',name:''};
        const pending = window.skPendingActivationSfxFiles[idx];
        if(pending){ infoEl.textContent = `ì—…ë¡œë“œë¨: ${pending.name || 'audio'}`; }
        else if(cur.key){ infoEl.textContent = `ì €ì¥ëœ íŒŒì¼: ${cur.name || cur.key}`; }
        else if(cur.path){ infoEl.textContent = `ê²½ë¡œ: ${cur.path}`; }
        else infoEl.textContent = 'ì—…ë¡œë“œëœ íŒŒì¼ ì—†ìŒ';
      };
      pathEl.addEventListener('input', ()=>{
        window.skActivationVoiceDrafts[idx] = window.skActivationVoiceDrafts[idx] || {path:'',key:'',name:''};
        window.skActivationVoiceDrafts[idx].path = pathEl.value || '';
        refresh();
      });
      fileEl.addEventListener('change', ()=>{
        const f = fileEl.files && fileEl.files[0] ? fileEl.files[0] : null;
        window.skPendingActivationSfxFiles[idx] = f;
        refresh();
      });
      row.querySelector('[data-remove-activation]')?.addEventListener('click', ()=>{
        window.skActivationVoiceDrafts.splice(idx,1);
        window.skPendingActivationSfxFiles.splice(idx,1);
        renderActivationVoiceList(typeof getSkillById==='function' ? getSkillById(window.activeSkId) : null);
      });
      refresh();
    });
  }

  // íšŒí”¼ ìŒì„± ì €ì¥ì„ ìœ„í•´ ì„±ê³µ/ì‹¤íŒ¨ í’€ì„ êµì°¨ ë°°ì—´ë¡œ ë³€í™˜
  function interleaveEvadeDrafts(successDrafts, failDrafts){
    const s = Array.isArray(successDrafts) ? successDrafts : [];
    const f = Array.isArray(failDrafts) ? failDrafts : [];
    const out = [];
    const n = Math.max(s.length, f.length);
    for(let i=0;i<n;i++){
      const sv = s[i] || {path:'',key:'',name:''};
      const fv = f[i] || {path:'',key:'',name:''};
      out.push({path:String(sv.path||''), key:String(sv.key||''), name:String(sv.name||'')});
      out.push({path:String(fv.path||''), key:String(fv.key||''), name:String(fv.name||'')});
    }
    // ë’¤ìª½ ë¹ˆ ê°’ ì •ë¦¬(ì™„ì „ ë¹„ì–´ìˆëŠ” pairëŠ” ì œê±°)
    while(out.length){
      const last = out[out.length-1];
      if((last?.path||'') || (last?.key||'') || (last?.name||'')) break;
      out.pop();
    }
    return out;
  }

  function interleaveEvadePending(successPending, failPending){
    const s = Array.isArray(successPending) ? successPending : [];
    const f = Array.isArray(failPending) ? failPending : [];
    const out = [];
    const n = Math.max(s.length, f.length);
    for(let i=0;i<n;i++){
      out.push(s[i] || null);
      out.push(f[i] || null);
    }
    while(out.length && !out[out.length-1]) out.pop();
    return out;
  }



function renderCoinVoiceListNew(baseSkill=null){
    if(!skCoinVoiceList2) return;
    const skill = baseSkill || (typeof getSkillById === 'function' ? getSkillById(window.activeSkId) : null) || null;
    skCoinVoiceList2.innerHTML = '';
    let countRows = 0;
    for(let slot=1; slot<=5; slot++){
      const arr = window.skCoinVoiceDraftsMulti[slot] || [];
      arr.forEach((draft, idx)=>{
        countRows++;
        const row = document.createElement('div');
        row.className = 'miniBlock';
        row.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
            <div style="font-weight:800;color:rgba(243,211,154,.95);">${slot}ì½”ì¸ ìŒì„± ${idx+1}</div>
            <button type="button" class="ghost" data-remove-slot="${slot}" data-remove-idx="${idx}">ì œê±°</button>
          </div>
          <div style="margin-top:8px;"><input class="textInput" data-coin-path="${slot}" data-coin-idx="${idx}" type="text" placeholder="ì˜ˆ: assets/voice_coin_${slot}.mp3 (ì„ íƒ)" /></div>
          <div class="dkButtons" style="margin-top:8px;"><button class="primary file" type="button">íš¨ê³¼ìŒ íŒŒì¼ ì—…ë¡œë“œ<input data-coin-file="${slot}" data-coin-idx="${idx}" type="file" accept="audio/*" /></button></div>
          <div data-coin-info="${slot}" data-coin-info-idx="${idx}" style="margin-top:6px; color:var(--muted); font-size:12px;">ì—…ë¡œë“œëœ íŒŒì¼ ì—†ìŒ</div>
        `;
        skCoinVoiceList2.appendChild(row);
        const pathEl = row.querySelector('[data-coin-path]');
        const fileEl = row.querySelector('[data-coin-file]');
        const infoEl = row.querySelector('[data-coin-info]');
        pathEl.value = draft.path || '';
        const refresh=()=>{
          const cur = (window.skCoinVoiceDraftsMulti[slot]||[])[idx] || {path:'',key:'',name:''};
          const pending = (window.skPendingCoinSfxFilesMulti[slot]||[])[idx];
          if(pending) infoEl.textContent = `ì„ íƒë¨: ${pending.name}`;
          else if((cur.path||'').trim()) infoEl.textContent = `ê²½ë¡œ ì§€ì •ë¨: ${cur.path.trim()}`;
          else if(cur.key) infoEl.textContent = `ì €ì¥ëœ íŒŒì¼: ${cur.name || `ì½”ì¸${slot} ìŒì„±`}`;
          else infoEl.textContent = 'ì—…ë¡œë“œëœ íŒŒì¼ ì—†ìŒ';
        };
        refresh();
        pathEl.addEventListener('input', ()=>{
          const arr2 = window.skCoinVoiceDraftsMulti[slot] || []; arr2[idx] = {...(arr2[idx]||{path:'',key:'',name:''}), path:pathEl.value||''}; window.skCoinVoiceDraftsMulti[slot]=arr2; refresh(); if(typeof renderSkillPreview==='function') renderSkillPreview();
        });
        fileEl.addEventListener('change', (e)=>{ const arrP = window.skPendingCoinSfxFilesMulti[slot] || []; arrP[idx] = e.target.files && e.target.files[0] ? e.target.files[0] : null; window.skPendingCoinSfxFilesMulti[slot]=arrP; refresh(); });
        row.querySelector('[data-remove-slot]')?.addEventListener('click', ()=>{
          window.skCoinVoiceDraftsMulti[slot].splice(idx,1);
          (window.skPendingCoinSfxFilesMulti[slot]||[]).splice(idx,1);
          renderCoinVoiceListNew(skill);
        });
      });
    }
    if(skCoinVoiceEmpty2) skCoinVoiceEmpty2.style.display = countRows ? 'none' : 'block';
  }

  window.refreshSkillSfxInfo = function(baseSkill=null){ renderActivationVoiceList(baseSkill); };
  window.renderCoinVoiceList = renderCoinVoiceListNew;

  skActivationVoiceAddBtn?.addEventListener('click', ()=>{
    window.skActivationVoiceDrafts.push({path:'',key:'',name:''});
    window.skPendingActivationSfxFiles.push(null);
    renderActivationVoiceList(typeof getSkillById==='function' ? getSkillById(window.activeSkId) : null);
  });

  skCoinVoiceAddBtn2?.addEventListener('click', ()=>{
    const raw = prompt('ëª‡ ë²ˆì§¸ ì½”ì¸ ìŒì„±ì„ ì¶”ê°€í• ê¹Œ? (1~5)');
    if(raw === null) return;
    const slot = Math.max(1, Math.min(5, Number(raw)||0));
    if(!slot){ alert('1~5 ìˆ«ìë¥¼ ì…ë ¥í•´ì¤˜.'); return; }
    (window.skCoinVoiceDraftsMulti[slot] ||= []).push({path:'',key:'',name:''});
    (window.skPendingCoinSfxFilesMulti[slot] ||= []).push(null);
    renderCoinVoiceListNew(typeof getSkillById==='function' ? getSkillById(window.activeSkId) : null);
  });

  const oldSkLoadStore = window.skLoadStore;
  window.skLoadStore = function(){
    oldSkLoadStore();
    if(!Array.isArray(window.skills)) window.skills = Array.isArray(skills) ? skills : [];
    if(Array.isArray(window.skills)){
      window.skills = window.skills.map(s=>({
        ...s,
        activationSfxPaths: normActivationList(s).map(v=>v.path),
        activationSfxKeys: normActivationList(s).map(v=>v.key),
        activationSfxNames: normActivationList(s).map(v=>v.name),
        coinSfxMap: normCoinVoiceMap(s)
      }));
      skills = window.skills;
    }
  };

  window.skSaveStore = function(){
    try{
      const store = Array.isArray(window.skills) ? window.skills : (Array.isArray(skills) ? skills : []);
      skills = store;
      window.skills = store;
      const compact = store.map(s => ({
        id: s.id,
        name: s.name || "",
        atkType: s.atkType || "pierce",
        sin: s.sin || "pride",
        tier: Number(s.tier || 1),
        power: Number(s.power || 0),
        coinSign: (s.coinSign === "-") ? "-" : "+",
        coinPower: Number(s.coinPower || 0),
        atkLevel: Number(s.atkLevel || 0),
        growth: Number(s.growth || 0),
        weight: Number(s.weight || 0),
        kind: (s.kind === "special") ? "special" : "normal",
        actionType: (s.actionType === "defense") ? "defense" : "attack",
        spawnChance: clampSkillSpawn(s.spawnChance ?? 100),
        coinType: s.coinType || "normal",
        coinCount: Number(s.coinCount || 1),
        text: s.text || "",
        activationSfxPaths: Array.isArray(s.activationSfxPaths) ? s.activationSfxPaths.slice() : [],
        activationSfxKeys: Array.isArray(s.activationSfxKeys) ? s.activationSfxKeys.slice() : [],
        activationSfxNames: Array.isArray(s.activationSfxNames) ? s.activationSfxNames.slice() : [],
        coinSfxMap: (function(map){ const out={}; for(let i=1;i<=5;i++) out[i]=(Array.isArray(map?.[i])?map[i]:[]).map(v=>({path:String(v?.path||''), key:String(v?.key||''), name:String(v?.name||'')})); return out; })(s.coinSfxMap),
        autoRules: Array.isArray(s.autoRules) ? s.autoRules.map(normalizeAutoRule) : [],
        imgKey: s.imgKey || ""
      }));
      const raw = JSON.stringify(compact); localStorage.setItem(KEY_SK, raw); const ok = localStorage.getItem(KEY_SK); if(ok !== raw) throw new Error('localStorage write verify failed'); return true;
    }catch(e){ console.error('SK ì €ì¥ ì‹¤íŒ¨:', e); try{ toast(skToast, 'ìŠ¤í‚¬ ì €ì¥ ì‹¤íŒ¨'); }catch(_){} return false; }
  };

  function wireSaveOverride(){
    const oldBtn = document.getElementById('skSaveBtn');
    if(!oldBtn || oldBtn.dataset.multiVoicePatched==='1') return;
    const newBtn = oldBtn.cloneNode(true);
    newBtn.dataset.multiVoicePatched='1';
    oldBtn.parentNode.replaceChild(newBtn, oldBtn);
    window.skSaveBtn = newBtn;
    newBtn.addEventListener('click', async ()=>{
      try {
        const store = Array.isArray(window.skills) ? window.skills : (Array.isArray(skills) ? skills : []);
        if(!Array.isArray(window.skills)) window.skills = store;
        if(!Array.isArray(skills)) skills = store;
        const before = store.slice();
        const prev = window.activeSkId ? store.find(x => x.id === window.activeSkId) : null;
        const __modeRaw = String(skAtkType?.value || '').toLowerCase();
        const __isEv = (__modeRaw === 'evade');
        const __actDrafts = __isEv ? interleaveEvadeDrafts(window.skEvadeSuccessVoiceDrafts, window.skEvadeFailVoiceDrafts) : window.skActivationVoiceDrafts;
        const __actPending = __isEv ? interleaveEvadePending(window.skPendingEvadeSuccessSfxFiles, window.skPendingEvadeFailSfxFiles) : window.skPendingActivationSfxFiles;

        const payload = {
          id: window.activeSkId || skUid(),
          name: skName?.value || "",
          atkType: skAtkType?.value || "pierce",
          sin: skSin?.value || "pride",
          tier: Number(skTier?.value || 1),
          power: Number(skPower?.value || 0),
          coinSign: (skCoinSignBtn?.dataset?.sign === "-") ? "-" : "+",
          coinPower: Number(skCoinPower?.value || 0),
          atkLevel: Number(skAtkLevel?.value || 0),
          growth: Number(skGrowth?.value || 0),
          weight: Number(skWeight?.value || 0),
          actionType: (skActionType === "defense") ? "defense" : "attack",
          kind: (skCurrentKind === "special") ? "special" : "normal",
          spawnChance: clampSkillSpawn(skillSpawnChance ? skillSpawnChance.value : 100),
          coinType: (skCoinType?.value || "normal"),
          coinCount: Number(skCoinCount?.value || 1),
          text: skText?.value || "",
          activationSfxPaths: (__actDrafts||[]).map(v=>String(v?.path||'')),
          activationSfxKeys: (__actDrafts||[]).map(v=>String(v?.key||'')),
          activationSfxNames: (__actDrafts||[]).map(v=>String(v?.name||'')),
          coinSfxMap: {1:[],2:[],3:[],4:[],5:[]},
          autoRules: currentAutoRules.map(normalizeAutoRule),
          imgKey: prev?.imgKey || ""
        };
        if (window.skPendingImgDataURL && window.skPendingImgDataURL.startsWith('data:image/')) {
          const blob = dataURLToBlob(window.skPendingImgDataURL); payload.imgKey = `skill_img_${payload.id}`; await idbPutBlob(payload.imgKey, blob);
        }
        for(let i=0;i<(__actPending||[]).length;i++){
          const f = (__actPending||[])[i];
          if(f){ const key = `skill_activation_sfx_${payload.id}_${i+1}`; await idbPutBlob(key, f); payload.activationSfxKeys[i]=key; payload.activationSfxNames[i]=f.name||`ë°œë™ìŒì„±${i+1}`; }
        }
        for(let slot=1; slot<=5; slot++){
          const arr = window.skCoinVoiceDraftsMulti[slot] || [];
          const pend = window.skPendingCoinSfxFilesMulti[slot] || [];
          payload.coinSfxMap[slot] = arr.map(v=>({path:String(v?.path||''), key:String(v?.key||''), name:String(v?.name||'')}));
          for(let i=0;i<arr.length;i++){
            const f = pend[i];
            if(f){ const key = `skill_coin_sfx_${payload.id}_${slot}_${i+1}`; await idbPutBlob(key, f); payload.coinSfxMap[slot][i].key=key; payload.coinSfxMap[slot][i].name=f.name||`ì½”ì¸${slot}ìŒì„±${i+1}`; }
          }
        }
        payload.hitSfx = payload.activationSfxPaths[0] || '';
        payload.hitSfxKey = payload.activationSfxKeys[0] || '';
        payload.hitSfxName = payload.activationSfxNames[0] || '';
        payload.coinSfxPaths = Array.from({length:5}, (_,i)=> payload.coinSfxMap[i+1]?.[0]?.path || '');
        payload.coinSfxKeys = Array.from({length:5}, (_,i)=> payload.coinSfxMap[i+1]?.[0]?.key || '');
        payload.coinSfxNames = Array.from({length:5}, (_,i)=> payload.coinSfxMap[i+1]?.[0]?.name || '');
        if (window.activeSkId) { const idx = store.findIndex(x => x.id === window.activeSkId); if (idx >= 0) store[idx] = payload; else store.unshift(payload); }
        else store.unshift(payload);
        skills = store;
        window.skills = store;
        window.activeSkId = payload.id;
        activeSkId = window.activeSkId;
  window.activeSkId = activeSkId;
        window.skPendingImgDataURL = "";
        window.skPendingActivationSfxFiles = new Array(window.skActivationVoiceDrafts.length).fill(null);
        for(let slot=1;slot<=5;slot++) window.skPendingCoinSfxFilesMulti[slot] = new Array((window.skCoinVoiceDraftsMulti[slot]||[]).length).fill(null);
        hydrateVoiceDraftsFromSkillNew(payload);
        if (!window.skSaveStore()) { skills = before; window.skills = before; return; }
        toast(skToast, 'ìŠ¤í‚¬ ì €ì¥ ì™„ë£Œ!');
        try { await renderSkillList(); } catch(_){}
        try { await renderSkillPreview(); } catch(_){}
        renderActivationVoiceList(payload); renderCoinVoiceListNew(payload);
      } catch(e){ console.error(e); toast(skToast, 'ìŠ¤í‚¬ ì €ì¥ ì‹¤íŒ¨'); }
    });
  }

  if(!Array.isArray(window.skills)) window.skills = Array.isArray(skills) ? skills : [];
  if(Array.isArray(window.skills)) window.skills = window.skills.map(s=>({...s, activationSfxPaths:normActivationList(s).map(v=>v.path), activationSfxKeys:normActivationList(s).map(v=>v.key), activationSfxNames:normActivationList(s).map(v=>v.name), coinSfxMap:normCoinVoiceMap(s)}));
  skills = window.skills;
  if(typeof getSkillById==='function') hydrateVoiceDraftsFromSkillNew(getSkillById(window.activeSkId));
  renderActivationVoiceList(typeof getSkillById==='function' ? getSkillById(window.activeSkId) : null);
  renderCoinVoiceListNew(typeof getSkillById==='function' ? getSkillById(window.activeSkId) : null);
  wireSaveOverride();

  window.playSkillActivationAudio = async function(skill){
    if(!skill) return false;
    const list = normActivationList(skill);
    if(!list.length) return false;
    await Promise.all(list.map(v=>playSkillAudioSpec(v.path||'', v.key||'', 0.78)));
    return true;
  };
  window.playSkillCoinAudio = async function(skill, coinIndex){
    if(!skill) return false;
    const slot = Math.max(1, Number(coinIndex||1));
    const map = normCoinVoiceMap(skill);
    const list = Array.isArray(map[slot]) ? map[slot] : [];
    if(!list.length) return false;
    await Promise.all(list.map(v=>playSkillAudioSpec(v.path||'', v.key||'', 0.72)));
    return true;
  };
})();

function isUnitStaggerLocked(unit){
  return !!(
    unit &&
    (
      unit.isStaggered ||
      unit.staggered ||
      Number(unit.staggerTurnsLeft || 0) > 0
    )
  );
}

</script>

<audio id="aiBattleBgm" preload="auto" loop></audio>
</body>
</html>
